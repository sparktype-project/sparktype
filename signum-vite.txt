FILE CONCATENATION REPORT
Root Directory: src/
Excluded Directories: public, node_modules, ios
File Extensions: *.ts, *.tsx, *.js, *.jsx, *.css, *.html, *.json, *.hbs
================================================================================

File: vite-env.d.ts
/// <reference types="vite/client" />


================================================================================

File: App.tsx
// src/App.tsx

import { Suspense, useEffect, useState, lazy } from 'react';
import { Routes, Route } from 'react-router-dom';

// Global State and UI Management
import { useAppStore } from './core/state/useAppStore';
import { useInitialiseUIStore } from './core/hooks/useInitialiseUIStore';
import { Toaster } from "./core/components/ui/sonner";

// --- Code-Splitting Page Imports using React.lazy ---
// This is a best practice to keep the initial bundle size small.
// Each page component is only loaded when its route is visited.

// Marketing and Site Management Pages
const MarketingHomePage = lazy(() => import('@/pages/MarketingHomePage')); // app/page.tsx
const HomePageDashboard = lazy(() => import('@/pages/HomePageDashboard')); // app/sites/page.tsx
const CreateSitePage = lazy(() => import('@/pages/CreateSitePage'));     // app/create-site/page.tsx

// Site-Specific Layouts and Pages
const SiteLayout = lazy(() => import('@/pages/sites/SiteLayout'));             // app/sites/[siteId]/layout.tsx
const SiteRootPage = lazy(() => import('@/pages/sites/SiteRootPage'));         // app/sites/[siteId]/page.tsx
const EditSiteLayout = lazy(() => import('@/pages/sites/edit/EditSiteLayout')); // app/sites/[siteId]/edit/layout.tsx
const EditContentPage = lazy(() => import('@/pages/sites/edit/EditContentPage'));// app/sites/[siteId]/edit/content/[[...slug]]/page.tsx
const SettingsSectionLayout = lazy(() => import('@/pages/sites/settings/SettingsSectionLayout')); // app/sites/[siteId]/settings/layout.tsx
const SiteSettingsPage = lazy(() => import('@/pages/sites/settings/SettingsSectionLayout'));         // app/sites/[siteId]/settings/page.tsx
const ThemeSettingsPage = lazy(() => import('@/pages/sites/settings/ThemeSettingsPage'));       // app/sites/[siteId]/settings/theme/page.tsx
const ImageSettingsPage = lazy(() => import('@/pages/sites/settings/ImageSettingsPage'));       // app/sites/[siteId]/settings/images/page.tsx
const ViewSitePage = lazy(() => import('@/pages/sites/view/ViewSitePage'));                     // app/sites/[siteId]/view/[[...slug]]/page.tsx

/**
 * A simple loading component to be used with Suspense while pages are being lazy-loaded.
 */
function AppLoadingIndicator() {
  return (
    <div className="flex items-center justify-center h-screen bg-background text-foreground">
      <div className="flex flex-col items-center">
        <svg className="animate-spin h-8 w-8 text-primary mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <p className="text-lg">Loading...</p>
      </div>
    </div>
  );
}

export default function App() {
  // This initialization logic is ported directly from your RootLayout.
  useInitialiseUIStore();
  const initialize = useAppStore(state => state.initialize);
  const isInitialized = useAppStore(state => state.isInitialized);
  const [clientMounted, setClientMounted] = useState(false);

  useEffect(() => {
    setClientMounted(true);
    if (!isInitialized) {
      initialize();
    }
  }, [initialize, isInitialized]);

  const showLoading = clientMounted && !isInitialized;

  if (showLoading) {
    return <AppLoadingIndicator />;
  }

  return (
    <>
      <Suspense fallback={<AppLoadingIndicator />}>
        <Routes>
          {/* Marketing Page Route */}
          <Route path="/" element={<MarketingHomePage />} />

          {/* Top-Level Dashboard & Creation Routes */}
          <Route path="/sites" element={<HomePageDashboard />} />
          <Route path="/create-site" element={<CreateSitePage />} />

          {/* 
            Site-Specific Nested Routes.
            The SiteLayout component will render an <Outlet /> where the nested routes will appear.
          */}
          <Route path="/sites/:siteId" element={<SiteLayout />}>
            {/* The index route for /sites/:siteId, which redirects */}
            <Route index element={<SiteRootPage />} />

            {/* Editor Routes */}
            <Route path="edit" element={<EditSiteLayout />}>
              {/* `*` is a wildcard that captures all sub-paths */}
              <Route path="content/*" element={<EditContentPage />} />
            </Route>

            {/* Settings Routes */}
            <Route path="settings" element={<SettingsSectionLayout />}>
              <Route index element={<SiteSettingsPage />} />
              <Route path="theme" element={<ThemeSettingsPage />} />
              <Route path="images" element={<ImageSettingsPage />} />
            </Route>
            
            {/* Viewer Route */}
            <Route path="view/*" element={<ViewSitePage />} />
          </Route>

          {/* Optional: A catch-all 404 route */}
          <Route path="*" element={<div>404 - Page Not Found</div>} />
        </Routes>
      </Suspense>

      {/* The global toaster for notifications */}
      <Toaster richColors position="top-right" />
    </>
  );
}

================================================================================

File: main.tsx
// src/main.tsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import { HashRouter } from 'react-router-dom';

import App from './App';
import './globals.css'; // Import global styles

// Error Boundary to catch any rendering errors at the very top level.
import ErrorBoundary from './core/components/ErrorBoundary'; 

// Providers
import { ThemeProvider } from './core/components/ThemeProvider';
import { EditorProvider } from './features/editor/contexts/EditorProvider';

// Find the root element from your index.html
const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Fatal Error: Root element with id 'root' not found in the DOM.");
}

ReactDOM.createRoot(rootElement).render(
  <React.StrictMode>
    <ErrorBoundary>
      {/* 
        The HashRouter is the outermost routing component. 
        It uses the URL hash for client-side routing.
      */}
      <HashRouter>
        {/*
          The ThemeProvider manages light/dark mode for the entire application.
          It's placed here to wrap all visible components.
        */}
        <ThemeProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
          disableTransitionOnChange
        >
          {/* 
            The EditorProvider manages the editor's save state and unsaved changes.
            Placing it here makes the editor context available to any route
            that needs it, like the editor pages and the header.
          */}
          <EditorProvider>
            <App />
          </EditorProvider>
        </ThemeProvider>
      </HashRouter>
    </ErrorBoundary>
  </React.StrictMode>
);

================================================================================

File: App.css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


================================================================================

File: index.css
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}


================================================================================

File: globals.css
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}


================================================================================

File: core/types/index.ts
// src/core/types/index.ts

// ============================================================================
// NEW & REFACTORED TYPES FOR THE LAYOUT-DRIVEN ARCHITECTURE
// ============================================================================

/**
 * Represents a single choice within a `DisplayOption` variant group.
 * e.g., A "Grid View" option within a "Listing Style" variant.
 */
export interface DisplayOptionChoice {
  name: string;
  description?: string;
  template: string;
}

/**
 * Defines a group of user-selectable display variants in a layout manifest.
 * e.g., The "Listing Style" variant, which contains "List" and "Grid" options.
 */
export interface DisplayOption {
  name: string;
  description?: string;
  default: string;
  options: Record<string, DisplayOptionChoice>;
}

/**
 * Represents the configuration stored in the frontmatter of a "Collection Page".
 * It stores the user's selected keys from the `display_options` defined in the layout.
 */
export interface CollectionConfig {
  [key: string]: string | number | undefined;
  sort_by?: string;
  sort_order?: 'asc' | 'desc';
  items_per_page?: number;
}

/**
 * Represents metadata for a layout asset in the file system.
 */
export interface LayoutInfo {
  id: string;
  name: string;
  type: 'page' | 'collection';
  path: string;
  description?: string;
}

// ============================================================================
// CORE DATA STRUCTURES
// ============================================================================

/**
 * Represents a node in the site's hierarchical structure, as defined in `manifest.json`.
 */
export interface StructureNode {
  type: 'page';
  title: string;
  menuTitle?: string;
  path: string;
  slug: string;
  navOrder?: number;
  children?: StructureNode[];
  [key: string]: unknown;
}

/**
 * Represents the theme-specific appearance configuration saved in the manifest.
 */
export interface ThemeConfig {
  name: string;
  config: Record<string, string | boolean | number>;
  themeData?: Record<string, unknown>;
}

/**
 * Represents metadata for a theme asset, used for populating UI selectors.
 */
export interface ThemeInfo {
  id: string;
  name: string;
  path: string;
}

/**
 * Represents the fields within a content file's YAML frontmatter.
 */
export interface MarkdownFrontmatter {
  title: string;
  layout: string; 
  collection?: CollectionConfig;
  homepage?: boolean;
  [key: string]: unknown;
}

/**
 * Represents a raw markdown file that has been parsed from storage.
 */
export interface ParsedMarkdownFile {
  slug: string;
  path: string;
  frontmatter: MarkdownFrontmatter;
  content: string;
}

/**
 * Represents a generic raw file (e.g., theme CSS, layout JSON) read from storage.
 */
export interface RawFile {
  path: string;
  content: string;
}

/**
 * Represents the data required for rendering pager controls.
 */
export interface PaginationData {
    currentPage: number;
    totalPages: number;
    totalItems: number;
    hasPrevPage: boolean;
    hasNextPage: boolean;
    prevPageUrl?: string;
    nextPageUrl?: string;
}

/**
 * Represents the main `manifest.json` file for a single site.
 */
export interface Manifest {
  siteId: string;
  generatorVersion: string;
  title: string;
  description: string;
  author?: string;
  baseUrl?: string;
  theme: ThemeConfig;
  structure: StructureNode[];
  layouts?: LayoutInfo[];
  themes?: ThemeInfo[];
  logo?: ImageRef;
  favicon?: ImageRef;
  settings?: {
    imageService?: 'local' | 'cloudinary';
    cloudinary?: {
      cloudName?: string;
    },
    [key: string]: unknown; 
  };
}

/**
 * Represents the complete data for a single site when held in the application's memory.
 */
export interface LocalSiteData {
  siteId: string;
  manifest: Manifest;
  contentFiles?: ParsedMarkdownFile[];
  layoutFiles?: RawFile[];
  themeFiles?: RawFile[];
  dataFiles?: Record<string, string>; // Added for storing data like categories.json
  secrets?: SiteSecrets;
}

// ============================================================================
// DERIVED & HELPER TYPES FOR RENDERING
// ============================================================================

/**
 * Represents a link used for rendering navigation menus.
 */
export interface NavLinkItem {
  href: string;
  label: string;
  isActive?: boolean;
  children?: NavLinkItem[];
}

/**
 * An enum to clearly distinguish the outcome of a page resolution attempt.
 */
export enum PageType {
  SinglePage,
  DynamicPage, // Added for dynamically generated pages like category archives
  NotFound,
}

/**
 * Represents a single term from a taxonomy data file (e.g., a single category).
 */
export interface TaxonomyTerm {
  slug: string;
  name: string;
  description?: string;
  [key: string]: unknown; // Allows for other properties
}

/**
 * The base structure for a page resolution result, containing common properties.
 */
interface BasePageResolution {
  pageTitle: string;
  layoutPath: string;
  collectionItems?: ParsedMarkdownFile[]; 
  pagination?: PaginationData;
}

/**
 * Represents the resolved data for a standard, static page from the `structure.json`.
 */
interface SinglePageResolution extends BasePageResolution {
  type: PageType.SinglePage;
  contentFile: ParsedMarkdownFile;
}

/**
 * --- NEW ---
 * Represents the resolved data for a dynamically generated page, like a category archive.
 * It includes the `term` (e.g., the specific category object) that this page represents.
 */
interface DynamicPageResolution extends BasePageResolution {
  type: PageType.DynamicPage;
  /** The content file of the parent collection (e.g., the main 'blog' page). */
  contentFile: ParsedMarkdownFile;
  /** The specific taxonomy term object (e.g., the category) this page is for. */
  term: TaxonomyTerm;
}

/**
 * Represents the complete, resolved data package for any page render.
 * This is the primary object passed to the theme engine.
 */
export type PageResolutionResult = 
  | SinglePageResolution
  | DynamicPageResolution
  | {
      type: PageType.NotFound;
      errorMessage: string;
    };


// ============================================================================
// IMAGE & SERVICE TYPES
// ============================================================================

/** The storable reference to an uploaded image. This goes in frontmatter. */
export interface ImageRef {
  serviceId: 'local' | 'cloudinary';
  src: string;
  alt?: string;
  width?: number;
  height?: number;
}

/** Transformation options requested by the theme engine. */
export interface ImageTransformOptions {
  width?: number;
  height?: number;
  crop?: 'fill' | 'fit' | 'scale';
  gravity?: 'center' | 'north' | 'south' | 'east' | 'west' | 'auto';
  format?: 'webp' | 'avif' | 'jpeg';
}

/** The interface/contract that all image services must implement. */
export interface ImageService {
  id: string;
  name: string;
  upload(file: File, siteId: string): Promise<ImageRef>;
  getDisplayUrl(manifest: Manifest, ref: ImageRef, options: ImageTransformOptions, isExport: boolean): Promise<string>;
  getExportableAssets(siteId: string, allImageRefs: ImageRef[]): Promise<{ path: string; data: Blob; }[]>;
}

/** Defines the shape of the sensitive, non-public data for a site. */
export interface SiteSecrets {
  cloudinary?: {
    uploadPreset?: string;
  };
}

/**
 * Represents the in-memory site bundle generated by the builder services.
 * It's a map of file paths to their content, which can be a string or a binary Blob.
 */
export interface SiteBundle {
  [filePath: string]: string | Blob;
}

================================================================================

File: core/libraries/markdownParser.ts
// src/lib/markdownParser.ts
import matter, { type Input } from 'gray-matter'; // Import GrayMatterOption and Input
//import { marked } from 'marked'; // For optional direct HTML rendering, though mostly client-side
import { type MarkdownFrontmatter, type ParsedMarkdownFile } from '@/core/types';
import yaml from 'js-yaml'; // For more robust YAML stringification

/**
 * Parses a raw markdown string (which includes YAML frontmatter) into an object
 * containing the frontmatter (as an object) and the markdown body content.
 *
 * @param rawMarkdown The complete markdown string with frontmatter.
 * @returns An object with `frontmatter` and `content` (markdown body).
 * @throws Error if frontmatter parsing fails.
 */
export function parseMarkdownString(rawMarkdown: string): { frontmatter: MarkdownFrontmatter, content: string } {
  try {
    // Ensure gray-matter options are correctly typed if needed, though defaults are often fine
    const { data, content: bodyContent } = matter(rawMarkdown as Input); // Cast to Input if type issues
    
    // Ensure title is always a string, provide default if missing or not string
    const title = typeof data.title === 'string' ? data.title : 'Untitled';

    return { 
      frontmatter: { ...data, title } as MarkdownFrontmatter, // Ensure title is part of the typed frontmatter
      content: bodyContent.trim() 
    };
  } catch (e) {
    console.error("Error parsing markdown string with gray-matter:", e);
    // Provide a more specific error message to the user
    throw new Error("Invalid YAML frontmatter format. Please check for syntax errors (e.g., unclosed quotes, incorrect indentation).");
  }
}

/**
 * Converts a frontmatter object and a markdown body content string back into
 * a single string formatted as YAML frontmatter followed by the markdown content.
 * Uses js-yaml for robust YAML serialization.
 *
 * @param frontmatter The frontmatter object.
 * @param content The markdown body content.
 * @returns A string combining serialized YAML frontmatter and markdown content.
 */
export function stringifyToMarkdown(frontmatter: MarkdownFrontmatter, content: string): string {
  try {
    // Filter out undefined or null values from frontmatter before stringifying
    const cleanedFrontmatter: Partial<MarkdownFrontmatter> = {};
    for (const key in frontmatter) {
      if (Object.prototype.hasOwnProperty.call(frontmatter, key) && frontmatter[key] !== undefined && frontmatter[key] !== null) {
        cleanedFrontmatter[key] = frontmatter[key];
      }
    }

    const fmString = Object.keys(cleanedFrontmatter).length > 0 
      ? yaml.dump(cleanedFrontmatter, { skipInvalid: true, indent: 2 }) // Use js-yaml for proper YAML formatting
      : ''; // No frontmatter if object is empty

    if (fmString) {
        return `---\n${fmString}---\n\n${content}`;
    }
    return content; // Return only content if no frontmatter

  } catch (e) {
    console.error("Error stringifying frontmatter to YAML:", e);
    // Fallback to simpler stringification or re-throw
    // For now, let's try a very basic fallback if yaml.dump fails for some reason
    let fallbackFmString = '';
    for (const key in frontmatter) {
        if (Object.prototype.hasOwnProperty.call(frontmatter, key)) {
            fallbackFmString += `${key}: ${String(frontmatter[key])}\n`;
        }
    }
    if (fallbackFmString) {
        return `---\n${fallbackFmString}---\n\n${content}`;
    }
    return content;
  }
}

/**
 * Parses a raw markdown string and also renders its body content to HTML using 'marked'.
 * This is primarily a utility if pre-rendered HTML is needed somewhere, but Sparktype focuses
 * on client-side rendering of raw markdown.
 *
 * @param slug The slug for the parsed file.
 * @param path The file path for the parsed file.
 * @param rawMarkdownContent The complete markdown string with frontmatter.
 * @returns A ParsedMarkdownFile object, potentially including htmlContent.
 */
export function parseAndRenderMarkdown(slug: string, path: string, rawMarkdownContent: string): ParsedMarkdownFile {
  const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
  
  // marked.parse can be configured with options if needed
  // const htmlContent = marked.parse(content) as string;

  return {
    slug,
    path,
    frontmatter,
    content,
    // htmlContent, // Uncomment if you decide to pre-render HTML
  };
}

================================================================================

File: core/libraries/browsingUtils.ts
// src/lib/browsingUtils.ts

export const REMOTE_SITE_ID_MARKER = "remote@";

export interface ParsedSiteIdentifier {
  rawParam: string;          // The original parameter from the URL
  cleanedIdOrUrl: string;  // The ID after basic cleaning (quotes, one layer of URI decode)
  isRemote: boolean;
  remoteBaseUrl: string | null; // Decoded and validated base URL if remote
  effectiveSiteId: string;     // The ID to use for fetching/internal logic (e.g. "actual-id" or "remote@actual-id")
}

/**
 * Parses the site identifier from URL parameters, handles decoding,
 * and determines if it's a local or remote site.
 * 
 * @param siteIdParam The raw siteId parameter from Next.js `useParams()`.
 * @returns ParsedSiteIdentifier object or null if siteIdParam is invalid.
 */
export function parseSiteIdentifier(siteIdParam: string | string[] | undefined): ParsedSiteIdentifier | null {
  let rawId = '';
  if (Array.isArray(siteIdParam)) {
    rawId = siteIdParam[0] || '';
  } else if (typeof siteIdParam === 'string') {
    rawId = siteIdParam;
  }

  if (!rawId) {
    console.warn("[BrowsingUtils] siteIdParam is empty or undefined.");
    return null;
  }

  let cleanedId = rawId;

  // Attempt to decode (browsers/Next.js might already do one layer)
  try {
    let decodedOnce = decodeURIComponent(cleanedId);
    // Heuristic: if it still contains '%', it might be double-encoded, especially if wrapped in quotes.
    if (decodedOnce.includes('%') && (decodedOnce.startsWith('"') || decodedOnce.startsWith('%22'))) {
        let temp = decodedOnce;
        if (temp.startsWith('%22')) temp = temp.substring(3); // Remove leading %22
        if (temp.endsWith('%22')) temp = temp.substring(0, temp.length - 3); // Remove trailing %22
        if (temp.startsWith('"')) temp = temp.substring(1); // Remove leading "
        if (temp.endsWith('"')) temp = temp.substring(0, temp.length - 1); // Remove trailing "
        decodedOnce = decodeURIComponent(temp);
    }
    cleanedId = decodedOnce;
  } catch (e) {
    console.warn(`[BrowsingUtils] decodeURIComponent failed for "${cleanedId}", using as is. Error:`, e);
  }

  // Final removal of surrounding quotes if present
  if (cleanedId.startsWith('"') && cleanedId.endsWith('"')) {
    cleanedId = cleanedId.substring(1, cleanedId.length - 1);
  }
  
  const isRemote = cleanedId.startsWith(REMOTE_SITE_ID_MARKER);
  let remoteBaseUrl: string | null = null;
  const effectiveSiteId = cleanedId; // For local sites, cleanedId is the effectiveSiteId

  if (isRemote) {
    const potentialUrl = cleanedId.substring(REMOTE_SITE_ID_MARKER.length);
    try {
      // The URL part should already be decoded by the steps above.
      // We just need to validate it's a URL.
      const urlObject = new URL(potentialUrl);
      remoteBaseUrl = urlObject.origin; // Use origin (scheme + hostname + port)
      // For remote sites, the cleanedId itself (e.g., "remote@http://...") is used as the key/identifier
      // for display and routing, but the actual ID fetched from manifest is what `LocalSiteData.siteId` will hold.
      // Let's keep `effectiveSiteId` as the full "remote@..." string for consistency in what the client uses
      // to identify this browsing session. The fetcher will derive the internal siteId.
    } catch (e) {
      console.error(`[BrowsingUtils] Invalid remote URL part: "${potentialUrl}" from "${cleanedId}"`, e);
      return { // Return a partial result indicating parsing failure for remote URL
          rawParam: rawId,
          cleanedIdOrUrl: cleanedId,
          isRemote: true,
          remoteBaseUrl: null, // Explicitly null due to error
          effectiveSiteId: cleanedId,
      }; 
    }
  }

  return {
    rawParam: rawId,
    cleanedIdOrUrl: cleanedId,
    isRemote,
    remoteBaseUrl,
    effectiveSiteId,
  };
}

================================================================================

File: core/libraries/utils.ts
// src/lib/utils.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function slugify(text: string): string {
  if (!text) return '';
  return text
    .toString()
    .normalize('NFKD') // Normalize accented characters
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-') // Replace spaces with -
    .replace(/[^\w-]+/g, '') // Remove all non-word chars except -
    .replace(/--+/g, '-'); // Replace multiple - with single -
}

export function generateSiteId(title: string): string {
  // Keep the random part short to avoid overly long site IDs
  const randomString = Math.random().toString(36).substring(2, 7); 
  const slugBase = slugify(title);
  // Truncate slugBase if it's too long to keep siteId reasonable
  const maxBaseLength = 50; 
  const truncatedSlugBase = slugBase.substring(0, maxBaseLength);
  return `${truncatedSlugBase}-${randomString}`;
}

================================================================================

File: core/libraries/remoteSiteFetcher.ts
// src/lib/remoteSiteFetcher.ts
import { type LocalSiteData, type ParsedMarkdownFile, type Manifest } from '@/core/types';
import { parseMarkdownString } from './markdownParser';
import { flattenStructure } from '../services/fileTree.service';

async function fetchRemoteFile(baseUrl: string, filePath: string): Promise<string> {
  const url = new URL(filePath, baseUrl).href;
  const response = await fetch(url, { cache: 'no-store' });
  if (!response.ok) {
    throw new Error(`Fetch failed for ${url}: ${response.statusText}`);
  }
  return response.text();
}

/**
 * Fetches and reconstructs an entire remote Sparktype site into the LocalSiteData format.
 * It fetches the manifest, then fetches all content files listed within it.
 * @param remoteSiteUrl The base URL of the remote Sparktype site.
 * @returns A Promise that resolves to a complete LocalSiteData object, or null if fetching fails.
 */
export async function fetchRemoteSiteData(remoteSiteUrl: string): Promise<LocalSiteData | null> {
  if (!remoteSiteUrl || !remoteSiteUrl.startsWith('http')) {
    console.error(`Invalid remoteSiteUrl provided: ${remoteSiteUrl}`);
    return null;
  }

  try {
    // 1. Fetch manifest.json, which is now the single source of truth.
    const manifestString = await fetchRemoteFile(remoteSiteUrl, '_site/manifest.json');
    const manifest: Manifest = JSON.parse(manifestString);

    if (!manifest || !manifest.siteId || !manifest.structure) {
        throw new Error("Invalid manifest structure fetched from remote site.");
    }
    
    // 2. Collect all unique file paths from the manifest structure.
    const allPageNodes = flattenStructure(manifest.structure);
    const contentFilePaths = [...new Set(allPageNodes.map(node => node.path))];

    // 3. Fetch all content files in parallel.
    const contentFilesPromises = contentFilePaths.map(async (path) => {
        try {
            const rawMarkdown = await fetchRemoteFile(remoteSiteUrl, `_site/${path}`);
            const { frontmatter, content } = parseMarkdownString(rawMarkdown);
            const slug = path.substring(path.lastIndexOf('/') + 1).replace('.md', '');
            return { slug, path, frontmatter, content };
        } catch (error) {
            console.warn(`Could not fetch or parse content file: ${path}`, error);
            return null; // Return null on failure for this specific file
        }
    });
    
    const resolvedContentFiles = await Promise.all(contentFilesPromises);
    const validContentFiles = resolvedContentFiles.filter(file => file !== null) as ParsedMarkdownFile[];

    // 4. Construct the final LocalSiteData object.
    const finalSiteData: LocalSiteData = {
      siteId: `remote-${manifest.siteId}`, // Prefix to distinguish in local state
      manifest: manifest,
      contentFiles: validContentFiles,
    };

    return finalSiteData;

  } catch (error) {
    console.error(`CRITICAL ERROR fetching remote site data for ${remoteSiteUrl}:`, error);
    return null;
  }
}

================================================================================

File: core/libraries/__tests__/utils.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import { slugify, generateSiteId, cn } from '../utils';

describe('utils', () => {
  describe('slugify', () => {
    test('converts text to lowercase slug', () => {
      expect(slugify('Hello World')).toBe('hello-world');
    });

    test('handles empty string', () => {
      expect(slugify('')).toBe('');
    });

    test('handles null and undefined', () => {
      expect(slugify(null as any)).toBe('');
      expect(slugify(undefined as any)).toBe('');
    });

    test('normalizes accented characters', () => {
      expect(slugify('CafÃ© NiÃ±o')).toBe('cafe-nino');
      expect(slugify('Ã…pfel Ãœber')).toBe('apfel-uber');
      expect(slugify('JosÃ© MarÃ­a')).toBe('jose-maria');
    });

    test('removes special characters', () => {
      expect(slugify('Hello@World#2024!')).toBe('helloworld2024');
      expect(slugify('Price: $99.99')).toBe('price-9999');
      expect(slugify('User & Admin')).toBe('user-admin');
    });

    test('replaces multiple spaces with single dash', () => {
      expect(slugify('Hello    World')).toBe('hello-world');
      expect(slugify('Multiple   Spaces  Here')).toBe('multiple-spaces-here');
    });

    test('replaces multiple dashes with single dash', () => {
      expect(slugify('Hello--World')).toBe('hello-world');
      expect(slugify('Multiple---Dashes')).toBe('multiple-dashes');
    });

    test('trims whitespace', () => {
      expect(slugify('  Hello World  ')).toBe('hello-world');
      expect(slugify('\t\nHello World\t\n')).toBe('hello-world');
    });

    test('handles numbers', () => {
      expect(slugify('Blog Post 123')).toBe('blog-post-123');
      expect(slugify('2024 Year in Review')).toBe('2024-year-in-review');
    });

    test('handles unicode characters', () => {
      expect(slugify('ðŸŽ‰ Party Time! ðŸŽŠ')).toBe('party-time');
      expect(slugify('Test ä¸­æ–‡ Content')).toBe('test-content');
    });

    test('handles mixed case and special characters', () => {
      expect(slugify('CamelCase-with_underscores')).toBe('camelcase-withunderscores');
      expect(slugify('API v2.0 (Beta)')).toBe('api-v20-beta');
    });

    test('handles very long strings', () => {
      const longText = 'a'.repeat(200);
      const result = slugify(longText);
      expect(result).toBe('a'.repeat(200));
      expect(result.length).toBe(200);
    });
  });

  describe('generateSiteId', () => {
    test('generates site ID with title slug and random string', () => {
      const result = generateSiteId('My Blog');
      expect(result).toMatch(/^my-blog-[a-z0-9]{5}$/);
    });

    test('handles empty title', () => {
      const result = generateSiteId('');
      expect(result).toMatch(/^-[a-z0-9]{5}$/);
    });

    test('truncates long titles', () => {
      const longTitle = 'A'.repeat(100);
      const result = generateSiteId(longTitle);
      
      // Should be truncated to 50 chars + dash + 5 random chars = 56 total
      expect(result.length).toBe(56);
      expect(result).toMatch(/^a{50}-[a-z0-9]{5}$/);
    });

    test('handles special characters in title', () => {
      const result = generateSiteId('My @#$% Blog!');
      expect(result).toMatch(/^my-blog-[a-z0-9]{5}$/);
    });

    test('generates unique IDs for same title', () => {
      const id1 = generateSiteId('Test Blog');
      const id2 = generateSiteId('Test Blog');
      
      expect(id1).not.toBe(id2);
      expect(id1.startsWith('test-blog-')).toBe(true);
      expect(id2.startsWith('test-blog-')).toBe(true);
    });

    test('handles accented characters', () => {
      const result = generateSiteId('CafÃ© Blog');
      expect(result).toMatch(/^cafe-blog-[a-z0-9]{5}$/);
    });

    test('random part is always 5 characters', () => {
      // Test multiple generations to ensure consistency
      for (let i = 0; i < 10; i++) {
        const result = generateSiteId('Test');
        const randomPart = result.split('-').pop();
        expect(randomPart).toHaveLength(5);
        expect(randomPart).toMatch(/^[a-z0-9]{5}$/);
      }
    });

    test('handles edge case of exactly 50 character title', () => {
      const title = 'a'.repeat(50);
      const result = generateSiteId(title);
      expect(result.length).toBe(56); // 50 + 1 dash + 5 random
      expect(result).toMatch(/^a{50}-[a-z0-9]{5}$/);
    });

    test('handles title with only special characters', () => {
      const result = generateSiteId('@#$%^&*()');
      expect(result).toMatch(/^-[a-z0-9]{5}$/);
    });
  });

  describe('cn (className utility)', () => {
    test('merges class names', () => {
      expect(cn('class1', 'class2')).toBe('class1 class2');
    });

    test('handles conditional classes', () => {
      expect(cn('base', true && 'conditional', false && 'hidden')).toBe('base conditional');
    });

    test('handles Tailwind conflicts', () => {
      // twMerge should resolve conflicting Tailwind classes
      expect(cn('px-2', 'px-4')).toBe('px-4');
      expect(cn('text-red-500', 'text-blue-500')).toBe('text-blue-500');
    });

    test('handles arrays', () => {
      expect(cn(['class1', 'class2'])).toBe('class1 class2');
    });

    test('handles objects', () => {
      expect(cn({ 'class1': true, 'class2': false, 'class3': true })).toBe('class1 class3');
    });

    test('handles empty inputs', () => {
      expect(cn()).toBe('');
      expect(cn('')).toBe('');
      expect(cn(null)).toBe('');
      expect(cn(undefined)).toBe('');
    });

    test('handles mixed input types', () => {
      expect(cn(
        'base',
        ['array-class'],
        { 'object-class': true },
        true && 'conditional',
        ''
      )).toBe('base array-class object-class conditional');
    });
  });
});

================================================================================

File: core/libraries/__tests__/browsingUtils.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import { parseSiteIdentifier, REMOTE_SITE_ID_MARKER } from '../browsingUtils';

describe('browsingUtils', () => {
  describe('parseSiteIdentifier', () => {
    test('handles local site ID string', () => {
      const result = parseSiteIdentifier('my-blog-abc123');
      
      expect(result).not.toBeNull();
      expect(result!.rawParam).toBe('my-blog-abc123');
      expect(result!.cleanedIdOrUrl).toBe('my-blog-abc123');
      expect(result!.isRemote).toBe(false);
      expect(result!.remoteBaseUrl).toBeNull();
      expect(result!.effectiveSiteId).toBe('my-blog-abc123');
    });

    test('handles site ID array (takes first element)', () => {
      const result = parseSiteIdentifier(['site-id-1', 'site-id-2']);
      
      expect(result).not.toBeNull();
      expect(result!.rawParam).toBe('site-id-1');
      expect(result!.cleanedIdOrUrl).toBe('site-id-1');
      expect(result!.isRemote).toBe(false);
      expect(result!.effectiveSiteId).toBe('site-id-1');
    });

    test('handles empty array', () => {
      const result = parseSiteIdentifier([]);
      
      expect(result).toBeNull();
    });

    test('handles undefined parameter', () => {
      const result = parseSiteIdentifier(undefined);
      
      expect(result).toBeNull();
    });

    test('handles empty string', () => {
      const result = parseSiteIdentifier('');
      
      expect(result).toBeNull();
    });

    test('handles quoted site ID', () => {
      const result = parseSiteIdentifier('"my-blog-abc123"');
      
      expect(result).not.toBeNull();
      expect(result!.cleanedIdOrUrl).toBe('my-blog-abc123');
      expect(result!.isRemote).toBe(false);
    });

    test('handles URL encoded site ID', () => {
      const encoded = encodeURIComponent('my-blog-abc123');
      const result = parseSiteIdentifier(encoded);
      
      expect(result).not.toBeNull();
      expect(result!.cleanedIdOrUrl).toBe('my-blog-abc123');
      expect(result!.isRemote).toBe(false);
    });

    test('handles double URL encoded quoted site ID', () => {
      // Simulate double encoding that might happen in some routing scenarios
      const doubleEncoded = encodeURIComponent(encodeURIComponent('"my-blog-abc123"'));
      const result = parseSiteIdentifier(doubleEncoded);
      
      expect(result).not.toBeNull();
      expect(result!.cleanedIdOrUrl).toBe('my-blog-abc123');
      expect(result!.isRemote).toBe(false);
    });

    test('handles malformed URL encoding gracefully', () => {
      const malformed = 'my-blog%ZZ'; // Invalid URL encoding
      const result = parseSiteIdentifier(malformed);
      
      expect(result).not.toBeNull();
      expect(result!.cleanedIdOrUrl).toBe('my-blog%ZZ'); // Should use as-is
      expect(result!.isRemote).toBe(false);
    });

    test('handles remote site URL', () => {
      const remoteId = `${REMOTE_SITE_ID_MARKER}https://example.com`;
      const result = parseSiteIdentifier(remoteId);
      
      expect(result).not.toBeNull();
      expect(result!.rawParam).toBe(remoteId);
      expect(result!.cleanedIdOrUrl).toBe(remoteId);
      expect(result!.isRemote).toBe(true);
      expect(result!.remoteBaseUrl).toBe('https://example.com');
      expect(result!.effectiveSiteId).toBe(remoteId);
    });

    test('handles remote site URL with port', () => {
      const remoteId = `${REMOTE_SITE_ID_MARKER}https://example.com:8080`;
      const result = parseSiteIdentifier(remoteId);
      
      expect(result).not.toBeNull();
      expect(result!.isRemote).toBe(true);
      expect(result!.remoteBaseUrl).toBe('https://example.com:8080');
    });

    test('handles remote site URL with path (extracts origin)', () => {
      const remoteId = `${REMOTE_SITE_ID_MARKER}https://example.com/some/path`;
      const result = parseSiteIdentifier(remoteId);
      
      expect(result).not.toBeNull();
      expect(result!.isRemote).toBe(true);
      expect(result!.remoteBaseUrl).toBe('https://example.com');
    });

    test('handles HTTP (non-HTTPS) remote URL', () => {
      const remoteId = `${REMOTE_SITE_ID_MARKER}http://localhost:3000`;
      const result = parseSiteIdentifier(remoteId);
      
      expect(result).not.toBeNull();
      expect(result!.isRemote).toBe(true);
      expect(result!.remoteBaseUrl).toBe('http://localhost:3000');
    });

    test('handles invalid remote URL', () => {
      const remoteId = `${REMOTE_SITE_ID_MARKER}not-a-valid-url`;
      const result = parseSiteIdentifier(remoteId);
      
      expect(result).not.toBeNull();
      expect(result!.isRemote).toBe(true);
      expect(result!.remoteBaseUrl).toBeNull(); // Should be null due to invalid URL
      expect(result!.effectiveSiteId).toBe(remoteId);
    });

    test('handles quoted remote site URL', () => {
      const remoteId = `"${REMOTE_SITE_ID_MARKER}https://example.com"`;
      const result = parseSiteIdentifier(remoteId);
      
      expect(result).not.toBeNull();
      expect(result!.cleanedIdOrUrl).toBe(`${REMOTE_SITE_ID_MARKER}https://example.com`);
      expect(result!.isRemote).toBe(true);
      expect(result!.remoteBaseUrl).toBe('https://example.com');
    });

    test('handles URL encoded remote site URL', () => {
      const remoteUrl = `${REMOTE_SITE_ID_MARKER}https://example.com/path?param=value`;
      const encoded = encodeURIComponent(remoteUrl);
      const result = parseSiteIdentifier(encoded);
      
      expect(result).not.toBeNull();
      expect(result!.isRemote).toBe(true);
      expect(result!.remoteBaseUrl).toBe('https://example.com');
    });

    test('handles complex encoding scenario with quotes and remote URL', () => {
      const remoteUrl = `${REMOTE_SITE_ID_MARKER}https://example.com`;
      const quotedAndEncoded = encodeURIComponent(`"${remoteUrl}"`);
      const result = parseSiteIdentifier(quotedAndEncoded);
      
      expect(result).not.toBeNull();
      expect(result!.isRemote).toBe(true);
      expect(result!.remoteBaseUrl).toBe('https://example.com');
    });

    test('handles edge case with only quotes', () => {
      const result = parseSiteIdentifier('""');
      
      expect(result).not.toBeNull();
      expect(result!.cleanedIdOrUrl).toBe('');
      expect(result!.isRemote).toBe(false);
    });

    test('handles site ID that starts with remote marker but is not remote', () => {
      // Edge case where someone might have a site ID that coincidentally starts with the marker
      const confusingId = `${REMOTE_SITE_ID_MARKER}local-site-id`;
      const result = parseSiteIdentifier(confusingId);
      
      expect(result).not.toBeNull();
      expect(result!.isRemote).toBe(true); // Would be treated as remote
      expect(result!.remoteBaseUrl).toBeNull(); // But URL parsing would fail
    });

    test('preserves special characters in local site IDs', () => {
      const result = parseSiteIdentifier('my-blog_test.site-123');
      
      expect(result).not.toBeNull();
      expect(result!.cleanedIdOrUrl).toBe('my-blog_test.site-123');
      expect(result!.isRemote).toBe(false);
    });

    test('handles deeply nested encoding', () => {
      const original = 'my-blog-123';
      const deeplyEncoded = encodeURIComponent(encodeURIComponent(encodeURIComponent(original)));
      const result = parseSiteIdentifier(deeplyEncoded);
      
      // The function only does one level of decoding, so deeply encoded strings won't be fully decoded
      expect(result).not.toBeNull();
      expect(result!.isRemote).toBe(false);
      // The exact result depends on how the decoding handles this case
    });

    test('handles international domain names', () => {
      const remoteId = `${REMOTE_SITE_ID_MARKER}https://ä¾‹ãˆ.ãƒ†ã‚¹ãƒˆ`;
      const result = parseSiteIdentifier(remoteId);
      
      expect(result).not.toBeNull();
      expect(result!.isRemote).toBe(true);
      // URL constructor should handle IDN correctly
      expect(result!.remoteBaseUrl).toContain('ä¾‹ãˆ.ãƒ†ã‚¹ãƒˆ');
    });
  });

  describe('REMOTE_SITE_ID_MARKER', () => {
    test('has expected value', () => {
      expect(REMOTE_SITE_ID_MARKER).toBe('remote@');
    });
  });
});

================================================================================

File: core/libraries/__tests__/markdownParser.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import { parseMarkdownString, stringifyToMarkdown, parseAndRenderMarkdown } from '../markdownParser';
import { MarkdownFrontmatter } from '@/core/types';

describe('markdownParser', () => {
  describe('parseMarkdownString', () => {
    test('parses markdown with valid frontmatter', () => {
      const input = `---
title: Test Post
date: 2024-01-01
tags: [test, markdown]
---

# Hello World

This is a test post.`;

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.title).toBe('Test Post');
      expect(result.frontmatter.date).toEqual(new Date('2024-01-01'));
      expect(result.frontmatter.tags).toEqual(['test', 'markdown']);
      expect(result.content).toBe('# Hello World\n\nThis is a test post.');
    });

    test('handles markdown without frontmatter', () => {
      const input = `# Just Markdown

No frontmatter here.`;

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.title).toBe('Untitled');
      expect(result.content).toBe('# Just Markdown\n\nNo frontmatter here.');
    });

    test('provides default title when missing', () => {
      const input = `---
date: 2024-01-01
---

Content without title.`;

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.title).toBe('Untitled');
      expect(result.frontmatter.date).toEqual(new Date('2024-01-01'));
    });

    test('handles non-string title', () => {
      const input = `---
title: 123
---

Content with numeric title.`;

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.title).toBe('Untitled');
    });

    test('trims content whitespace', () => {
      const input = `---
title: Test
---


  # Content with extra whitespace  


`;

      const result = parseMarkdownString(input);
      
      expect(result.content).toBe('# Content with extra whitespace');
    });

    test('throws error for invalid YAML frontmatter', () => {
      const input = `---
title: "Unclosed quote
date: invalid-yaml
---

Content`;

      expect(() => parseMarkdownString(input)).toThrow('Invalid YAML frontmatter format');
    });

    test('handles empty frontmatter', () => {
      const input = `---
---

Just content.`;

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.title).toBe('Untitled');
      expect(result.content).toBe('Just content.');
    });

    test('handles complex frontmatter data types', () => {
      const input = `---
title: Complex Post
published: true
priority: 5
tags:
  - web
  - development
author:
  name: John Doe
  email: john@example.com
---

Complex frontmatter content.`;

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.title).toBe('Complex Post');
      expect(result.frontmatter.published).toBe(true);
      expect(result.frontmatter.priority).toBe(5);
      expect(result.frontmatter.tags).toEqual(['web', 'development']);
      expect(result.frontmatter.author).toEqual({
        name: 'John Doe',
        email: 'john@example.com'
      });
    });

    test('handles malformed frontmatter delimiters', () => {
      const input = `--
title: Test
--

Content`;

      const result = parseMarkdownString(input);
      
      // Should treat the whole thing as content since delimiters are wrong
      expect(result.frontmatter.title).toBe('Untitled');
      expect(result.content).toContain('--\ntitle: Test\n--\n\nContent');
    });

    test('handles frontmatter with tabs and mixed indentation', () => {
      const input = `---
title: Test With Tabs
date: 2024-01-01
tags:
  - mixed
  - indentation
---

Content with tabs.`;

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.title).toBe('Test With Tabs');
      expect(result.frontmatter.date).toEqual(new Date('2024-01-01'));
      expect(result.frontmatter.tags).toEqual(['mixed', 'indentation']);
    });

    test('handles frontmatter with Unicode characters', () => {
      const input = `---
title: "TÃ«st PÃ¸st with ä¸­æ–‡ and ðŸš€"
author: "JÃ¼rgen MÃ¼ller"
tags: [ä¸­æ–‡, "Ñ€ÑƒÑÑÐºÐ¸Ð¹", "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"]
---

# Content with Ã©mojis ðŸŽ‰

Some Unicode content: cafÃ©, naÃ¯ve, rÃ©sumÃ©.`;

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.title).toBe('TÃ«st PÃ¸st with ä¸­æ–‡ and ðŸš€');
      expect(result.frontmatter.author).toBe('JÃ¼rgen MÃ¼ller');
      expect(result.frontmatter.tags).toEqual(['ä¸­æ–‡', 'Ñ€ÑƒÑÑÐºÐ¸Ð¹', 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©']);
      expect(result.content).toContain('Ã©mojis ðŸŽ‰');
      expect(result.content).toContain('cafÃ©, naÃ¯ve, rÃ©sumÃ©');
    });

    test('handles extremely long frontmatter values', () => {
      const longString = 'a'.repeat(10000);
      const input = `---
title: ${longString}
description: Short description
---

Content here.`;

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.title).toBe(longString);
      expect(result.frontmatter.description).toBe('Short description');
      expect(result.content).toBe('Content here.');
    });

    test('handles YAML with special characters and escaping', () => {
      const input = `---
title: "Quote test: \\"nested quotes\\" work"
path: "C:\\\\Windows\\\\path"
regex: "/test[a-z]+\\\\d{3}/"
multiline: |
  Line 1
  Line 2 with "quotes"
  Line 3
---

Content with special chars.`;

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.title).toBe('Quote test: "nested quotes" work');
      expect(result.frontmatter.path).toBe('C:\\Windows\\path');
      expect(result.frontmatter.regex).toBe('/test[a-z]+\\d{3}/');
      expect(result.frontmatter.multiline).toContain('Line 1\nLine 2 with "quotes"\nLine 3');
    });

    test('handles YAML parsing edge cases', () => {
      const input = `---
boolean_true: true
boolean_false: false
number_int: 42
number_float: 3.14
null_value: null
empty_string: ""
zero: 0
negative: -5
scientific: 1.23e-4
---

Edge case content.`;

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.boolean_true).toBe(true);
      expect(result.frontmatter.boolean_false).toBe(false);
      expect(result.frontmatter.number_int).toBe(42);
      expect(result.frontmatter.number_float).toBe(3.14);
      expect(result.frontmatter.null_value).toBe(null);
      expect(result.frontmatter.empty_string).toBe('');
      expect(result.frontmatter.zero).toBe(0);
      expect(result.frontmatter.negative).toBe(-5);
      expect(result.frontmatter.scientific).toBe(1.23e-4);
    });

    test('handles frontmatter only (no content)', () => {
      const input = `---
title: Frontmatter Only
date: 2024-01-01
---`;

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.title).toBe('Frontmatter Only');
      expect(result.frontmatter.date).toEqual(new Date('2024-01-01'));
      expect(result.content).toBe('');
    });

    test('handles content only (no frontmatter markers)', () => {
      const input = `This is just plain content
with multiple lines
and no frontmatter at all.

Even with line breaks.`;

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.title).toBe('Untitled');
      expect(result.content).toBe(input);
    });

    test('handles multiple frontmatter delimiter attempts', () => {
      const input = `---
title: First
---

Some content

---
title: Second
---

More content`;

      const result = parseMarkdownString(input);
      
      // Should only parse the first frontmatter block
      expect(result.frontmatter.title).toBe('First');
      expect(result.content).toContain('Some content\n\n---\ntitle: Second\n---\n\nMore content');
    });

    test('handles YAML with deeply nested objects', () => {
      const input = `---
title: Deep Nesting
config:
  level1:
    level2:
      level3:
        deep_value: "found it"
        array_deep:
          - item1
          - nested_item: true
---

Deep content.`;

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.title).toBe('Deep Nesting');
      const config = result.frontmatter.config as Record<string, unknown>;
      const level1 = config.level1 as Record<string, unknown>;
      const level2 = level1.level2 as Record<string, unknown>;
      const level3 = level2.level3 as Record<string, unknown>;
      expect(level3.deep_value).toBe('found it');
      expect((level3.array_deep as unknown[])[0]).toBe('item1');
      expect((level3.array_deep as unknown[])[1]).toEqual({ nested_item: true });
    });
  });

  describe('stringifyToMarkdown', () => {
    test('converts frontmatter and content to markdown string', () => {
      const frontmatter: MarkdownFrontmatter = {
        title: 'Test Post',
        layout: 'post',
        date: '2024-01-01',
        tags: ['test', 'markdown']
      };
      const content = '# Hello World\n\nThis is a test.';

      const result = stringifyToMarkdown(frontmatter, content);
      
      expect(result).toContain('---\n');
      expect(result).toContain('title: Test Post');
      expect(result).toContain('layout: post');
      expect(result).toContain('date: \'2024-01-01\'');
      expect(result).toContain('tags:\n  - test\n  - markdown');
      expect(result).toContain('---\n\n# Hello World\n\nThis is a test.');
    });

    test('handles empty frontmatter', () => {
      const content = 'Just content.';

      // Clear all properties except title to simulate empty frontmatter
      const emptyFrontmatter = { title: undefined } as any;
      
      const result = stringifyToMarkdown(emptyFrontmatter, content);
      
      expect(result).toBe('Just content.');
      expect(result).not.toContain('---');
    });

    test('filters out null and undefined values', () => {
      const frontmatter: MarkdownFrontmatter = {
        title: 'Test Post',
        layout: 'post',
        date: undefined as any,
        tags: null as any,
        published: true
      };
      const content = 'Content here.';

      const result = stringifyToMarkdown(frontmatter, content);
      
      expect(result).toContain('title: Test Post');
      expect(result).toContain('published: true');
      expect(result).not.toContain('date:');
      expect(result).not.toContain('tags:');
    });

    test('handles complex nested objects', () => {
      const frontmatter: MarkdownFrontmatter = {
        title: 'Complex Post',
        layout: 'post',
        author: {
          name: 'John Doe',
          email: 'john@example.com'
        } as Record<string, unknown>,
        metadata: {
          priority: 5,
          featured: true
        } as Record<string, unknown>
      };
      const content = 'Complex content.';

      const result = stringifyToMarkdown(frontmatter, content);
      
      expect(result).toContain('title: Complex Post');
      expect(result).toContain('author:');
      expect(result).toContain('name: John Doe');
      expect(result).toContain('email: john@example.com');
      expect(result).toContain('metadata:');
      expect(result).toContain('priority: 5');
      expect(result).toContain('featured: true');
    });

    test('handles arrays in frontmatter', () => {
      const frontmatter: MarkdownFrontmatter = {
        title: 'Array Test',
        layout: 'post',
        tags: ['one', 'two', 'three'] as any,
        numbers: [1, 2, 3] as any
      };
      const content = 'Array content.';

      const result = stringifyToMarkdown(frontmatter, content);
      
      expect(result).toContain('tags:\n  - one\n  - two\n  - three');
      expect(result).toContain('numbers:\n  - 1\n  - 2\n  - 3');
    });

    test('escapes special YAML characters', () => {
      const frontmatter: MarkdownFrontmatter = {
        title: 'Title with: colon',
        layout: 'post',
        description: 'Description with "quotes" and \'apostrophes\'' as any
      };
      const content = 'Special characters content.';

      const result = stringifyToMarkdown(frontmatter, content);
      
      // YAML should properly escape these
      expect(result).toContain('title: \'Title with: colon\'');
      expect(result).toMatch(/description: ['"]?Description with "quotes".*['"]?/);
    });

    test('roundtrip test - parse then stringify', () => {
      const original = `---
title: Roundtrip Test
date: '2024-01-01'
tags:
  - test
  - roundtrip
published: true
---

# Roundtrip Content

This should survive the roundtrip.`;

      const parsed = parseMarkdownString(original);
      const stringified = stringifyToMarkdown(parsed.frontmatter, parsed.content);
      const reparsed = parseMarkdownString(stringified);

      expect(reparsed.frontmatter.title).toBe('Roundtrip Test');
      expect(reparsed.frontmatter.date).toBe('2024-01-01');
      expect(reparsed.frontmatter.tags).toEqual(['test', 'roundtrip']);
      expect(reparsed.frontmatter.published).toBe(true);
      expect(reparsed.content).toBe('# Roundtrip Content\n\nThis should survive the roundtrip.');
    });

    test('handles empty content', () => {
      const frontmatter: MarkdownFrontmatter = {
        title: 'Empty Content Test',
        layout: 'post'
      };
      const content = '';

      const result = stringifyToMarkdown(frontmatter, content);
      
      expect(result).toContain('title: Empty Content Test');
      expect(result).toContain('layout: post');
      expect(result).toContain('---\n\n');
      expect(result.endsWith('\n\n')).toBe(true);
    });

    test('handles content with only whitespace', () => {
      const frontmatter: MarkdownFrontmatter = {
        title: 'Whitespace Test',
        layout: 'post'
      };
      const content = '   \n\n\t  \n   ';

      const result = stringifyToMarkdown(frontmatter, content);
      
      expect(result).toContain('title: Whitespace Test');
      // Should trim whitespace content
      expect(result.trim()).toMatch(/---\s*$/);
    });

    test('preserves boolean false values', () => {
      const frontmatter: MarkdownFrontmatter = {
        title: 'Boolean Test',
        layout: 'post',
        published: false as any,
        draft: true as any
      };
      const content = 'Boolean content.';

      const result = stringifyToMarkdown(frontmatter, content);
      
      expect(result).toContain('published: false');
      expect(result).toContain('draft: true');
    });

    test('preserves zero values', () => {
      const frontmatter: MarkdownFrontmatter = {
        title: 'Zero Test',
        layout: 'post',
        rating: 0 as any,
        count: 0 as any
      };
      const content = 'Zero content.';

      const result = stringifyToMarkdown(frontmatter, content);
      
      expect(result).toContain('rating: 0');
      expect(result).toContain('count: 0');
    });

    test('handles Unicode in frontmatter output', () => {
      const frontmatter: MarkdownFrontmatter = {
        title: 'ÃœnÃ¯cÃ¸dÃ© TÃ©st ðŸŽ‰',
        layout: 'post',
        author: 'JosÃ© MarÃ­a' as any,
        tags: ['ä¸­æ–‡', 'Ñ€ÑƒÑÑÐºÐ¸Ð¹'] as any
      };
      const content = 'Unicode content with Ã©mojis ðŸš€.';

      const result = stringifyToMarkdown(frontmatter, content);
      
      expect(result).toMatch(/title: ['"]?ÃœnÃ¯cÃ¸dÃ© TÃ©st ðŸŽ‰['"]?/);
      expect(result).toMatch(/author: ['"]?JosÃ© MarÃ­a['"]?/);
      expect(result).toContain('- ä¸­æ–‡');
      expect(result).toContain('- Ñ€ÑƒÑÑÐºÐ¸Ð¹');
      expect(result).toContain('Unicode content with Ã©mojis ðŸš€');
    });

    test('handles very large arrays', () => {
      const largeTags = Array.from({ length: 100 }, (_, i) => `tag${i}`);
      const frontmatter: MarkdownFrontmatter = {
        title: 'Large Array Test',
        layout: 'post',
        tags: largeTags as any
      };
      const content = 'Large array content.';

      const result = stringifyToMarkdown(frontmatter, content);
      
      expect(result).toContain('title: Large Array Test');
      expect(result).toContain('- tag0');
      expect(result).toContain('- tag99');
      largeTags.forEach(tag => {
        expect(result).toContain(`- ${tag}`);
      });
    });
  });

  describe('parseAndRenderMarkdown', () => {
    test('creates ParsedMarkdownFile object', () => {
      const rawContent = `---
title: Test File
date: 2024-01-01
---

# Test Content

This is a test file.`;

      const result = parseAndRenderMarkdown('test-slug', '/path/to/file.md', rawContent);

      expect(result.slug).toBe('test-slug');
      expect(result.path).toBe('/path/to/file.md');
      expect(result.frontmatter.title).toBe('Test File');
      expect(result.frontmatter.date).toEqual(new Date('2024-01-01'));
      expect(result.content).toBe('# Test Content\n\nThis is a test file.');
    });

    test('handles file without frontmatter', () => {
      const rawContent = `# Just Content

No frontmatter in this file.`;

      const result = parseAndRenderMarkdown('content-only', '/content.md', rawContent);

      expect(result.slug).toBe('content-only');
      expect(result.path).toBe('/content.md');
      expect(result.frontmatter.title).toBe('Untitled');
      expect(result.content).toBe('# Just Content\n\nNo frontmatter in this file.');
    });

    test('passes through parsing errors', () => {
      const rawContent = `---
title: "Invalid YAML
---

Content`;

      expect(() => parseAndRenderMarkdown('error-test', '/error.md', rawContent))
        .toThrow('Invalid YAML frontmatter format');
    });

    test('handles empty raw content', () => {
      const result = parseAndRenderMarkdown('empty', '/empty.md', '');

      expect(result.slug).toBe('empty');
      expect(result.path).toBe('/empty.md');
      expect(result.frontmatter.title).toBe('Untitled');
      expect(result.content).toBe('');
    });

    test('handles very long file paths', () => {
      const longPath = '/very/deep/nested/directory/structure/with/many/levels/of/nesting/that/goes/on/and/on/file.md';
      const rawContent = `---
title: Long Path Test
---

Content for long path.`;

      const result = parseAndRenderMarkdown('long-path', longPath, rawContent);

      expect(result.slug).toBe('long-path');
      expect(result.path).toBe(longPath);
      expect(result.frontmatter.title).toBe('Long Path Test');
    });

    test('handles special characters in slug and path', () => {
      const specialSlug = 'test-slug-with-ä¸­æ–‡-and-Ã©mojis-ðŸš€';
      const specialPath = '/path/with spaces/and-ä¸­æ–‡/file.md';
      const rawContent = `---
title: Special Characters
---

Special content.`;

      const result = parseAndRenderMarkdown(specialSlug, specialPath, rawContent);

      expect(result.slug).toBe(specialSlug);
      expect(result.path).toBe(specialPath);
      expect(result.frontmatter.title).toBe('Special Characters');
    });

    test('preserves all frontmatter properties', () => {
      const rawContent = `---
title: Complete Test
author: Test Author
date: 2024-01-01
published: true
tags: [test, complete]
metadata:
  category: testing
  priority: high
---

Complete content.`;

      const result = parseAndRenderMarkdown('complete', '/complete.md', rawContent);

      expect(result.frontmatter.title).toBe('Complete Test');
      expect(result.frontmatter.author).toBe('Test Author');
      expect(result.frontmatter.date).toEqual(new Date('2024-01-01'));
      expect(result.frontmatter.published).toBe(true);
      expect(result.frontmatter.tags).toEqual(['test', 'complete']);
      expect((result.frontmatter.metadata as any).category).toBe('testing');
      expect((result.frontmatter.metadata as any).priority).toBe('high');
    });
  });

  describe('Performance and Edge Cases', () => {
    test('handles very large markdown content', () => {
      const largeContent = 'This is a line of content.\n'.repeat(10000);
      const input = `---
title: Large Content Test
---

${largeContent}`;

      const start = performance.now();
      const result = parseMarkdownString(input);
      const end = performance.now();

      expect(result.frontmatter.title).toBe('Large Content Test');
      expect(result.content).toContain('This is a line of content.');
      expect(result.content.split('\n')).toHaveLength(10000); // 10000 lines
      expect(end - start).toBeLessThan(1000); // Should complete within 1 second
    });

    test('handles very large frontmatter with many properties', () => {
      const frontmatterEntries = Array.from({ length: 1000 }, (_, i) => `prop${i}: value${i}`).join('\n');
      const input = `---
title: Large Frontmatter Test
${frontmatterEntries}
---

Content here.`;

      const start = performance.now();
      const result = parseMarkdownString(input);
      const end = performance.now();

      expect(result.frontmatter.title).toBe('Large Frontmatter Test');
      expect((result.frontmatter as any).prop0).toBe('value0');
      expect((result.frontmatter as any).prop999).toBe('value999');
      expect(end - start).toBeLessThan(1000); // Should complete within 1 second
    });

    test('handles markdown with no line breaks', () => {
      const input = '---\ntitle: No Breaks\n---\nContent without any line breaks in a very long single line that goes on and on and should still be parsed correctly by the markdown parser.';

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.title).toBe('No Breaks');
      expect(result.content).toContain('Content without any line breaks');
    });

    test('handles extremely nested YAML structures', () => {
      const input = `---
title: Deep Nesting
level1:
  level2:
    level3:
      level4:
        level5:
          level6:
            level7:
              level8:
                level9:
                  level10:
                    deep_value: "maximum depth"
---

Deep nesting content.`;

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.title).toBe('Deep Nesting');
      expect((result.frontmatter as any).level1.level2.level3.level4.level5.level6.level7.level8.level9.level10.deep_value).toBe('maximum depth');
    });

    test('handles frontmatter with binary-like data', () => {
      const binaryString = Array.from({ length: 100 }, () => Math.random() > 0.5 ? '1' : '0').join('');
      const input = `---
title: Binary Test
binary_data: "${binaryString}"
hex_data: "0x${Array.from({ length: 32 }, () => Math.floor(Math.random() * 16).toString(16)).join('')}"
---

Binary content.`;

      const result = parseMarkdownString(input);
      
      expect(result.frontmatter.title).toBe('Binary Test');
      expect((result.frontmatter as any).binary_data).toBe(binaryString);
      expect((result.frontmatter as any).hex_data).toMatch(/^0x[0-9a-f]{32}$/);
    });

    test('handles roundtrip with complex Unicode and special characters', () => {
      const complexContent = `# Test with ä¸­æ–‡, Ã‘oÃ±o, and ðŸŽ‰

This content has:
- Unicode: cafÃ©, naÃ¯ve, rÃ©sumÃ©
- Emojis: ðŸš€ ðŸŽ¯ ðŸ’» ðŸ”¥
- Mathematical symbols: âˆ‘ âˆ† Ï€ âˆž
- Currency: â‚¬ $ Â¥ Â£
- Special chars: @#$%^&*()_+-={}[]|\\:";'<>?,./`;

      const frontmatter: MarkdownFrontmatter = {
        title: 'Complex Unicode Test ðŸŒ',
        layout: 'post',
        tags: ['unicode', 'ä¸­æ–‡', 'Ã©mojis'] as any,
        description: 'Test with cafÃ© and naÃ¯ve words ðŸŽ‰' as any
      };

      const stringified = stringifyToMarkdown(frontmatter, complexContent);
      const reparsed = parseMarkdownString(stringified);

      expect(reparsed.frontmatter.title).toBe('Complex Unicode Test ðŸŒ');
      expect(reparsed.frontmatter.tags).toEqual(['unicode', 'ä¸­æ–‡', 'Ã©mojis']);
      expect(reparsed.content).toContain('cafÃ©, naÃ¯ve, rÃ©sumÃ©');
      expect(reparsed.content).toContain('ðŸš€ ðŸŽ¯ ðŸ’» ðŸ”¥');
      expect(reparsed.content).toContain('âˆ‘ âˆ† Ï€ âˆž');
    });

    test('performance test for parseAndRenderMarkdown with large files', () => {
      const largeRawContent = `---
title: Performance Test
author: Test Author
tags: ${JSON.stringify(Array.from({ length: 100 }, (_, i) => `tag${i}`))}
metadata:
  large_array: ${JSON.stringify(Array.from({ length: 1000 }, (_, i) => ({ id: i, value: `item${i}` })))}
---

${'# Performance test content\n\nThis is line content.\n'.repeat(1000)}`;

      const start = performance.now();
      const result = parseAndRenderMarkdown('perf-test', '/large-file.md', largeRawContent);
      const end = performance.now();

      expect(result.slug).toBe('perf-test');
      expect(result.frontmatter.title).toBe('Performance Test');
      expect((result.frontmatter.tags as any)).toHaveLength(100);
      expect((result.frontmatter.metadata as any).large_array).toHaveLength(1000);
      expect(end - start).toBeLessThan(2000); // Should complete within 2 seconds
    });
  });
});

================================================================================

File: core/state/uiStore.ts
// src/core/state/uiStore.ts

import { create, type StateCreator } from 'zustand';
import { type ReactNode } from 'react';

// --- Helper for screen size ---
const isDesktopView = () => typeof window !== 'undefined' && window.innerWidth >= 1024;

// --- Type Definitions for the store structure ---

// Defines the shape of the data in the sidebar slice
interface SidebarState {
  isLeftOpen: boolean;
  isRightOpen: boolean;
  isLeftAvailable: boolean;
  isRightAvailable: boolean;
  leftSidebarContent: ReactNode | null;
  rightSidebarContent: ReactNode | null;
}

// Defines the actions available in the sidebar slice
interface SidebarActions {
  toggleLeftSidebar: () => void;
  toggleRightSidebar: () => void;
  setLeftAvailable: (available: boolean) => void;
  setRightAvailable: (available: boolean) => void;
  setRightOpen: (isOpen: boolean) => void;
  setLeftSidebarContent: (content: ReactNode | null) => void;
  setRightSidebarContent: (content: ReactNode | null) => void;
}

// Defines the shape of the data in the screen slice
interface ScreenState {
  isDesktop: boolean;
  isInitialized: boolean;
}

// Defines the actions available in the screen slice
interface ScreenActions {
    initializeScreenSize: () => void;
}

// The full store shape, combining state and actions
type UIState = {
    sidebar: SidebarState & SidebarActions;
    screen: ScreenState & ScreenActions;
}

// --- Store Slice Implementations ---

// Creates the sidebar slice of the store
const createSidebarSlice: StateCreator<UIState, [], [], { sidebar: SidebarState & SidebarActions }> = (set, get) => ({
  sidebar: {
    isLeftOpen: isDesktopView(),
    isRightOpen: isDesktopView(),
    isLeftAvailable: false,
    isRightAvailable: false,
    leftSidebarContent: null,
    rightSidebarContent: null,
    toggleLeftSidebar: () => set(state => ({ 
        sidebar: { 
            ...state.sidebar, 
            isLeftOpen: !state.sidebar.isLeftOpen, 
            // On mobile, opening one sidebar closes the other
            isRightOpen: !get().screen.isDesktop && !state.sidebar.isLeftOpen ? false : state.sidebar.isRightOpen 
        }
    })),
    toggleRightSidebar: () => set(state => ({ 
        sidebar: { 
            ...state.sidebar, 
            isRightOpen: !state.sidebar.isRightOpen, 
            isLeftOpen: !get().screen.isDesktop && !state.sidebar.isRightOpen ? false : state.sidebar.isLeftOpen 
        }
    })),
    setLeftAvailable: (available) => set(state => ({ sidebar: { ...state.sidebar, isLeftAvailable: available }})),
    setRightAvailable: (available) => set(state => ({ sidebar: { ...state.sidebar, isRightAvailable: available }})),
    setRightOpen: (isOpen) => set(state => ({ sidebar: { ...state.sidebar, isRightOpen: isOpen }})),
    setLeftSidebarContent: (content) => set(state => ({ sidebar: { ...state.sidebar, leftSidebarContent: content }})),
    setRightSidebarContent: (content) => set(state => ({ sidebar: { ...state.sidebar, rightSidebarContent: content }})),

  }
});

// Creates the screen slice of the store
const createScreenSlice: StateCreator<UIState, [], [], { screen: ScreenState & ScreenActions }> = (set, get) => ({
    screen: {
        isDesktop: isDesktopView(),
        isInitialized: false, // Initialize the flag to false
        initializeScreenSize: () => {
          // Add a guard clause to prevent running more than once
          if (get().screen.isInitialized) return;

          // Set the flag to true immediately to block re-entry
          set(state => ({
            screen: { ...state.screen, isInitialized: true }
          }));

          if (typeof window === 'undefined') return;

          const handleResize = () => {
            const desktop = isDesktopView();
            if (desktop !== get().screen.isDesktop) {
              set({
                  screen: { ...get().screen, isDesktop: desktop },
                  sidebar: { ...get().sidebar, isLeftOpen: desktop, isRightOpen: desktop }
                });
            }
          };
          window.addEventListener('resize', handleResize);
          handleResize();
        },
    }
});


// Combine the slices to create the final store
export const useUIStore = create<UIState>()((...a) => ({
    ...createSidebarSlice(...a),
    ...createScreenSlice(...a),
}));

================================================================================

File: core/state/useAppStore.ts
// src/core/state/useAppStore.ts
import { create, type StoreApi } from 'zustand';
import { enableMapSet } from 'immer';
import { type SiteSlice, createSiteSlice } from './slices/siteSlice';
import { type ContentSlice, createContentSlice } from './slices/contentSlice';
import { type SecretsSlice, createSecretsSlice } from './slices/secretsSlice';

// Enable Immer for Map and Set support, which is good practice with Zustand.
enableMapSet();

/**
 * The full, combined type for the application's global store.
 * It's an intersection of all slice types plus root-level state.
 */
export type AppStore = SiteSlice & ContentSlice & SecretsSlice & {
  isInitialized: boolean;
  initialize: () => void;
  activeSiteId: string | null;
  setActiveSiteId: (siteId: string | null) => void;
};

/**
 * The main application store, built with Zustand.
 * It combines multiple "slices" of state for better organization.
 */
export const useAppStore = create<AppStore>()((set, get, api) => ({
  // --- Root State Properties ---
  isInitialized: false,
  activeSiteId: null,

  // --- Root State Actions ---

  /**
   * Initializes the application state. This should only be called once when the app loads.
   * It prevents re-initialization and triggers the hydration of sites from local storage.
   */
  initialize: () => {
    if (get().isInitialized) {
      return;
    }

    console.log('[AppStore] Initializing application state...');
    
    // Call the hydration action to load sites from storage.
    get().initializeSites().then(() => {
        set({ isInitialized: true });
        console.log('[AppStore] State initialized.');
    }).catch((error) => {
        console.error('[AppStore] Failed to initialize application state:', error);
        // Initialize anyway to prevent hanging
        set({ isInitialized: true });
        console.log('[AppStore] State initialized with errors.');
    });
  },

  /**
   * Sets the currently active site ID for the application.
   * @param siteId The ID of the site to set as active, or null to clear it.
   */
  setActiveSiteId: (siteId) => {
    set({ activeSiteId: siteId });
  },

  // --- Slices ---
  // The store is composed of smaller, focused slices of state.
  // --- FIX: Pass all three arguments (set, get, api) to each slice creator. ---
  // This satisfies the StateCreator type contract and resolves the build errors.
  ...createSiteSlice(set, get, api as StoreApi<AppStore>),
  ...createContentSlice(set, get, api as StoreApi<AppStore>),
  ...createSecretsSlice(set, get, api as StoreApi<AppStore>),
}));

================================================================================

File: core/state/slices/contentSlice.ts
// src/core/state/slices/contentSlice.ts
import { type StateCreator } from 'zustand';
import { produce } from 'immer';
import { toast } from 'sonner';
import { type ParsedMarkdownFile, type StructureNode, type LocalSiteData } from '@/core/types';
import * as localSiteFs from '@/core/services/localFileSystem.service';
import { getLayoutManifest, type LayoutManifest } from '@/core/services/config/configHelpers.service';
import {
  findAndRemoveNode,
  updatePathsRecursively,
  findNodeByPath,
  getNodeDepth,
} from '@/core/services/fileTree.service';
import { type SiteSlice } from '@/core/state/slices/siteSlice';
import { stringifyToMarkdown, parseMarkdownString } from '@/core/libraries/markdownParser';

/**
 * A simple template renderer for path strings.
 * Replaces {{key}} with the corresponding value from the context object.
 * @param {string} templateString - The string containing placeholders (e.g., "data/{{collection.slug}}_categories.json").
 * @param {Record<string, any>} context - An object with keys matching the placeholders.
 * @returns {string} The resolved string.
 */
function renderPathTemplate(templateString: string, context: Record<string, unknown>): string {
    let result = templateString;
    const regex = /{{\s*([^}]+)\s*}}/g;
    let match;
    while ((match = regex.exec(templateString)) !== null) {
        const keyPath = match[1]; // e.g., 'collection.slug'
        const keys = keyPath.split('.');
        let value: unknown = context;
        for (const k of keys) {
            value = (value as Record<string, unknown>)?.[k];
        }
        
        // --- FIX: Ensure the replacement value is a primitive before calling replace. ---
        // This prevents passing an object to String.prototype.replace().
        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
            result = result.replace(match[0], String(value));
        } else {
            console.warn(`[renderPathTemplate] Could not resolve complex value for placeholder: ${match[0]}`);
        }
    }
    return result;
}

/**
 * Checks a layout manifest for a `data_files` contract and initializes any
 * missing data files for the site. This is a critical part of the "plug-and-play"
 * layout system.
 * @param {LocalSiteData} site The full site data object.
 * @param {LayoutManifest} layoutManifest The manifest of the layout being applied.
 * @param {ParsedMarkdownFile} collectionPageFile The content file for the collection page itself.
 */
async function initializeLayoutDataFiles(site: LocalSiteData, layoutManifest: LayoutManifest, collectionPageFile: ParsedMarkdownFile) {
    if (!layoutManifest.data_files || layoutManifest.data_files.length === 0) {
        return; // No data files to initialize for this layout.
    }

    const allDataFiles = await localSiteFs.getAllDataFiles(site.siteId);

    for (const dataFileDef of layoutManifest.data_files) {
        const pathContext = { collection: { slug: collectionPageFile.slug } };
        const finalPath = renderPathTemplate(dataFileDef.path_template, pathContext);

        // Only create the file if it does not already exist.
        if (!allDataFiles[finalPath]) {
            console.log(`[Data Init] Data file not found at "${finalPath}". Creating...`);
            const initialContent = JSON.stringify(dataFileDef.initial_content || [], null, 2);
            await localSiteFs.saveDataFile(site.siteId, finalPath, initialContent);
            toast.info(`Initialized data file for "${dataFileDef.id}".`);
        }
    }
}

/**
 * Helper function to update file paths in an array of content files.
 */
const updateContentFilePaths = (files: ParsedMarkdownFile[], pathsToMove: { oldPath: string; newPath:string }[]): ParsedMarkdownFile[] => {
    const pathMap = new Map(pathsToMove.map(p => [p.oldPath, p.newPath]));
    return files.map(file => {
        if (pathMap.has(file.path)) {
            const newPath = pathMap.get(file.path)!;
            const newSlug = newPath.split('/').pop()?.replace('.md', '') ?? '';
            return { ...file, path: newPath, slug: newSlug };
        }
        // --- FIX: Always return the file, even if it hasn't changed. ---
        // This ensures the .map() function doesn't return `undefined`.
        return file;
    });
};

/**
 * The interface for all actions related to content file management.
 */
export interface ContentSlice {
  addOrUpdateContentFile: (siteId: string, filePath: string, rawMarkdownContent: string) => Promise<boolean>;
  deleteContentFileAndState: (siteId: string, filePath: string) => Promise<void>;
  repositionNode: (siteId: string, activeNodePath: string, newParentPath: string | null, newIndex: number) => Promise<void>;
  updateContentFileOnly: (siteId: string, savedFile: ParsedMarkdownFile) => Promise<void>;
}

/**
 * Creates the content management slice of the Zustand store.
 */
export const createContentSlice: StateCreator<SiteSlice & ContentSlice, [], [], ContentSlice> = (set, get) => ({

  /**
   * A lightweight action to save changes to an existing file without modifying the site structure.
   */
  updateContentFileOnly: async (siteId, savedFile) => {
    await localSiteFs.saveContentFile(siteId, savedFile.path, stringifyToMarkdown(savedFile.frontmatter, savedFile.content));
    set(produce((draft: SiteSlice) => {
      const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
      if (siteToUpdate?.contentFiles) {
        const fileIndex = siteToUpdate.contentFiles.findIndex(f => f.path === savedFile.path);
        if (fileIndex !== -1) siteToUpdate.contentFiles[fileIndex] = savedFile;
        else siteToUpdate.contentFiles.push(savedFile);
      }
    }));
  },

  /**
   * The primary action for creating or updating a content file. This function is now responsible
   * for initializing associated data files when a new Collection Page is created.
   */
  addOrUpdateContentFile: async (siteId, filePath, rawMarkdownContent) => {
    const site = get().getSiteById(siteId);
    if (!site) return false;

    // --- Standard logic for parsing and saving the file ---
    let { frontmatter } = parseMarkdownString(rawMarkdownContent);
    const { content } = parseMarkdownString(rawMarkdownContent);
    const isFirstFile = site.manifest.structure.length === 0 && !site.contentFiles?.some(f => f.path === filePath);
    if (isFirstFile) {
        toast.info("First page created. It has been set as the permanent homepage.");
        frontmatter = { ...frontmatter, homepage: true };
        rawMarkdownContent = stringifyToMarkdown(frontmatter, content);
    }
    const savedFile = await localSiteFs.saveContentFile(siteId, filePath, rawMarkdownContent);
    const isNewFileInStructure = !findNodeByPath(site.manifest.structure, filePath);

    // --- NEW: Data File Initialization Logic ---
    // If we are creating a new Collection Page, check its layout for data dependencies.
    if (isNewFileInStructure && savedFile.frontmatter.collection) {
        const layoutManifest = await getLayoutManifest(site, savedFile.frontmatter.layout);
        if (layoutManifest) {
            // Call the helper to create any missing data files.
            await initializeLayoutDataFiles(site, layoutManifest, savedFile);
        }
    }
    // --- END NEW ---

    // --- Standard logic for updating the manifest and in-memory state ---
    const newManifest = produce(site.manifest, draft => {
      if (isNewFileInStructure) {
        const newNode: StructureNode = {
          type: 'page',
          title: savedFile.frontmatter.title,
          menuTitle: typeof savedFile.frontmatter.menuTitle === 'string' ? savedFile.frontmatter.menuTitle : undefined,
          path: filePath,
          slug: savedFile.slug,
          navOrder: draft.structure.length,
          children: [],
        };
        
        // Check if this should be a collection item by looking for a parent collection
        const pathParts = filePath.split('/');
        if (pathParts.length > 2) { // e.g., "content/news/item.md" has 3 parts
          const parentDir = pathParts.slice(0, -1).join('/'); // "content/news"
          const parentPath = `${parentDir}.md`; // "content/news.md"
          
          const parentFile = site.contentFiles?.find((f: ParsedMarkdownFile) => f.path === parentPath);
          if (parentFile?.frontmatter.collection) {
            // This is a collection item - find parent in structure and add as child
            const findAndAddToParent = (nodes: StructureNode[]): boolean => {
              for (const node of nodes) {
                if (node.path === parentPath) {
                  if (!node.children) node.children = [];
                  newNode.navOrder = node.children.length;
                  node.children.push(newNode);
                  return true;
                }
                if (node.children && findAndAddToParent(node.children)) {
                  return true;
                }
              }
              return false;
            };
            
            if (!findAndAddToParent(draft.structure)) {
              // Parent not found in structure, add to root as fallback
              draft.structure.push(newNode);
            }
          } else {
            // Regular page - add to root
            draft.structure.push(newNode);
          }
        } else {
          // Root level page - add to root
          draft.structure.push(newNode);
        }
      } else {
        const findAndUpdate = (nodes: StructureNode[]): void => {
          for (const node of nodes) {
            if (node.path === filePath) {
              node.title = savedFile.frontmatter.title;
              node.menuTitle = typeof savedFile.frontmatter.menuTitle === 'string' ? savedFile.frontmatter.menuTitle : undefined;
              return;
            }
            if (node.children) findAndUpdate(node.children);
          }
        };
        findAndUpdate(draft.structure);
      }
    });

    await get().updateManifest(siteId, newManifest);

    set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate) {
          if (!siteToUpdate.contentFiles) siteToUpdate.contentFiles = [];
          const fileIndex = siteToUpdate.contentFiles.findIndex(f => f.path === savedFile.path);
          if (fileIndex !== -1) siteToUpdate.contentFiles[fileIndex] = savedFile;
          else siteToUpdate.contentFiles.push(savedFile);
        }
      }));
    return true;
  },
    
  deleteContentFileAndState: async (siteId, filePath) => {
    const site = get().getSiteById(siteId);
    if (!site) return;
    const fileToDelete = site.contentFiles?.find(f => f.path === filePath);
    if (fileToDelete?.frontmatter.homepage === true) {
      toast.error("Cannot delete the homepage.", { description: "The first page of a site is permanent." });
      return;
    }
    const newManifest = produce(site.manifest, draft => {
      const filterStructure = (nodes: StructureNode[]): StructureNode[] => nodes.filter(node => {
        if (node.path === filePath) return false;
        if (node.children) node.children = filterStructure(node.children);
        return true;
      });
      draft.structure = filterStructure(draft.structure);
    });
    await Promise.all([
      localSiteFs.deleteContentFile(siteId, filePath),
      get().updateManifest(siteId, newManifest),
    ]);
    set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate?.contentFiles) {
          siteToUpdate.contentFiles = siteToUpdate.contentFiles.filter(f => f.path !== filePath);
        }
      }));
    toast.success(`Page "${fileToDelete?.frontmatter.title || 'file'}" deleted.`);
  },
    
  repositionNode: async (siteId, activeNodePath, newParentPath, newIndex) => {
    const site = get().getSiteById(siteId);
    if (!site?.contentFiles || !site.manifest) {
      toast.error("Site data not ready. Cannot move page.");
      return;
    }

    const structure = site.manifest.structure;
    const homepagePath = structure[0]?.path;

    if (activeNodePath === homepagePath) {
      toast.error("The homepage cannot be moved.");
      return;
    }

    const nodeToMove = findNodeByPath(structure, activeNodePath);
    if (newParentPath && nodeToMove?.children && nodeToMove.children.length > 0) {
      toast.error("Cannot nest a page that already has its own child pages.", {
        description: "This would create too many levels of nesting."
      });
      return;
    }
    
    if (newParentPath) {
      const parentNode = findNodeByPath(structure, newParentPath);
      if (!parentNode) {
        toast.error("Target parent page for nesting not found.");
        return;
      }
      
      // --- FIX: Update depth check to allow nesting up to 3 levels total. ---
      // A parent can be at depth 0 or 1. A page at depth 2 cannot be a parent.
      const parentDepth = getNodeDepth(structure, newParentPath);
      if (parentDepth >= 2) {
        toast.error("Nesting is limited to two levels deep (3 levels total).");
        return;
      }
      
      const parentFile = site.contentFiles.find(f => f.path === newParentPath);
      if (parentFile?.frontmatter.collection) {
        toast.error("Pages cannot be nested under a Collection Page.");
        return;
      }
    }

    const { found: activeNode, tree: treeWithoutActive } = findAndRemoveNode([...structure], activeNodePath);
    if (!activeNode) return;

    const newParentDir = newParentPath ? newParentPath.replace(/\.md$/, '') : 'content';
    const finalActiveNode = updatePathsRecursively(activeNode, newParentDir);
    
    const pathsToMove: { oldPath: string; newPath: string }[] = [];
    const collectPaths = (newNode: StructureNode, oldNode: StructureNode) => {
        if (newNode.path !== oldNode.path) pathsToMove.push({ oldPath: oldNode.path, newPath: newNode.path });
        if (newNode.children && oldNode.children) newNode.children.forEach((child, i) => collectPaths(child, oldNode.children![i]));
    };
    collectPaths(finalActiveNode, activeNode);
    
    const finalTree = produce(treeWithoutActive, draft => {
        if (newParentPath) {
            const parent = findNodeByPath(draft, newParentPath);
            if (parent) {
                parent.children = parent.children || [];
                parent.children.splice(newIndex, 0, finalActiveNode);
            }
        } else {
            draft.splice(newIndex, 0, finalActiveNode);
        }
    });
    
    try {
      if (pathsToMove.length > 0) await localSiteFs.moveContentFiles(siteId, pathsToMove);
      const newManifest = { ...site.manifest, structure: finalTree };
      const updatedContentFiles = updateContentFilePaths(site.contentFiles, pathsToMove);
      set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate) {
          siteToUpdate.manifest = newManifest;
          siteToUpdate.contentFiles = updatedContentFiles;
        }
      }));
      await localSiteFs.saveManifest(siteId, newManifest);
      toast.success("Site structure updated successfully.");
    } catch (error) {
      console.error("Failed to reposition node:", error);
      toast.error("An error occurred while updating the site structure. Reverting changes.");
      get().loadSite(siteId);
    }
  },
});

================================================================================

File: core/state/slices/siteSlice.ts
// src/core/state/slices/siteSlice.ts

import { type StateCreator } from 'zustand';
import { produce } from 'immer';
import {  type LocalSiteData,  type Manifest } from '@/core/types';
import * as localSiteFs from '@/core/services/localFileSystem.service';
import { loadSiteSecretsFromDb } from '@/core/services/siteSecrets.service';
import { toast } from 'sonner';

export interface SiteSlice {
  sites: LocalSiteData[];
  loadingSites: Set<string>;
  getSiteById: (siteId: string) => LocalSiteData | undefined;
  loadSite: (siteId: string) => Promise<void>;
  addSite: (siteData: LocalSiteData) => Promise<void>;
  updateManifest: (siteId: string, manifest: Manifest) => Promise<void>;
  deleteSiteAndState: (siteId: string) => Promise<void>;
  initializeSites: () => Promise<void>;
}

export const createSiteSlice: StateCreator<SiteSlice, [], [], SiteSlice> = (set, get) => ({
  sites: [],
  loadingSites: new Set(),
  getSiteById: (siteId) => get().sites.find(s => s.siteId === siteId),

  initializeSites: async () => {
    // ... (this function is correct, no changes needed)
    try {
      const manifests = await localSiteFs.loadAllSiteManifests();
      const initialSites: LocalSiteData[] = manifests.map(manifest => ({
        siteId: manifest.siteId,
        manifest: manifest,
      }));
      set({ sites: initialSites });
    } catch (error) {
      console.error("Failed to initialize sites from storage:", error);
      toast.error("Could not load your sites. Storage might be corrupted.");
    }
  },

  loadSite: async (siteId) => {
    // --- FIX: This logic is now non-destructive ---
    if (get().loadingSites.has(siteId)) return;
    
    const existingSite = get().getSiteById(siteId);
    // Only fetch if core content files aren't already loaded.
    if (existingSite && existingSite.contentFiles) return;
    
    set(produce(draft => { draft.loadingSites.add(siteId); }));

    try {
      const manifest = await localSiteFs.getManifestById(siteId);
      if (!manifest) throw new Error(`Failed to load manifest for siteId: ${siteId}`);
      
      const [contentFiles, layoutFiles, themeFiles, secrets] = await Promise.all([
        localSiteFs.getSiteContentFiles(siteId),
        localSiteFs.getSiteLayoutFiles(siteId),
        localSiteFs.getSiteThemeFiles(siteId),
        loadSiteSecretsFromDb(siteId)
      ]);

      const loadedData = { manifest, contentFiles, layoutFiles, themeFiles, secrets };

      set(produce((draft: SiteSlice) => {
        const siteIndex = draft.sites.findIndex(s => s.siteId === siteId);
        if (siteIndex > -1) {
          // Instead of replacing, we MERGE the loaded data into the existing object.
          // This preserves any other data that might already be in the in-memory state.
          draft.sites[siteIndex] = { ...draft.sites[siteIndex], ...loadedData };
        } else {
          // If it's a new site being loaded, add it.
          draft.sites.push({ siteId, ...loadedData });
        }
      }));
    } catch (error) {
      toast.error(`Could not load site data for ID: ${siteId}`);
      console.error(`[AppStore.loadSite] Error during load for ${siteId}:`, error);
    } finally {
      set(produce(draft => { draft.loadingSites.delete(siteId); }));
    }
  },
  
  // --- This action is now safe to use because loadSite is no longer destructive ---
  updateManifest: async (siteId, newManifest) => {
    await localSiteFs.saveManifest(siteId, newManifest);
    set(produce((draft: SiteSlice) => {
      const site = draft.sites.find(s => s.siteId === siteId);
      if (site) site.manifest = newManifest;
    }));
  },

  // ... (addSite and deleteSiteAndState remain the same)
  addSite: async (newSiteData) => {
    await localSiteFs.saveSite(newSiteData);
    set(produce((draft: SiteSlice) => {
      const siteIndex = draft.sites.findIndex(s => s.siteId === newSiteData.siteId);
      if (siteIndex > -1) {
        draft.sites[siteIndex] = newSiteData;
      } else {
        draft.sites.push(newSiteData);
      }
    }));
  },

  deleteSiteAndState: async (siteId) => {
    await localSiteFs.deleteSite(siteId);
    set(produce((draft: SiteSlice) => {
      draft.sites = draft.sites.filter(s => s.siteId !== siteId);
    }));
  },
});

================================================================================

File: core/state/slices/secretsSlice.ts
// src/core/state/slices/secretsSlice.ts
import { type StateCreator } from 'zustand';
import { produce } from 'immer';
import { type SiteSlice } from './siteSlice';
import { type SiteSecrets, saveSiteSecretsToDb } from '@/core/services/siteSecrets.service';
import { toast } from 'sonner';

export interface SecretsSlice {
  /**
   * Updates the secrets for a site, persisting them to storage first
   * and then updating the in-memory state.
   * @param siteId The ID of the site to update.
   * @param secrets The new secrets object to save.
   */
  updateSiteSecrets: (siteId: string, secrets: SiteSecrets) => Promise<void>;
}

export const createSecretsSlice: StateCreator<SiteSlice & SecretsSlice, [], [], SecretsSlice> = (set) => ({
  updateSiteSecrets: async (siteId, newSecrets) => {
    try {
      await saveSiteSecretsToDb(siteId, newSecrets);
      set(produce((draft: SiteSlice) => {
        const site = draft.sites.find(s => s.siteId === siteId);
        if (site) {
          site.secrets = newSecrets;
        }
      }));
      toast.success("Secret settings saved successfully!");
    } catch (error) {
      console.error("Failed to save site secrets:", error);
      toast.error("Could not save secret settings.");
      throw error;
    }
  },
});

================================================================================

File: core/components/Navbar.tsx
// src/core/components/Navbar.tsx

import React, { useState } from 'react';
import { Link, useLocation, useNavigate } from 'react-router-dom';
import { Leaf, Home, Settings, Globe } from 'lucide-react';
import { toast } from 'sonner';

// UI Components (no changes needed)
import { Button } from '@/core/components/ui/button';
import { Input } from '@/core/components/ui/input';
import { cn } from '@/core/libraries/utils';

/**
 * A specialized NavLink component for the main navigation.
 * It uses react-router-dom's useLocation hook to determine if it's the active link.
 */
const NavLink: React.FC<{ to: string; label: string; icon?: React.ReactNode; }> = ({ to, label, icon }) => {
  const location = useLocation();
  // Check if the current path exactly matches or starts with the link's path.
  // This handles nested routes correctly. The `to !== '/'` check prevents the root link
  // from being active for all other routes.
  const isActive = location.pathname === to || (to !== '/' && location.pathname.startsWith(to));

  return (
    // The `asChild` prop on Button allows the Link to control navigation while inheriting the button's styles.
    <Button asChild variant="ghost" className={cn('justify-start', isActive && 'bg-accent text-accent-foreground')}>
      <Link to={to} className="flex items-center space-x-2">
        {icon}
        <span>{label}</span>
      </Link>
    </Button>
  );
};

export default function Navbar() {
  const navigate = useNavigate();
  const [remoteUrl, setRemoteUrl] = useState('');

  const handleBrowseRemoteSite = (e: React.FormEvent) => {
    e.preventDefault();
    if (remoteUrl.trim()) {
      try {
        const url = new URL(remoteUrl.trim());
        // The URL is already a client-side route, so we don't need to encode it further for the hash.
        // We just navigate to the hash route directly.
        // Example: input 'http://localhost:8080' becomes route '#/remote@http://localhost:8080'
        navigate(`/remote@${url.origin}`);
        setRemoteUrl(''); // Clear input after navigation
      } catch (error) {
        // Use toast for better user feedback instead of alert()
        toast.error("Invalid URL entered. Please include http:// or https://");
        console.error("Invalid URL:", error);
      }
    }
  };

  return (
    <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container flex h-16 items-center justify-between gap-4">
        {/* The main logo links to the marketing page or dashboard root */}
        <Link to="/" className="flex items-center space-x-2">
          <Leaf className="h-7 w-7 text-primary" />
          <span className="text-2xl font-bold text-foreground hidden sm:inline">Sparktype</span>
        </Link>
        
        <form onSubmit={handleBrowseRemoteSite} className="flex-grow max-w-xl flex items-center gap-2">
          <div className="relative w-full">
            <Globe className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
            <Input
              type="url"
              value={remoteUrl}
              onChange={(e) => setRemoteUrl(e.target.value)}
              placeholder="Enter remote Sparktype site URL..."
              className="pl-9"
            />
          </div>
          <Button type="submit">Browse</Button>
        </form>
        
        <nav className="hidden md:flex items-center space-x-1">
          {/* Note: The main dashboard link is now `/sites` */}
          <NavLink to="/sites" label="Dashboard" icon={<Home className="h-4 w-4" />} />
        </nav>

        {/* This mobile menu button is currently a placeholder and would need state management to function */}
        <div className="md:hidden">
          <Button variant="ghost" size="icon">
            <Settings className="h-5 w-5" />
            <span className="sr-only">Toggle menu</span>
          </Button>
        </div>
      </div>
    </header>
  );
}

================================================================================

File: core/components/HashLink.tsx
// src/core/components/ui/HashLink.tsx
'use client';

import { type AnchorHTMLAttributes, type FC, forwardRef } from 'react';
import { cn } from '@/core/libraries/utils';

interface HashLinkProps extends AnchorHTMLAttributes<HTMLAnchorElement> {
  // 'to' will be the path without the hash, e.g., "/sites/123"
  to: string;
}

export const HashLink: FC<HashLinkProps> = forwardRef<HTMLAnchorElement, HashLinkProps>(
  ({ to, children, className, ...props }, ref) => {
    // The href is constructed with the required # prefix.
    // We remove a leading slash from 'to' if it exists, as the # acts as the root.
    const href = `#${to.startsWith('/') ? to : `/${to}`}`;
    return (
      <a href={href} className={cn(className)} ref={ref} {...props}>
        {children}
      </a>
    );
  }
);
HashLink.displayName = 'HashLink';

================================================================================

File: core/components/Footer.tsx
// src/components/core/Footer.tsx
import {Link} from '@/core/components/ui/link'
import { ExternalLink } from 'lucide-react';

export default function Footer() {
  const currentYear = new Date().getFullYear();

  return (
    <footer className="border-t bg-muted/50">
      <div className="container mx-auto py-8 text-center text-sm text-muted-foreground">
        <p>Â© {currentYear} Sparktype Project. All Rights Reserved (Placeholder).</p>
        <p className="mt-1">
          <Link 
            href="https://github.com/your-repo/signum-client" // Replace with your actual repo URL
            target="_blank" 
            rel="noopener noreferrer" 
            className="hover:text-primary transition-colors font-medium"
          >
            View on GitHub <ExternalLink className="inline-block ml-1 h-3 w-3" />
          </Link>
        </p>
        {/* You can add more links here, like Privacy Policy, Terms of Service, etc. */}
      </div>
    </footer>
  );
}

================================================================================

File: core/components/ThemeProvider.tsx
// src/components/core/ThemeProvider.tsx
"use client"

import { ThemeProvider as NextThemesProvider } from "next-themes"
// Corrected import for ThemeProviderProps:
import { type ThemeProviderProps } from "next-themes"; // Import directly from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

================================================================================

File: core/components/SchemaDrivenForm.tsx
'use client';

import Form from '@rjsf/shadcn';
import validator from '@rjsf/validator-ajv8';
import type { 
  RJSFSchema, 
  UiSchema, 
  FieldTemplateProps, 
  ObjectFieldTemplateProps, 
  RegistryWidgetsType,
  FormContextType
 } from '@rjsf/utils';
import { Label } from '@/core/components/ui/label';


// --- Props Definition ---
interface SchemaDrivenFormProps<T = unknown> {
  schema: RJSFSchema;
  uiSchema?: UiSchema;
  formData: object;
  onFormChange: (data: object) => void;
  liveValidate?: boolean;
  widgets?: RegistryWidgetsType<T>;
  formContext?: FormContextType & T; // <-- Use the official type and our generic
}



// --- Custom Field Template (for better layout and labels) ---
function CustomFieldTemplate(props: FieldTemplateProps) {
  const { id, classNames, label, help, required, errors, children, schema } = props;

  if (props.hidden) {
    return <div className="hidden">{children}</div>;
  }
  
  const isCheckbox = schema.type === 'boolean' && (props.uiSchema?.['ui:widget'] === 'checkbox' || props.uiSchema?.['ui:widget'] === undefined);

  if (isCheckbox) {
      return <div className={classNames}>{children}</div>
  }

  return (
    <div className={classNames}>
      {label && (
        <Label htmlFor={id} className="block text-sm font-medium mb-1">
          {label}
          {required && <span className="text-destructive ml-1">*</span>}
        </Label>
      )}
      
      
      
      {children}
      
      {errors}
      
      {help}
    </div>
  );
}

// --- Custom Object Field Template (for overall form layout) ---
function CustomObjectFieldTemplate(props: ObjectFieldTemplateProps) {
  return (
    <div>
        {props.description && <p className="text-sm text-muted-foreground">{props.description}</p>}
        <div className="mt-4">
            {props.properties.map(element => (
                <div key={element.name} className="mb-4">
                    {element.content}
                </div>
            ))}
        </div>
    </div>
  );
}

// --- Custom Submit Button Template (to hide it) ---
function HideSubmitButton() {
    return null;
}

/**
 * A reusable component that dynamically generates a form from a given JSON Schema.
 * It uses react-jsonschema-form with a shadcn/ui theme for a consistent look and feel.
 */
export default function SchemaDrivenForm<T>({ 
  schema, 
  uiSchema, 
  formData, 
  onFormChange, 
  liveValidate = false,
  widgets,
  formContext 
}: SchemaDrivenFormProps<T>) {

  const safeFormData = formData || {};

  return (
    <Form
      schema={schema}
      uiSchema={uiSchema}
      formData={safeFormData}
      validator={validator}
      onChange={(e) => onFormChange(e.formData)}
      liveValidate={liveValidate}
      showErrorList={false}
      widgets={widgets}
      formContext={formContext}
      
      templates={{
        FieldTemplate: CustomFieldTemplate,
        ObjectFieldTemplate: CustomObjectFieldTemplate,
        ButtonTemplates: {
            SubmitButton: HideSubmitButton,
        }
      }}
    />
  );
}

================================================================================

File: core/components/ErrorBoundary.tsx
// src/components/core/ErrorBoundary.tsx
'use client';

import React, { Component, type ErrorInfo, type ReactNode } from 'react';
import { AlertTriangle } from 'lucide-react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // You can also log the error to an error reporting service
    console.error("Uncaught error:", error, errorInfo);
  }

  
  public render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return (
        <div className="flex flex-col items-center justify-center h-full p-8 text-center bg-destructive/10 border border-destructive rounded-lg">
          <AlertTriangle className="h-12 w-12 text-destructive mb-4" />
          <h1 className="text-2xl font-bold text-destructive-foreground">Something went wrong.</h1>
          <p className="text-muted-foreground mt-2 mb-4">
            An unexpected error occurred. Please try refreshing the page.
          </p>
          {this.state.error && (
            <details className="w-full max-w-lg text-left bg-background p-2 rounded border mb-4">
                <summary className="cursor-pointer text-sm font-medium">Error Details</summary>
                <pre className="mt-2 text-xs text-muted-foreground whitespace-pre-wrap break-all">
                    {this.state.error.message}
                </pre>
            </details>
          )}

        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;

================================================================================

File: core/components/ui/alert-dialog.tsx
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/core/libraries/utils"
import { buttonVariants } from "@/core/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


================================================================================

File: core/components/ui/link.tsx
/**
 * TODO: Update this component to use your client-side framework's link
 * component. We've provided examples of how to do this for Next.js, Remix, and
 * Inertia.js in the Catalyst documentation:
 *
 * https://catalyst.tailwindui.com/docs#client-side-router-integration
 */

import * as Headless from '@headlessui/react'
import React, { forwardRef } from 'react'

export const Link = forwardRef(function Link(
  props: { href: string } & React.ComponentPropsWithoutRef<'a'>,
  ref: React.ForwardedRef<HTMLAnchorElement>
) {
  return (
    <Headless.DataInteractive>
      <a {...props} ref={ref} />
    </Headless.DataInteractive>
  )
})


================================================================================

File: core/components/ui/label.tsx
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/core/libraries/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }


================================================================================

File: core/components/ui/sonner.tsx
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, type ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }


================================================================================

File: core/components/ui/accordion.tsx
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/core/libraries/utils"

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0 data-[state=closed]:border-b-0", className)}
      {...props}
    />
  )
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex border-b">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 text-xs font-semibold uppercase tracking-wider text-muted-foreground transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180 py-2 px-2",
          className
        )}
        {...props}
      >
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0 transition-transform duration-200 mr-1" />
        {children}
        
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm py-4 px-3"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }


================================================================================

File: core/components/ui/switch.tsx
"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/core/libraries/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }


================================================================================

File: core/components/ui/dialog.tsx
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/core/libraries/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}


================================================================================

File: core/components/ui/button.tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/core/libraries/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }


================================================================================

File: core/components/ui/dropdown-menu.tsx
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/core/libraries/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}


================================================================================

File: core/components/ui/select.tsx
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/core/libraries/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}


================================================================================

File: core/components/ui/textarea.tsx
import * as React from "react"

import { cn } from "@/core/libraries/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }


================================================================================

File: core/components/ui/input.tsx
import * as React from "react"

import { cn } from "@/core/libraries/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }


================================================================================

File: core/components/layout/ThreeColumnLayout.tsx
'use client';

import type { ReactNode } from 'react';
import { useUIStore } from '@/core/state/uiStore';
import { cn } from '@/core/libraries/utils';
import EditorHeader from '@/features/editor/components/EditorHeader';

interface ThreeColumnLayoutProps {
  leftSidebar: ReactNode;
  rightSidebar: ReactNode;
  children: ReactNode;
  headerActions?: ReactNode;
}

export default function ThreeColumnLayout({ leftSidebar, rightSidebar, children, headerActions }: ThreeColumnLayoutProps) {
  const isLeftOpen = useUIStore((state) => state.sidebar.isLeftOpen);
  const isRightOpen = useUIStore((state) => state.sidebar.isRightOpen);

  return (
    <div className="flex h-screen w-full flex-col bg-muted/20">
      <EditorHeader actions={headerActions} />
      
      {/* This is now the positioning context for all three columns */}
      <div className="relative flex-1 overflow-hidden">
        
        
        {/* Left Sidebar: Absolutely positioned within the parent div */}
        <aside
          className={cn(
            'absolute inset-y-0 left-0 z-20 h-full w-72 border-r bg-background transition-transform duration-300 ease-in-out',
            isLeftOpen ? 'translate-x-0' : '-translate-x-full'
          )}
        >
          {/* This container ensures its direct child can scroll */}
          <div className="h-full w-full overflow-y-auto">
            {leftSidebar}
          </div>
        </aside>

        {/* Main Content: The layout is now controlled by padding */}
        <main
          className={cn(
            'h-full overflow-y-auto transition-all duration-300 ease-in-out',
            // When left sidebar is open, add left padding
            isLeftOpen ? 'lg:pl-72' : 'lg:pl-0',
            // When right sidebar is open, add right padding
            isRightOpen ? 'lg:pr-80' : 'lg:pr-0'
          )}
        >
          {children}
        </main>

        {/* Right Sidebar: Absolutely positioned within the parent div */}
        <aside
          className={cn(
            'absolute inset-y-0 right-0 z-10 h-full w-80 border-l bg-background transition-transform duration-300 ease-in-out',
            isRightOpen ? 'translate-x-0' : 'translate-x-full'
          )}
        >
          {/* This container ensures its direct child can scroll */}
          <div className="h-full w-full overflow-y-auto">
            {rightSidebar}
          </div>
        </aside>
      </div>
    </div>
  );
}

================================================================================

File: core/hooks/useAutosave.ts
// src/hooks/useAutosave.ts
'use client';

import { useEffect, useRef } from 'react';
import { AUTOSAVE_DELAY } from '@/config/editorConfig';

interface AutosaveParams<TData> {
  /** The generic data to be saved. */
  dataToSave: TData;
  /** A flag indicating if there are pending changes. */
  hasUnsavedChanges: boolean;
  /** A flag to prevent saving if the content isn't in a saveable state. */
  isSaveable: boolean;
  /** The function that performs the save operation with the generic data. */
  onSave: (data: TData) => Promise<void>;
}

/**
 * A generic custom hook to handle autosaving content after a specified delay.
 * It encapsulates the timer logic and effect management for saving drafts.
 */
export function useAutosave<TData>({ dataToSave, hasUnsavedChanges, isSaveable, onSave }: AutosaveParams<TData>) {
  const autosaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    if (autosaveTimeoutRef.current) {
      clearTimeout(autosaveTimeoutRef.current);
    }

    if (hasUnsavedChanges && isSaveable) {
      autosaveTimeoutRef.current = setTimeout(() => {
        onSave(dataToSave);
      }, AUTOSAVE_DELAY);
    }

    return () => {
      if (autosaveTimeoutRef.current) {
        clearTimeout(autosaveTimeoutRef.current);
      }
    };
  }, [dataToSave, hasUnsavedChanges, isSaveable, onSave]);
}

================================================================================

File: core/hooks/useInitialiseUIStore.ts
'use client';

import { useUIStore } from '@/core/state/uiStore';
import { useEffect } from 'react';

export function useInitialiseUIStore() {
  const initialize = useUIStore((state) => state.screen.initializeScreenSize);
  const isInitialized = useUIStore((state) => state.screen.isInitialized);

  useEffect(() => {
    if (!isInitialized) {
      initialize();
    }
  }, [initialize, isInitialized]);
}   

================================================================================

File: core/hooks/useHashNavigation.ts
// src/core/hooks/useHashNavigation.ts
'use client';

import { useState, useEffect } from 'react';

// A helper to safely get the hash and clean it up.
function getCleanHash() {
  if (typeof window === 'undefined') return '/';
  // Get the hash, remove the leading #, and ensure it starts with a /
  const hash = window.location.hash.substring(1);
  return hash.startsWith('/') ? hash : `/${hash}`;
}

export function useHashNavigation() {
  const [currentPath, setCurrentPath] = useState(getCleanHash());

  useEffect(() => {
    const handleHashChange = () => {
      setCurrentPath(getCleanHash());
    };

    // Listen for changes to the hash
    window.addEventListener('hashchange', handleHashChange);
    // Set the initial path when the component mounts
    handleHashChange();

    return () => {
      window.removeEventListener('hashchange', handleHashChange);
    };
  }, []);

  return currentPath;
}

================================================================================

File: core/services/blocknote.service.ts
// src/core/services/blocknote.service.ts
import { type Block, BlockNoteEditor } from '@blocknote/core';

/**
 * Converts a Markdown string into an array of Blocknote `Block` objects.
 * This works by creating a headless editor and using the `tryParseMarkdownToBlocks`
 * instance method.
 *
 * @param markdown The Markdown string to convert.
 * @returns A promise that resolves to an array of Blocks.
 */
export async function markdownToBlocks(markdown: string): Promise<Block[]> {
  // If the incoming markdown is empty, return an empty array to avoid
  // creating an unnecessary editor instance.
  if (!markdown || markdown.trim() === '') {
    return [];
  }
  
  const editor = await BlockNoteEditor.create();
  const blocks = await editor.tryParseMarkdownToBlocks(markdown);
  
  return blocks;
}

/**
 * Converts an array of Blocknote `Block` objects into a Markdown string.
 * This works by creating a headless editor pre-populated with the blocks
 * and then using its instance method to serialize them to Markdown.
 *
 * @param blocks The array of Blocks to convert.
 * @returns A promise that resolves to a Markdown string.
 */
export async function blocksToMarkdown(blocks: Block[]): Promise<string> {
  // If the blocks array is empty or undefined, return an empty string immediately.
  if (!blocks || blocks.length === 0) {
    return "";
  }
  
  // Only create an editor instance if there are blocks to process.
  const editor = await BlockNoteEditor.create({
    initialContent: blocks,
  });
  
  const markdown = await editor.blocksToMarkdownLossy();

  return markdown;
}

================================================================================

File: core/services/siteExporter.service.ts
// src/core/services/siteExporter.service.ts (REFACTORED)

import JSZip from 'jszip';
import type { LocalSiteData } from '@/core/types';
import { buildSiteBundle } from './siteBuilder.service';

/**
 * Takes a complete site data object, uses the siteBuilder service to generate
 * all static assets, and then packages them into a ZIP archive for download.
 *
 * This service is a "deployment target". Other targets could be created
 * for different platforms (e.g., Netlify, Vercel).
 *
 * @param siteData The fully loaded local site data.
 * @returns A promise that resolves to a Blob containing the ZIP file.
 */
export async function exportSiteToZip(siteData: LocalSiteData): Promise<Blob> {
    // 1. Call the builder service to generate the complete site bundle in memory.
    const bundle = await buildSiteBundle(siteData);

    // 2. Create a new ZIP instance.
    const zip = new JSZip();

    // 3. Iterate through the in-memory bundle and add each file to the zip.
    for (const [filePath, content] of Object.entries(bundle)) {
        zip.file(filePath, content);
    }

    // 4. Generate the final ZIP blob and return it.
    return zip.generateAsync({
        type: 'blob',
        compression: 'DEFLATE',
        compressionOptions: {
            level: 9,
        },
    });
}

================================================================================

File: core/services/urlUtils.service.ts
// src/core/services/urlUtils.service.ts
import type { Manifest } from '@/core/types';

/**
 * Generates a URL for a given site node based on its position and context.
 * This is a critical utility for both the live preview and the final static site export.
 *
 * It implements the "First Page is Homepage" rule:
 * - The very first page in the site's root structure (`manifest.structure[0]`) is
 *   always treated as the homepage and mapped to the root URL (`/` or `index.html`).
 * - All other pages are mapped to subdirectories based on their slug for clean URLs
 *   (e.g., a page with slug 'about' becomes '/about/').
 *
 * @param node - The `StructureNode` object for which to generate a URL. It must have `path` and `slug`.
 * @param manifest - The complete site manifest. This is required to identify the homepage by its position.
 * @param isExport - A boolean indicating if the URL is for a static export (e.g., `about/index.html`) or a live preview (e.g., `/about`).
 * @param pageNumber - An optional page number for generating paginated links (e.g., `/blog/page/2`).
 * @returns A string representing the final URL segment or filename.
 */
export function getUrlForNode(
  node: { path: string; slug: string },
  manifest: Manifest,
  isExport: boolean,
  pageNumber?: number,
): string {
  // --- Homepage Check ---
  // The homepage is defined as the first node in the root of the manifest's structure array.
  // The optional chaining `?.` safely handles an empty structure for a brand new site.
  const isDesignatedHomepage = manifest.structure[0]?.path === node.path;

  if (isDesignatedHomepage) {
    // --- Homepage URL Logic ---
    if (isExport) {
      // For a paginated homepage, page 2 and beyond go into a subdirectory.
      // e.g., /page/2/index.html
      if (pageNumber && pageNumber > 1) {
        return `page/${pageNumber}/index.html`;
      }
      // The homepage itself is always the root index.html file.
      return 'index.html';
    } else {
      // Live Preview URL
      if (pageNumber && pageNumber > 1) {
        return `page/${pageNumber}`;
      }
      // For the live preview, the root URL is represented by an empty string,
      // which the browser/router interprets as '/'.
      return '';
    }
  }

  // --- Logic for All Other Pages ---
  const baseSlug = node.slug;

  if (isExport) {
    // Paginated collection pages, e.g., blog/page/2/index.html
    if (pageNumber && pageNumber > 1) {
      return `${baseSlug}/page/${pageNumber}/index.html`;
    }
    // All other pages are placed in their own directory with an index.html
    // to create clean URLs, e.g., /about-us/
    return `${baseSlug}/index.html`;
  } else {
    // Live Preview URLs for other pages
    if (pageNumber && pageNumber > 1) {
      return `${baseSlug}/page/${pageNumber}`;
    }
    // A standard page preview URL is just its slug, e.g., /about-us
    return baseSlug;
  }
}

================================================================================

File: core/services/siteBackup.service.ts
// src/core/services/siteBackup.service.ts
import JSZip from 'jszip';
import type  {
  LocalSiteData,
  SiteSecrets,
  Manifest,
  ParsedMarkdownFile,
  RawFile,
} from '@/core/types';
import { stringifyToMarkdown, parseMarkdownString } from '@/core/libraries/markdownParser';
import { isCoreTheme, isCoreLayout } from './config/configHelpers.service';
import * as localSiteFs from './localFileSystem.service';

const SIGNUM_FOLDER = '_site';

/**
 * Exports a complete backup of a Sparktype site's source data into a ZIP archive.
 * This function's logic is sound and does not require changes.
 */
export async function exportSiteBackup(siteData: LocalSiteData): Promise<Blob> {
  const zip = new JSZip();
  const signumFolder = zip.folder(SIGNUM_FOLDER);

  if (!signumFolder) {
    throw new Error("Failed to create root backup folder in ZIP archive.");
  }

  signumFolder.file('manifest.json', JSON.stringify(siteData.manifest, null, 2));
  signumFolder.file('secrets.json', JSON.stringify(siteData.secrets || {}, null, 2));

  const contentFolder = signumFolder.folder('content');
  siteData.contentFiles?.forEach(file => {
    contentFolder?.file(
      file.path.replace('content/', ''),
      stringifyToMarkdown(file.frontmatter, file.content)
    );
  });
  
  const imagesFolder = signumFolder.folder('assets/images');
  const imageAssets = await localSiteFs.getAllImageAssetsForSite(siteData.siteId);
  for (const [path, blob] of Object.entries(imageAssets)) {
      const filename = path.split('/').pop();
      if (filename) imagesFolder?.file(filename, blob);
  }

  if (siteData.themeFiles?.length) {
    const themeName = siteData.manifest.theme.name;
    if (!isCoreTheme(themeName)) {
      const themeFolder = signumFolder.folder(`themes/${themeName}`);
      siteData.themeFiles.forEach(file => {
        const relativePath = file.path.substring(`themes/${themeName}/`.length);
        themeFolder?.file(relativePath, file.content);
      });
    }
  }
  
  if (siteData.layoutFiles?.length) {
    const layoutsFolder = signumFolder.folder('layouts');
    const seenLayouts = new Set<string>();
    siteData.contentFiles?.forEach(cf => {
      const layoutId = cf.frontmatter.layout;
      if (layoutId && !isCoreLayout(layoutId) && !seenLayouts.has(layoutId)) {
        const layoutFolder = layoutsFolder?.folder(layoutId);
        const layoutFiles = siteData.layoutFiles?.filter(lf => lf.path.startsWith(`layouts/${layoutId}/`));
        layoutFiles?.forEach(file => {
          const relativePath = file.path.substring(`layouts/${layoutId}/`.length);
          layoutFolder?.file(relativePath, file.content);
        });
        seenLayouts.add(layoutId);
      }
    });
  }

  return zip.generateAsync({ type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 9 } });
}

/**
 * Parses a ZIP backup file and reconstructs the site data in memory.
 * This function now uses the correct asynchronous pattern for reading files from the archive.
 */
export async function importSiteFromZip(zipFile: File): Promise<LocalSiteData & { imageAssetsToSave?: { [path: string]: Blob } }> {
    const zip = await JSZip.loadAsync(zipFile);
    const signumFolder = zip.folder(SIGNUM_FOLDER);

    if (!signumFolder) throw new Error("Invalid backup file: _site folder not found.");
    
    const manifestFile = signumFolder.file('manifest.json');
    if (!manifestFile) throw new Error("Invalid backup file: manifest.json is missing.");
    const manifest: Manifest = JSON.parse(await manifestFile.async('string'));

    const secretsFile = signumFolder.file('secrets.json');
    const secrets: SiteSecrets = secretsFile ? JSON.parse(await secretsFile.async('string')) : {};

    const contentFiles: ParsedMarkdownFile[] = [];
    const contentFolder = signumFolder.folder('content');
    if (contentFolder) {
        for (const relativePath in contentFolder.files) {
            const file = contentFolder.files[relativePath];
            if (!file.dir && typeof file.name === 'string') {
                const fullPath = file.name.replace(`${SIGNUM_FOLDER}/`, '');
                const rawContent = await file.async('string');
                const { frontmatter, content } = parseMarkdownString(rawContent);
                const slug = fullPath.substring(fullPath.lastIndexOf('/') + 1).replace('.md', '');
                contentFiles.push({ path: fullPath, slug, frontmatter, content });
            }
        }
    }


    const themePromises: Promise<RawFile>[] = [];
    signumFolder.folder('themes')?.forEach((relativePath, fileObject) => {
        if (!fileObject.dir) {
            const promise = fileObject.async('string').then(content => ({
                path: fileObject.name.replace(`${SIGNUM_FOLDER}/`, ''),
                content: content,
            }));
            themePromises.push(promise);
        }
    });
    const themeFiles = await Promise.all(themePromises);

    const layoutPromises: Promise<RawFile>[] = [];
    signumFolder.folder('layouts')?.forEach((relativePath, fileObject) => {
        if (!fileObject.dir) {
            const promise = fileObject.async('string').then(content => ({
                path: fileObject.name.replace(`${SIGNUM_FOLDER}/`, ''),
                content: content,
            }));
            layoutPromises.push(promise);
        }
    });
    const layoutFiles = await Promise.all(layoutPromises);

    const imageAssets: { [path: string]: Blob } = {};
    const imagesFolder = signumFolder.folder('assets/images');
    if (imagesFolder) {
        for (const filename in imagesFolder.files) {
            const file = imagesFolder.files[filename];
            if (!file.dir) {
                const path = `assets/images/${file.name.split('/').pop()}`;
                imageAssets[path] = await file.async('blob');
            }
        }
    }

    return {
        siteId: manifest.siteId,
        manifest,
        secrets,
        contentFiles,
        themeFiles,
        layoutFiles,
        imageAssetsToSave: imageAssets,
    };
}

================================================================================

File: core/services/relativePaths.service.ts
// src/lib/pathUtils.ts

/**
 * Calculates the relative path from one file to another.
 * This is essential for creating portable HTML that works on any server
 * or directly from the local file system.
 *
 * @example
 * // from 'index.html' to 'about.html' -> './about.html'
 * getRelativePath('index.html', 'about.html');
 *
 * @example
 * // from 'posts/post1.html' to 'index.html' -> '../index.html'
 * getRelativePath('posts/post1.html', 'index.html');
 *
 * @example
 * // from 'posts/post1.html' to 'tags/tech.html' -> '../tags/tech.html'
 * getRelativePath('posts/post1.html', 'tags/tech.html');
 *
 * @param {string} fromPath - The path of the file containing the link.
 * @param {string} toPath - The path of the file being linked to.
 * @returns {string} The calculated relative path.
 */
export function getRelativePath(fromPath: string, toPath: string): string {
  if (fromPath === toPath) {
    return toPath.split('/').pop() || '';
  }

  const fromParts = fromPath.split('/').slice(0, -1); // Path without filename
  const toParts = toPath.split('/');

  // Find the common path segment
  let commonLength = 0;
  while (
    commonLength < fromParts.length &&
    commonLength < toParts.length &&
    fromParts[commonLength] === toParts[commonLength]
  ) {
    commonLength++;
  }

  const upLevels = fromParts.length - commonLength;
  const upPath = '../'.repeat(upLevels) || './';

  const downPath = toParts.slice(commonLength).join('/');

  return upPath + downPath;
}

================================================================================

File: core/services/localFileSystem.service.ts
// src/lib/localSiteFs.ts
import { type LocalSiteData, type ParsedMarkdownFile, type Manifest, type RawFile } from '@/core/types';
import localforage from 'localforage';
import { stringifyToMarkdown, parseMarkdownString } from '@/core/libraries/markdownParser';

const DB_NAME = 'SparktypeDB';

const siteManifestsStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteManifests',
});

const siteContentFilesStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteContentFiles',
});

const siteLayoutFilesStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteLayoutFiles',
});

const siteThemeFilesStore = localforage.createInstance({
    name: DB_NAME,
    storeName: 'siteThemeFiles',
});

const siteImageAssetsStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteImageAssets',
});

const siteDataFilesStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteDataFiles',
});

// --- Function to load only manifests for a fast initial load ---
export async function loadAllSiteManifests(): Promise<Manifest[]> {
  const manifests: Manifest[] = [];
  
  try {
    // Add timeout to prevent IndexedDB from hanging indefinitely
    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => reject(new Error('IndexedDB operation timed out after 10 seconds')), 10000);
    });
    
    const iteratePromise = siteManifestsStore.iterate((value: Manifest) => {
      manifests.push(value);
    });
    
    await Promise.race([iteratePromise, timeoutPromise]);
  } catch (error) {
    console.error('Failed to load site manifests from IndexedDB:', error);
    
    // Attempt recovery by clearing potentially corrupted data
    if (error instanceof Error && error.message.includes('timed out')) {
      console.warn('IndexedDB appears to be corrupted. Attempting recovery...');
      await recoverIndexedDB();
    }
    
    // Return empty array to allow app to continue
  }
  
  return manifests;
}

/**
 * Attempts to recover from IndexedDB corruption by clearing all stores.
 * This is a last resort when the database becomes unresponsive.
 */
async function recoverIndexedDB(): Promise<void> {
  try {
    console.log('Starting IndexedDB recovery...');
    
    // Clear all stores to remove potential corruption
    await Promise.allSettled([
      siteManifestsStore.clear(),
      siteContentFilesStore.clear(), 
      siteLayoutFilesStore.clear(),
      siteThemeFilesStore.clear(),
      siteImageAssetsStore.clear(),
      siteDataFilesStore.clear(),
    ]);
    
    // Also clear derivative cache and secrets
    const { clearAllDerivativeCache } = await import('./images/derivativeCache.service');
    await clearAllDerivativeCache();
    
    console.log('IndexedDB recovery completed. All data has been cleared.');
    
    // Show user notification about recovery
    if (typeof window !== 'undefined' && 'toast' in window) {
      const windowWithToast = window as unknown as { toast?: { error?: (message: string) => void } };
      windowWithToast.toast?.error?.('Database corruption detected. All local data has been cleared. Please reimport your sites.');
    }
  } catch (recoveryError) {
    console.error('IndexedDB recovery failed:', recoveryError);
  }
}

/**
 * Fetches the manifest for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<Manifest | null>} A Promise that resolves to the Manifest object, or null if not found.
 */
export async function getManifestById(siteId: string): Promise<Manifest | null> {
  const manifest = await siteManifestsStore.getItem<Manifest>(siteId);
  return manifest ?? null;
}

/**
 * Fetches the content files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<ParsedMarkdownFile[]>} A Promise that resolves to an array of parsed markdown files.
 */
export async function getSiteContentFiles(siteId: string): Promise<ParsedMarkdownFile[]> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId);
    return contentFiles ?? [];
}

/**
 * Fetches the custom layout files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<RawFile[]>} A Promise that resolves to an array of raw layout files.
 */
export async function getSiteLayoutFiles(siteId: string): Promise<RawFile[]> {
    const layoutFiles = await siteLayoutFilesStore.getItem<RawFile[]>(siteId);
    return layoutFiles ?? [];
}

/**
 * Fetches the custom theme files for a single site by its ID.
 * @param {string} siteId The unique identifier for the site.
 * @returns {Promise<RawFile[]>} A Promise that resolves to an array of raw theme files.
 */
export async function getSiteThemeFiles(siteId: string): Promise<RawFile[]> {
    const themeFiles = await siteThemeFilesStore.getItem<RawFile[]>(siteId);
    return themeFiles ?? [];
}

export async function saveSite(siteData: LocalSiteData): Promise<void> {
  await Promise.all([
    siteManifestsStore.setItem(siteData.siteId, siteData.manifest),
    siteContentFilesStore.setItem(siteData.siteId, siteData.contentFiles ?? []),
    siteLayoutFilesStore.setItem(siteData.siteId, siteData.layoutFiles ?? []),
    siteThemeFilesStore.setItem(siteData.siteId, siteData.themeFiles ?? []),
  ]);
}

export async function deleteSite(siteId: string): Promise<void> {
  // Import required cleanup functions
  const { clearSiteDerivativeCache } = await import('./images/derivativeCache.service');
  const { deleteSiteSecretsFromDb } = await import('./siteSecrets.service');
  
  await Promise.all([
    // Core site data
    siteManifestsStore.removeItem(siteId),
    siteContentFilesStore.removeItem(siteId),
    siteLayoutFilesStore.removeItem(siteId),
    siteThemeFilesStore.removeItem(siteId),
    
    // Previously missing cleanup operations
    siteImageAssetsStore.removeItem(siteId),
    siteDataFilesStore.removeItem(siteId),
    deleteSiteSecretsFromDb(siteId),
    clearSiteDerivativeCache(siteId),
  ]);
}

export async function saveManifest(siteId: string, manifest: Manifest): Promise<void> {
    await siteManifestsStore.setItem(siteId, manifest);
}

export async function saveContentFile(siteId: string, filePath: string, rawMarkdownContent: string): Promise<ParsedMarkdownFile> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];

    const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
    const fileSlug = filePath.replace(/^content\//, '').replace(/\.md$/, '');
    const savedFile: ParsedMarkdownFile = { slug: fileSlug, path: filePath, frontmatter, content };

    const fileIndex = contentFiles.findIndex(f => f.path === filePath);
    if (fileIndex > -1) {
      contentFiles[fileIndex] = savedFile;
    } else {
      contentFiles.push(savedFile);
    }

    await siteContentFilesStore.setItem(siteId, contentFiles);
    return savedFile;
}

export async function deleteContentFile(siteId: string, filePath: string): Promise<void> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    const updatedContentFiles = contentFiles.filter(f => f.path !== filePath);
    await siteContentFilesStore.setItem(siteId, updatedContentFiles);
}

export async function getContentFileRaw(siteId: string, filePath: string): Promise<string | null> {
    const allFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    const fileData = allFiles.find(f => f.path === filePath);
    if (!fileData) return null;
    
    return stringifyToMarkdown(fileData.frontmatter, fileData.content);
}

/**
 * Moves a set of content files from old paths to new paths in a single transaction.
 * @param {string} siteId - The ID of the site.
 * @param {{oldPath: string, newPath: string}[]} pathsToMove - An array of path mapping objects.
 * @returns {Promise<void>}
 */
export async function moveContentFiles(siteId: string, pathsToMove: { oldPath: string, newPath: string }[]): Promise<void> {
    const contentFiles = await siteContentFilesStore.getItem<ParsedMarkdownFile[]>(siteId) ?? [];
    
    const updatedFiles = contentFiles.map(file => {
        const moveInstruction = pathsToMove.find(p => p.oldPath === file.path);
        if (moveInstruction) {
            const newSlug = moveInstruction.newPath.split('/').pop()?.replace('.md', '') || '';
            return { ...file, path: moveInstruction.newPath, slug: newSlug };
        }
        return file;
    });
    
    await siteContentFilesStore.setItem(siteId, updatedFiles);
}

/**
 * Saves a binary image asset (as a Blob) to storage for a specific site.
 * @param siteId The ID of the site.
 * @param imagePath The relative path to the image (e.g., 'assets/images/foo.jpg').
 * @param imageData The image data as a Blob.
 */
export async function saveImageAsset(siteId: string, imagePath: string, imageData: Blob): Promise<void> {
  const imageMap = await siteImageAssetsStore.getItem<Record<string, Blob>>(siteId) || {};
  imageMap[imagePath] = imageData;
  await siteImageAssetsStore.setItem(siteId, imageMap);
}

/**
 * Retrieves a binary image asset (as a Blob) from storage for a specific site.
 * @param siteId The ID of the site to look within.
 * @param imagePath The relative path of the image to retrieve.
 * @returns A Promise that resolves to the image Blob, or null if not found.
 */
export async function getImageAsset(siteId: string, imagePath: string): Promise<Blob | null> {

  // 1. Get the image map for the specific site.
  const imageMap = await siteImageAssetsStore.getItem<Record<string, Blob>>(siteId);
  if (!imageMap) {
    return null; // The site has no images.
  }
  // 2. Return the image from the map, or null if it doesn't exist.
  return imageMap[imagePath] || null;
}

/**
 * Retrieves the entire map of image paths to image Blobs for a given site.
 * @param siteId The ID of the site.
 * @returns A promise that resolves to a record mapping image paths to their Blob data.
 */
export async function getAllImageAssetsForSite(siteId: string): Promise<Record<string, Blob>> {
    return await siteImageAssetsStore.getItem<Record<string, Blob>>(siteId) || {};
}

/**
 * Saves a complete map of image assets for a site.
 * This is used during the site import process to restore all images at once.
 * @param siteId The ID of the site to save images for.
 * @param assets A record mapping image paths to their Blob data.
 */
export async function saveAllImageAssetsForSite(siteId: string, assets: Record<string, Blob>): Promise<void> {
  await siteImageAssetsStore.setItem(siteId, assets);
}

/**
 * Saves a single data file (e.g., categories.json) for a site.
 * @param siteId The ID of the site.
 * @param dataFilePath The path to the data file (e.g., 'data/blog_categories.json').
 * @param content The JSON string content to save.
 */
export async function saveDataFile(siteId: string, dataFilePath: string, content: string): Promise<void> {
    const dataFileMap = await siteDataFilesStore.getItem<Record<string, string>>(siteId) || {};
    dataFileMap[dataFilePath] = content;
    await siteDataFilesStore.setItem(siteId, dataFileMap);
}

/**
 * Retrieves the content of a single data file for a site.
 * @param siteId The ID of the site.
 * @param dataFilePath The path to the data file.
 * @returns The file's content as a string, or null if not found.
 */
export async function getDataFileContent(siteId: string, dataFilePath: string): Promise<string | null> {
    const dataFileMap = await siteDataFilesStore.getItem<Record<string, string>>(siteId);
    return dataFileMap?.[dataFilePath] || null;
}

/**
 * Retrieves all data files for a site as a path-to-content map.
 * @param siteId The ID of the site.
 * @returns A record mapping data file paths to their string content.
 */
export async function getAllDataFiles(siteId: string): Promise<Record<string, string>> {
    return (await siteDataFilesStore.getItem<Record<string, string>>(siteId)) || {};
}

================================================================================

File: core/services/navigationStructure.service.ts
// src/core/services/navigationStructure.service.ts
import { type LocalSiteData, type NavLinkItem, type StructureNode } from '@/core/types';
import { getUrlForNode } from '@/core/services/urlUtils.service';
import { getRelativePath } from '@/core/services/relativePaths.service';
import { type RenderOptions } from '@/core/services/renderer/render.service';

/**
 * Recursively builds a navigation link structure with context-aware paths.
 * @param siteData - The full site data, needed for URL generation.
 * @param nodes - The site structure nodes to build links from.
 * @param currentPagePath - The path of the page being currently rendered.
 * @param options - The render options, containing isExport and siteRootPath.
 * @returns An array of navigation link objects.
 */
function buildNavLinks(
    siteData: LocalSiteData, 
    nodes: StructureNode[], 
    currentPagePath: string, 
    options: Pick<RenderOptions, 'isExport' | 'siteRootPath'>
): NavLinkItem[] {
  return nodes
    .filter(node => node.type === 'page' && node.navOrder !== undefined)
    .sort((a, b) => (a.navOrder || 0) - (b.navOrder || 0))
    .map(node => {
      let href: string;

      const urlSegment = getUrlForNode(node, siteData.manifest, options.isExport);

      if (options.isExport) {
        href = getRelativePath(currentPagePath, urlSegment);
      } else {
        const path = `/${urlSegment}`.replace(/\/$/, '') || '/';
        href = `${options.siteRootPath}${path === '/' ? '' : path}`;
      }

      // Filter out collection items from navigation
      const nodeFile = siteData.contentFiles?.find(f => f.path === node.path);
      const isCollectionPage = !!nodeFile?.frontmatter.collection;
      
      const children = (node.children && node.children.length > 0 && !isCollectionPage)
        ? buildNavLinks(siteData, node.children, currentPagePath, options)
        : [];

      return {
        href: href,
        label: node.menuTitle || node.title,
        children: children,
      };
    });
}

/**
 * Generates the complete navigation structure for a given page.
 */
export function generateNavLinks(
  siteData: LocalSiteData,
  currentPagePath: string,
  options: Pick<RenderOptions, 'isExport' | 'siteRootPath'>
): NavLinkItem[] {
  const { structure } = siteData.manifest;
  return buildNavLinks(siteData, structure, currentPagePath, options);
}

================================================================================

File: core/services/htmlSanitizer.service.ts
// src/core/services/htmlSanitizer.service.ts

import DOMPurify from 'dompurify';

/**
 * HTML sanitization service for theme data fields.
 * Removes malicious scripts while preserving safe HTML formatting.
 */
export class HtmlSanitizerService {
  private static readonly ALLOWED_TAGS = [
    'p', 'br', 'strong', 'b', 'em', 'i', 'u', 'a', 'ul', 'ol', 'li',
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'span', 'div'
  ];

  private static readonly ALLOWED_ATTRIBUTES = {
    'a': ['href', 'title', 'target'],
    '*': ['class', 'id']
  };

  /**
   * Sanitizes HTML content by removing potentially malicious elements
   * while preserving safe formatting tags.
   */
  static sanitize(html: string): string {
    if (!html || typeof html !== 'string') {
      return '';
    }

    return DOMPurify.sanitize(html, {
      ALLOWED_TAGS: this.ALLOWED_TAGS,
      ALLOWED_ATTR: Object.values(this.ALLOWED_ATTRIBUTES).flat(),
      ALLOW_DATA_ATTR: false,
      ALLOW_UNKNOWN_PROTOCOLS: false,
      SANITIZE_DOM: true,
      KEEP_CONTENT: true
    });
  }

  /**
   * Sanitizes theme data object recursively, targeting string fields that may contain HTML.
   */
  static sanitizeThemeData(themeData: Record<string, unknown>): Record<string, unknown> {
    if (!themeData || typeof themeData !== 'object') {
      return {};
    }

    const sanitized: Record<string, unknown> = {};

    for (const [key, value] of Object.entries(themeData)) {
      if (typeof value === 'string') {
        sanitized[key] = this.sanitize(value);
      } else if (value && typeof value === 'object') {
        sanitized[key] = this.sanitizeThemeData(value as Record<string, unknown>);
      } else {
        sanitized[key] = value;
      }
    }

    return sanitized;
  }
}

================================================================================

File: core/services/siteBuilder.service.ts
// src/core/services/siteBuilder.service.ts (REFACTORED)

import type { LocalSiteData, SiteBundle } from '@/core/types';
import { flattenTree } from '@/core/services/fileTree.service';
import { getMergedThemeDataForForm } from '@/core/services/config/theme.service';
import { bundleAllAssets } from './builder/asset.builder';
import { bundleSourceFiles } from './builder/source.builder';
import { generateMetadataFiles } from './builder/metadata.builder';
import { generateHtmlPages } from './builder/page.builder';

/**
 * Orchestrates the entire site build process by calling specialized builder modules.
 * This service generates a complete, in-memory representation of a static site bundle.
 */
export async function buildSiteBundle(siteData: LocalSiteData): Promise<SiteBundle> {
    const bundle: SiteBundle = {};
    if (!siteData.contentFiles) {
        throw new Error("Cannot build site: content files are not loaded.");
    }

    // 1. Prepare a synchronized version of the site data for a consistent build
    const { initialConfig: finalMergedConfig } = await getMergedThemeDataForForm(
        siteData.manifest.theme.name,
        siteData.manifest.theme.config
    );
    const synchronizedSiteData = {
        ...siteData,
        manifest: { ...siteData.manifest, theme: { ...siteData.manifest.theme, config: finalMergedConfig } },
    };
    
    // This is needed by multiple builders, so we compute it once.
    const contentFiles = synchronizedSiteData.contentFiles || [];
    const allStaticNodes = flattenTree(synchronizedSiteData.manifest.structure, contentFiles);

    // 2. Generate all HTML pages
    const htmlPages = await generateHtmlPages(synchronizedSiteData, allStaticNodes);
    Object.assign(bundle, htmlPages);

    // 3. Bundle source files (_site directory)
    await bundleSourceFiles(bundle, synchronizedSiteData);

    // 4. Bundle all assets (images, themes, layouts)
    await bundleAllAssets(bundle, synchronizedSiteData);

    // 5. Generate metadata files (RSS, sitemap)
    generateMetadataFiles(bundle, synchronizedSiteData, allStaticNodes);

    return bundle;
}

================================================================================

File: core/services/pageResolver.service.ts
// src/core/services/pageResolver.service.ts

import type {
    LocalSiteData,
    ParsedMarkdownFile,
    CollectionConfig,
    PaginationData,
    PageResolutionResult,
    PageType,
    StructureNode,
} from '@/core/types';

import { findNodeByPath, findChildNodes } from './fileTree.service';
import { getUrlForNode } from './urlUtils.service';
import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';

/**
 * Executes a declarative query for a Collection Page.
 * This pure function takes the config and site data, finds all child pages
 * in the structure, fetches their content, and returns a fully sorted array.
 *
 * @param {CollectionConfig} collectionConfig - The configuration object from the page's frontmatter.
 * @param {StructureNode} collectionNode - The structure node for the Collection Page itself.
 * @param {LocalSiteData} siteData - The complete data for the site.
 * @returns {ParsedMarkdownFile[]} A sorted array of all content files that are children of the collection page.
 */
function executeCollectionQuery(
    collectionConfig: CollectionConfig,
    collectionNode: StructureNode,
    siteData: LocalSiteData,
): ParsedMarkdownFile[] {
    if (!siteData.contentFiles) {
        return [];
    }

    // Find all direct child nodes of the collection page in the site's structure.
    const childNodes = findChildNodes(siteData.manifest.structure, collectionNode.path);
    const childPaths = new Set(childNodes.map(child => child.path));

    // Filter the site's content files to get only the ones that are children.
    const items = siteData.contentFiles.filter(file => childPaths.has(file.path));

    const sortBy = collectionConfig.sort_by || 'date';
    const sortOrder = collectionConfig.sort_order || 'desc';
    const orderModifier = sortOrder === 'desc' ? -1 : 1;

    return [...items].sort((a, b) => {
        const valA = a.frontmatter[sortBy];
        const valB = b.frontmatter[sortBy];

        if (sortBy === 'date' && valA && valB) {
            const dateA = new Date(valA as string).getTime();
            const dateB = new Date(valB as string).getTime();
            if (isNaN(dateA) || isNaN(dateB)) return 0;
            return (dateA - dateB) * orderModifier;
        }

        if (typeof valA === 'string' && typeof valB === 'string') {
            return valA.localeCompare(valB) * orderModifier;
        }

        if (typeof valA === 'number' && typeof valB === 'number') {
            return (valA - valB) * orderModifier;
        }
        return 0;
    });
}

/**
 * Finds the correct page to render based on a URL slug path.
 * If the page is a Collection Page, this function executes the query, handles pagination,
 * and attaches the results to the final resolution object.
 *
 * @param {LocalSiteData} siteData - The complete data for the site.
 * @param {string[]} slugArray - The URL segments used for path matching.
 * @param {number} [pageNumber=1] - The current page number for pagination.
 * @returns {PageResolutionResult} An object containing all data needed to render the page or a not-found error.
 */
export function resolvePageContent(
    siteData: LocalSiteData,
    slugArray: string[],
    pageNumber: number = 1,
): PageResolutionResult {
    // Determine the homepage by finding the file with `homepage: true`.
    const homepageFile = siteData.contentFiles?.find(f => f.frontmatter.homepage === true);
    
    // If the slug is empty, we are trying to render the homepage.
    const isHomepageRequest = slugArray.length === 0 || (slugArray.length === 1 && slugArray[0] === '');
    const pathFromSlug = `content/${slugArray.join('/')}.md`;

    // Determine the target path. If it's a homepage request, use the homepage file's path.
    const targetNodePath = isHomepageRequest ? homepageFile?.path : pathFromSlug;
    
    if (!targetNodePath) {
        return {
            type: PageType.NotFound,
            errorMessage: "No homepage has been designated for this site.",
        };
    }

    const targetNode = findNodeByPath(siteData.manifest.structure, targetNodePath);
    if (!targetNode) {
        return {
            type: PageType.NotFound,
            errorMessage: `No page found in site structure for path: ${targetNodePath}`,
        };
    }

    const contentFile = siteData.contentFiles?.find(f => f.path === targetNode.path);
    if (!contentFile) {
        return {
            type: PageType.NotFound,
            errorMessage: `Manifest references "${targetNode.path}" but its content file is missing.`,
        };
    }

    let collectionItems: ParsedMarkdownFile[] | undefined = undefined;
    let pagination: PaginationData | undefined = undefined;

    const collectionConfig = contentFile.frontmatter.collection;
    if (collectionConfig) {
        const allItems = executeCollectionQuery(collectionConfig, targetNode, siteData);
        const itemsPerPage = collectionConfig.items_per_page;

        if (itemsPerPage && itemsPerPage > 0) {
            const totalItems = allItems.length;
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            const currentPage = Math.max(1, Math.min(pageNumber, totalPages));
            const startIndex = (currentPage - 1) * itemsPerPage;
            collectionItems = allItems.slice(startIndex, startIndex + itemsPerPage);

            const pageUrlSegment = getUrlForNode(targetNode, siteData.manifest, false);
            const baseUrl = pageUrlSegment ? `/${pageUrlSegment}` : '';
            
            pagination = {
                currentPage,
                totalPages,
                totalItems,
                hasPrevPage: currentPage > 1,
                hasNextPage: currentPage < totalPages,
                prevPageUrl: currentPage > 1 ? (currentPage === 2 ? baseUrl || '/' : `${baseUrl}/page/${currentPage - 1}`) : undefined,
                nextPageUrl: currentPage < totalPages ? `${baseUrl}/page/${currentPage + 1}` : undefined,
            };

        } else {
            collectionItems = allItems;
        }
    }

    return {
        type: PageType.SinglePage,
        pageTitle: contentFile.frontmatter.title,
        contentFile: contentFile,
        layoutPath: contentFile.frontmatter.layout || DEFAULT_PAGE_LAYOUT_PATH,
        collectionItems: collectionItems,
        pagination: pagination,
    };
}

================================================================================

File: core/services/siteSecrets.service.ts
// src/core/services/siteSecrets.service.ts
import localforage from 'localforage';

const DB_NAME = 'SparktypeDB';

// This store is NEVER included in the site export.
const siteSecretsStore = localforage.createInstance({
  name: DB_NAME,
  storeName: 'siteSecrets',
});


/**
 * Defines the shape of the sensitive, non-public data for a site.
 * This data is stored separately and is not included in public site exports.
 */
export interface SiteSecrets {
  cloudinary?: {
    uploadPreset?: string;
  };
}

/**
 * Loads the secrets object for a specific site from the database.
 * @param siteId The ID of the site.
 * @returns A promise that resolves to the SiteSecrets object, or an empty object.
 */
export async function loadSiteSecretsFromDb(siteId: string): Promise<SiteSecrets> {
  return (await siteSecretsStore.getItem<SiteSecrets>(siteId)) || {};
}

/**
 * Saves the complete secrets object for a specific site to the database.
 * @param siteId The ID of the site.
 * @param secrets The SiteSecrets object to save.
 */
export async function saveSiteSecretsToDb(siteId: string, secrets: SiteSecrets): Promise<void> {
  await siteSecretsStore.setItem(siteId, secrets);
}

/**
 * Deletes all secrets for a specific site from the database.
 * This should be called when deleting a site to ensure sensitive data is properly purged.
 * @param siteId The ID of the site whose secrets should be deleted.
 */
export async function deleteSiteSecretsFromDb(siteId: string): Promise<void> {
  await siteSecretsStore.removeItem(siteId);
}

================================================================================

File: core/services/fileTree.service.ts
// src/core/services/fileTree.service.ts
import type { ParsedMarkdownFile, StructureNode } from '@/core/types';

/**
 * A flattened representation of a StructureNode, including its depth and parent.
 * It also includes the frontmatter for easier access in UI components.
 */
export interface FlattenedNode extends StructureNode {
  parentId: string | null;
  depth: number;
  index: number;
  collapsed?: boolean;
  frontmatter?: ParsedMarkdownFile['frontmatter'];
}

/**
 * Recursively traverses a tree of StructureNodes and flattens it into an array.
 * It now also merges frontmatter data into each node.
 */
function flatten(
  nodes: StructureNode[],
  contentFiles: ParsedMarkdownFile[],
  parentId: string | null = null,
  depth = 0
): FlattenedNode[] {
  return nodes.reduce<FlattenedNode[]>((acc, item, index) => {
    const file = contentFiles.find(f => f.path === item.path);
    return [
      ...acc,
      { ...item, parentId, depth, index, frontmatter: file?.frontmatter },
      ...(item.children ? flatten(item.children, contentFiles, item.path, depth + 1) : []),
    ];
  }, []);
}

/**
 * Public facing function to flatten the entire site structure tree.
 */
export function flattenTree(nodes: StructureNode[], contentFiles: ParsedMarkdownFile[]): FlattenedNode[] {
  return flatten(nodes, contentFiles);
}

/**
 * Reconstructs a nested tree structure from a flat array of nodes.
 */
export function buildTree(flattenedNodes: FlattenedNode[]): StructureNode[] {
  const root: StructureNode & { children: StructureNode[] } = {
    path: 'root', slug: 'root', title: 'root', type: 'page', children: []
  };
  const nodes: Record<string, StructureNode> = { [root.path]: root };

  const items = flattenedNodes.map(item => ({ ...item, children: [] as StructureNode[] }));

  for (const item of items) {
    const { path } = item;
    const parentId = item.parentId ?? root.path;
    
    nodes[path] = item;
    const parent = nodes[parentId];

    if (parent) {
      parent.children = parent.children ?? [];
      parent.children.push(item);
    }
  }
  
  return root.children ?? [];
}

// --- NEW FUNCTION: A simple utility to get a flat list of all nodes ---
/**
 * Recursively traverses a tree of StructureNodes and returns a simple flat array.
 * This is used when only the node data is needed, without depth or parent context.
 * @param {StructureNode[]} nodes - The tree of nodes to flatten.
 * @returns {StructureNode[]} A flat array of all nodes in the tree.
 */
export function flattenStructure(nodes: StructureNode[]): StructureNode[] {
  let allNodes: StructureNode[] = [];
  for (const node of nodes) {
    allNodes.push(node);
    if (node.children) {
      allNodes = allNodes.concat(flattenStructure(node.children));
    }
  }
  return allNodes;
}

/**
 * Finds a node in a structure tree by its exact `path`.
 */
export function findNodeByPath(nodes: StructureNode[], path: string): StructureNode | undefined {
  for (const node of nodes) {
    if (node.path === path) return node;
    if (node.children) {
      const found = findNodeByPath(node.children, path);
      if (found) return found;
    }
  }
  return undefined;
}

/**
 * Finds all direct child nodes of a given parent node path.
 * This is a simple utility used by the page resolver for collection pages.
 * @param {StructureNode[]} nodes - The entire site structure tree.
 * @param {string} parentPath - The path of the parent node whose children are needed.
 * @returns {StructureNode[]} An array of child nodes, or an empty array if not found.
 */
export function findChildNodes(nodes: StructureNode[], parentPath: string): StructureNode[] {
    const parentNode = findNodeByPath(nodes, parentPath);
    return parentNode?.children || [];
}

/**
 * Finds and removes a node from a tree structure immutably.
 */
export function findAndRemoveNode(nodes: StructureNode[], path: string): { found: StructureNode | null, tree: StructureNode[] } {
    let found: StructureNode | null = null;
    const filterRecursively = (currentNodes: StructureNode[]): StructureNode[] => {
      return currentNodes.reduce<StructureNode[]>((acc, node) => {
        if (node.path === path) {
          found = node;
          return acc;
        }
        const newNode = { ...node };
        if (newNode.children) {
          newNode.children = filterRecursively(newNode.children);
        }
        acc.push(newNode);
        return acc;
      }, []);
    };
    const newTree = filterRecursively(nodes);
    return { found, tree: newTree };
  }
  
/**
 * Recursively updates the path of a node and all of its descendants.
 */
export function updatePathsRecursively(node: StructureNode, newParentDir: string): StructureNode {
    const fileName = node.path.substring(node.path.lastIndexOf('/') + 1);
    const newPath = `${newParentDir}/${fileName}`.replace('//', '/');
    const newSlug = newPath.replace(/^content\//, '').replace(/\.md$/, '');
    const updatedNode: StructureNode = { ...node, path: newPath, slug: newSlug };
    if (updatedNode.children) {
      const newChildsParentPath = newPath.replace(/\.md$/, '');
      updatedNode.children = updatedNode.children.map(child =>
        updatePathsRecursively(child, newChildsParentPath)
      );
    }
    return updatedNode;
}
  
/**
 * Recursively calculates the depth of a specific node within the tree.
 */
export function getNodeDepth(nodes: StructureNode[], path: string, currentDepth = 0): number {
    for (const node of nodes) {
        if (node.path === path) {
            return currentDepth;
        }
        if (node.children) {
            const depth = getNodeDepth(node.children, path, currentDepth + 1);
            if (depth !== -1) {
                return depth;
            }
        }
    }
    return -1;
}
  
/**
 * Recursively traverses a node tree and returns a flat array of all node paths (IDs).
 */
export function getDescendantIds(nodes: StructureNode[]): string[] {
    return nodes.flatMap(node => [
      node.path,
      ...(node.children ? getDescendantIds(node.children) : []),
    ]);
}

================================================================================

File: core/services/renderer/render.service.ts
// src/core/services/renderer/render.service.ts

import Handlebars from 'handlebars';
import type { LocalSiteData, PageResolutionResult, PageType } from '@/core/types';
import { getAssetContent, getLayoutManifest, type LayoutManifest } from '@/core/services/config/configHelpers.service';
import { getActiveImageService } from '@/core/services/images/images.service';
import { getMergedThemeDataForForm } from '@/core/services/config/theme.service';
import { prepareRenderEnvironment } from './asset.service';
import { assemblePageContext, assembleBaseContext } from './context.service';

/**
 * Defines the options passed to the main render function.
 */
export interface RenderOptions {
    siteRootPath: string;
    isExport: boolean;
    relativeAssetPath?: string;
}

/**
 * Determines the correct Handlebars template path for the body content.
 */
function getBodyTemplatePath(resolution: PageResolutionResult, pageLayoutManifest: LayoutManifest | null): string {

    if (resolution.type === PageType.NotFound) return 'index.hbs'; // Fallback
    
    // --- FIX: This logic was flawed. It was trying to read collection options for a single page. ---
    // It should check if the current page is a collection page or a collection *item*.
    const isCollectionPage = !!resolution.contentFile.frontmatter.collection;

    if (isCollectionPage) {
        // This is a collection list page (e.g., /blog)
        const collectionOptions = resolution.contentFile.frontmatter.collection || {};
        const choiceKey = (collectionOptions.listingStyle as string) || pageLayoutManifest?.display_options?.listingStyle?.default;
        const template = choiceKey ? pageLayoutManifest?.display_options?.listingStyle.options[choiceKey]?.template : 'index.hbs';
        return template || 'index.hbs';
    } else {
        // This is a single page or a collection item page (e.g., /blog/my-post).
        // For collection items, the layout choice comes from the *parent* collection's config.
        // This logic is complex for the renderer; for now, we assume a single item template per layout.
        // A more robust solution might involve looking up the parent config, but this is a safe default.
        return pageLayoutManifest?.files.find(f => f.path.includes('item.hbs'))?.path || 'index.hbs';
    }
}

/**
 * Renders a resolved page into a full HTML string. This is the primary
 * orchestration function for the entire rendering pipeline.
 */
export async function render(
    siteData: LocalSiteData,
    resolution: PageResolutionResult,
    options: RenderOptions
): Promise<string> {
    if (resolution.type === PageType.NotFound) {
        return `<h1>404 - Not Found</h1><p>${resolution.errorMessage}</p>`;
    }

    // 1. Synchronize Data and Prepare Environment
    const { initialConfig: finalMergedConfig } = await getMergedThemeDataForForm(siteData.manifest.theme.name, siteData.manifest.theme.config);
    const synchronizedSiteData = { ...siteData, manifest: { ...siteData.manifest, theme: { ...siteData.manifest.theme, config: finalMergedConfig }}};
    await prepareRenderEnvironment(synchronizedSiteData);

    // 2. Get Services and Manifests
    const imageService = getActiveImageService(synchronizedSiteData.manifest);
    const pageLayoutManifest = await getLayoutManifest(synchronizedSiteData, resolution.layoutPath);

    // 3. Assemble Contexts
    const pageContext = await assemblePageContext(synchronizedSiteData, resolution, options, imageService, pageLayoutManifest);
    const baseContext = await assembleBaseContext(synchronizedSiteData, resolution, options, imageService, pageContext);

    // 4. Compile and Render Body
    const bodyTemplatePath = getBodyTemplatePath(resolution, pageLayoutManifest);
    const bodyTemplateSource = await getAssetContent(synchronizedSiteData, 'layout', resolution.layoutPath, bodyTemplatePath);
    if (!bodyTemplateSource) throw new Error(`Body template not found: layouts/${resolution.layoutPath}/${bodyTemplatePath}`);
    
    // --- FIX #1: AWAIT the template execution to resolve async helpers inside the body. ---
    const bodyHtml = await Handlebars.compile(bodyTemplateSource)(pageContext);

    // 5. Compile and Render Final Page Shell
    const baseTemplateSource = await getAssetContent(synchronizedSiteData, 'theme', synchronizedSiteData.manifest.theme.name, 'base.hbs');
    if (!baseTemplateSource) throw new Error('Base theme template (base.hbs) not found.');
    
    // Inject the rendered body HTML into the base context
    const finalContextWithBody = { ...baseContext, body: new Handlebars.SafeString(bodyHtml) };

    // --- FIX #2: AWAIT the final template execution to resolve async helpers in the shell (header, footer, etc.). ---
    return await Handlebars.compile(baseTemplateSource)(finalContextWithBody);
}

================================================================================

File: core/services/renderer/context.service.ts
// src/core/services/rendering/context.service.ts

import Handlebars from 'handlebars';
import type {
    LocalSiteData,
    PageResolutionResult,
    ImageRef,
    ParsedMarkdownFile,
    Manifest,
    ImageService,
    PageType,
} from '@/core/types';
import { type LayoutManifest } from '@/core/services/config/configHelpers.service';
import { generateNavLinks } from '@/core/services/navigationStructure.service';
import { getUrlForNode } from '@/core/services/urlUtils.service';
import { generateStyleOverrides } from './asset.service';
import { type RenderOptions } from './render.service';
import { getRelativePath } from '@/core/services/relativePaths.service';

// Define a reusable type for the resolved image presets.
type ResolvedImagePresets = Record<string, { url: string; width?: number; height?: number }>;

type EnrichedPageContext = (PageResolutionResult & {
    images?: ResolvedImagePresets;
    collectionItems?: (ParsedMarkdownFile & { images?: ResolvedImagePresets })[];
    layoutManifest?: LayoutManifest | null; // Add layoutManifest as an optional property.
});


/**
 * Asynchronously resolves all image preset URLs for a given content file.
 */
async function resolveImagePresets(context: {
    imageService: ImageService;
    layoutManifest: LayoutManifest | null;
    contentFile: ParsedMarkdownFile;
    options: Pick<RenderOptions, 'isExport'>;
    manifest: Manifest;
}): Promise<ResolvedImagePresets> {
    const { imageService, layoutManifest, contentFile, options, manifest } = context;
    const presets = layoutManifest?.image_presets || {};
    const resolved: ResolvedImagePresets = {};
    for (const [name, preset] of Object.entries(presets)) {
        const sourceRef = contentFile.frontmatter[preset.source] as ImageRef | undefined;
        if (sourceRef?.serviceId && sourceRef?.src) {
            try {
                resolved[name] = {
                    url: await imageService.getDisplayUrl(manifest, sourceRef, preset, options.isExport),
                    width: preset.width,
                    height: preset.height,
                };
            } catch (e) { console.warn(`Could not resolve image preset "${name}":`, e); }
        }
    }
    return resolved;
}

/**
 * Assembles the complete context object for the main page body template.
 * This function enriches the initial page resolution with async data like image URLs.
 */
export async function assemblePageContext(
    siteData: LocalSiteData,
    resolution: PageResolutionResult,
    options: RenderOptions,
    imageService: ImageService,
    pageLayoutManifest: LayoutManifest | null
): Promise<EnrichedPageContext> {
    if (resolution.type === PageType.NotFound) {
        return resolution;
    }

    const { manifest } = siteData;
    const imageContext = await resolveImagePresets({ imageService, layoutManifest: pageLayoutManifest, contentFile: resolution.contentFile, options, manifest });

    const processedCollectionItems = resolution.collectionItems
        ? await Promise.all(resolution.collectionItems.map(async (item: ParsedMarkdownFile) => {
            const urlSegment = getUrlForNode(item, manifest, options.isExport);
            const currentPagePath = getUrlForNode(resolution.contentFile, manifest, options.isExport);
            
            let itemUrl: string;
            if (options.isExport) {
                itemUrl = getRelativePath(currentPagePath, urlSegment);
            } else {
                const path = `/${urlSegment}`.replace(/\/$/, '') || '/';
                itemUrl = `${options.siteRootPath}${path === '/' ? '' : path}`;
            }
            
            return {
                ...item,
                url: itemUrl,
                images: await resolveImagePresets({ imageService, layoutManifest: pageLayoutManifest, contentFile: item, options, manifest }),
            };
        }))
        : [];

    const result = {
        ...resolution,
        images: imageContext,
        collectionItems: processedCollectionItems,
        layoutManifest: pageLayoutManifest,
    };


    return result;
}

/**
 * Assembles the final, top-level context for the theme's base shell (base.hbs).
 */
export async function assembleBaseContext(
    siteData: LocalSiteData,
    resolution: PageResolutionResult,
    options: RenderOptions,
    imageService: ImageService,
    pageContext: EnrichedPageContext
) {
    if (resolution.type === PageType.NotFound || pageContext.type === PageType.NotFound) {
        return {};
    }

    const { manifest } = siteData;
    const logoUrl = manifest.logo ? await imageService.getDisplayUrl(manifest, manifest.logo, { height: 32 }, options.isExport) : undefined;
    const faviconUrl = manifest.favicon ? await imageService.getDisplayUrl(manifest, manifest.favicon, { width: 32, height: 32 }, options.isExport) : undefined;
    const openGraphImageUrl = pageContext.images?.og_image?.url || pageContext.images?.teaser_thumbnail?.url;

    return {
        manifest,
        options,
        pageContext,
        navLinks: generateNavLinks(siteData, getUrlForNode(resolution.contentFile, manifest, true), options),
        headContext: {
            pageTitle: resolution.pageTitle,
            manifest,
            contentFile: resolution.contentFile,
            canonicalUrl: new URL(getUrlForNode(resolution.contentFile, manifest, false), manifest.baseUrl || 'https://example.com').href,
            baseUrl: options.relativeAssetPath ?? '/',
            styleOverrides: new Handlebars.SafeString(generateStyleOverrides(manifest.theme.config)),
            faviconUrl,
            logoUrl,
            openGraphImageUrl,
        },
    };
}

================================================================================

File: core/services/renderer/asset.service.ts
// src/core/services/rendering/asset.service.ts (NEW)

import Handlebars from 'handlebars';
import type { LocalSiteData } from '@/core/types';
import {
    getJsonAsset,
    getAssetContent,
    getAvailableLayouts,
    type ThemeManifest,
} from '@/core/services/config/configHelpers.service';
import { coreHelpers } from './helpers';

let areHelpersRegistered = false;

/**
 * Registers all core Handlebars helpers. Idempotent.
 */
function registerCoreHelpers(siteData: LocalSiteData): void {
    if (areHelpersRegistered) return;
    coreHelpers.forEach(helperFactory => {
        const helperMap = helperFactory(siteData);
        Object.entries(helperMap).forEach(([name, func]) => Handlebars.registerHelper(name, func));
    });
    areHelpersRegistered = true;
}

/**
 * Pre-compiles and caches all available theme and layout partials.
 */
async function cacheAllTemplates(siteData: LocalSiteData): Promise<void> {
    Object.keys(Handlebars.partials).forEach(p => Handlebars.unregisterPartial(p));
    
    const { manifest } = siteData;
    const allLayouts = await getAvailableLayouts(siteData);
    
    const layoutPromises = allLayouts.flatMap(layout =>
        (layout.files || []).map(async file => {
            const source = await getAssetContent(siteData, 'layout', layout.id, file.path);
            if (source) {
                // Register partials with namespaced names to match render_item helper expectations
                const partialName = file.type === 'partial' ? 
                    `${layout.id}/${file.path.replace('.hbs', '')}` : 
                    (file.name || `${layout.id}/${file.path.replace('.hbs', '')}`);
                Handlebars.registerPartial(partialName, source);
            }
        })
    );

    const themeManifest = await getJsonAsset<ThemeManifest>(siteData, 'theme', manifest.theme.name, 'theme.json');
    const themePartialPromises = (themeManifest?.files || [])
        .filter(file => file.type === 'partial' && file.name)
        .map(async partial => {
            const source = await getAssetContent(siteData, 'theme', manifest.theme.name, partial.path);
            if (source) Handlebars.registerPartial(partial.name!, source);
        });

    await Promise.all([...layoutPromises, ...themePartialPromises]);
}

/**
 * Generates an inline <style> block from the theme configuration.
 */
export function generateStyleOverrides(themeConfig: Record<string, string | number | boolean>): string {
    if (!themeConfig || Object.keys(themeConfig).length === 0) return '';
    const variables = Object.entries(themeConfig)
        .map(([key, value]) => value ? `  --${key.replace(/_/g, '-')}: ${value};` : null)
        .filter(Boolean)
        .join('\n');
    if (!variables) return '';
    return `<style id="signum-style-overrides">\n:root {\n${variables}\n}\n</style>`;
}

/**
 * Prepares the Handlebars rendering environment by registering helpers and caching all templates.
 * This is the main entry point for this module.
 */
export async function prepareRenderEnvironment(siteData: LocalSiteData): Promise<void> {
    registerCoreHelpers(siteData);
    await cacheAllTemplates(siteData);
}

================================================================================

File: core/services/renderer/helpers/imageUrl.helper.ts
// src/core/services/themes/helpers/image_url.helper.ts

// --- 1. Import Handlebars to access the SafeString constructor ---
import Handlebars from 'handlebars';
import type { SparktypeHelper } from './types';
import type { ImageRef, LocalSiteData, ImageTransformOptions } from '@/core/types';
import { getActiveImageService } from '@/core/services/images/images.service';

/**
 * Defines the context object passed by Handlebars at the root of the template.
 */
interface RootTemplateContext {
  options: {
    isExport: boolean;
  };
}

/**
 * A Handlebars helper factory for creating the `image_url` helper.
 */
export const imageUrlHelper: SparktypeHelper = (siteData: LocalSiteData) => ({
  /**
   * An async Handlebars helper that generates only the URL for an image,
   * applying transformations as specified. This is essential for use in
   * `<meta>` tags, CSS `url()` functions, or other places where a full `<img>` tag is not needed.
   *
   * @example
   * <meta property="og:image" content="{{image_url src=logo width=1200 height=630}}">
   *
   * @returns {Promise<Handlebars.SafeString>} A promise that resolves to the final, transformed image URL,
   * wrapped in a SafeString to prevent HTML escaping.
   */
  // --- 2. Update the return type signature to match the implementation ---
  image_url: async function(this: unknown, ...args: unknown[]): Promise<Handlebars.SafeString> {
    const options = args[args.length - 1] as Handlebars.HelperOptions;
    
    const rootContext = options.data.root as RootTemplateContext;
    const isExport = rootContext.options?.isExport || false;

    const { src, width, height, crop, gravity } = options.hash;

    if (!src || typeof src !== 'object' || !('serviceId' in src)) {
      console.warn('[image_url] Invalid or missing ImageRef object provided.');
      return new Handlebars.SafeString(''); // Return an empty SafeString
    }

    const imageRef = src as ImageRef;

    try {
      const imageService = getActiveImageService(siteData.manifest);
      const transformOptions: ImageTransformOptions = { width, height, crop, gravity };

      const displayUrl = await imageService.getDisplayUrl(siteData.manifest, imageRef, transformOptions, isExport);
      
      // --- 3. Wrap the final URL string in new Handlebars.SafeString() ---
      // This satisfies the type checker and ensures Handlebars won't escape the URL.
      return new Handlebars.SafeString(displayUrl);

    } catch (error) {
      console.error(`[image_url] Failed to generate URL for src: ${imageRef.src}`, error);
      return new Handlebars.SafeString(''); // Return an empty SafeString on error
    }
  }
});

================================================================================

File: core/services/renderer/helpers/renderLayout.helper.ts
// src/core/services/themes/helpers/render_layout.helper.ts

import Handlebars from 'handlebars';
import type { SparktypeHelper } from './types';

export const renderLayoutHelper: SparktypeHelper = () => ({
  /**
   * An async Handlebars helper that renders a specified layout/partial
   * and waits for any async helpers within it to resolve.
   * This is the key to solving nested `[object Promise]` issues.
   *
   * @example
   * {{{render_layout 'pageLayout' this}}}
   *
   * @param {...unknown[]} args - The arguments passed from the template. Expected:
   *   - args[0]: The name of the partial to render (string).
   *   - args[1]: The data context to pass to the partial (object).
   *   - The last argument is the Handlebars options object, which is ignored here.
   * @returns {Promise<Handlebars.SafeString>} The fully rendered and resolved HTML.
   */
  render_layout: async function(...args: unknown[]): Promise<Handlebars.SafeString> {
    // The template arguments are all but the last one (which is the options object).
    const templateArgs = args.slice(0, -1); 
    
    const layoutName = templateArgs[0];
    const context = templateArgs[1];

    // Type guards for safety and clear error logging.
    if (typeof layoutName !== 'string' || !Handlebars.partials[layoutName]) {
      console.warn(`[render_layout] Layout partial "${String(layoutName)}" not found or invalid.`);
      return new Handlebars.SafeString('');
    }

    if (typeof context !== 'object' || context === null) {
        console.warn(`[render_layout] Invalid context object provided for layout "${layoutName}".`);
        return new Handlebars.SafeString('');
    }

    const template = Handlebars.compile(Handlebars.partials[layoutName]);
    
    // The key is to `await` the execution of the template here.
    // This pauses the helper until all nested async helpers have resolved.
    const renderedHtml = await template(context);
    
    return new Handlebars.SafeString(renderedHtml);
  }
});

================================================================================

File: core/services/renderer/helpers/strUtil.helper.ts
// src/core/services/theme-engine/helpers/strUtil.helper.ts
import type { SparktypeHelper } from './types';
import type { HelperOptions } from 'handlebars';

export const strUtilHelper: SparktypeHelper = () => ({
  /**
   * A generic string utility helper for common text manipulations like
   * truncating, uppercasing, and lowercasing.
   *
   * @example {{str-util some.text op="truncate" len=100}}
   * @example {{str-util some.text op="uppercase"}}
   */
  // --- FIX: The function signature now correctly matches SparktypeHelperFunction ---
  'str-util': function(...args: unknown[]): string {
    // The options object from Handlebars is always the last argument.
    const options = args.pop() as HelperOptions;
    // The input string is the first argument passed from the template.
    const input = args[0];
  
    // Type guard: Ensure the input is a valid string before proceeding.
    if (!input || typeof input !== 'string') {
        // Return an empty string if the input is not a string, null, or undefined.
        return '';
    }
  
    // Extract the desired operation from the helper's hash arguments.
    const op = options.hash.op;
  
    switch (op) {
      case 'truncate':
        // Safely get the length, with a default value.
        const len = typeof options.hash.len === 'number' ? options.hash.len : 140;
        if (input.length <= len) return input;
        return input.substring(0, len) + 'â€¦';
      
      case 'uppercase':
        return input.toUpperCase();
      
      case 'lowercase':
        return input.toLowerCase();
      
      default:
        // If no valid operation is specified, return the original string.
        return input;
    }
  }
});

================================================================================

File: core/services/renderer/helpers/concat.helper.ts
// src/core/services/theme-engine/helpers/concat.helper.ts

import type { SparktypeHelper } from './types';


export const concatHelper: SparktypeHelper = () => ({
  /**
   * Concatenates multiple string arguments into a single string.
   *
   * @example
   * {{concat "Hello" " " "World"}} -> "Hello World"
   *
   * @example
   * <img alt=(concat @root.manifest.title " Logo")>
   */
  concat: function(...args: unknown[]): string {
  
    args.pop();

    // Join all remaining arguments with an empty string.
    return args.join('');
  },
});

================================================================================

File: core/services/renderer/helpers/query.helper.ts
// src/core/services/theme-engine/helpers/query.helper.ts
import Handlebars from 'handlebars';
import type { SparktypeHelper } from './types';

// The helper factory receives the full siteData object, which it can use.
export const queryHelper: SparktypeHelper = (siteData) => ({
  /**
   * Fetches, filters, and sorts a list of content items from a collection.
   * The resulting array is made available to the inner block of the helper.
   *
   * @example
   * {{#query source_collection="blog" limit=5 as |posts|}}
   *   {{#each posts}} ... {{/each}}
   * {{/query}}
   */
  // --- FIX: The function signature now correctly matches SparktypeHelperFunction ---
  // The 'this' context is now 'unknown' and is not used.
  query: function(this: unknown, ...args: unknown[]): string {
    const options = args[args.length - 1] as Handlebars.HelperOptions;
    const config = options.hash;

    const sourceCollectionSlug = config.source_collection;
    if (!sourceCollectionSlug || typeof sourceCollectionSlug !== 'string') {
      console.warn("Query helper called without a valid 'source_collection' string.");
      return options.inverse ? options.inverse(this) : '';
    }

    // Find the source collection node in the site's structure.
    const collectionNode = siteData.manifest.structure.find(
        n => n.slug === sourceCollectionSlug
    );
    if (!collectionNode || !collectionNode.children) {
      console.warn(`Query could not find collection with slug: "${sourceCollectionSlug}"`);
      return options.inverse ? options.inverse(this) : '';
    }
    
    const childPaths = new Set(collectionNode.children.map(c => c.path));
    let items = (siteData.contentFiles ?? []).filter(f => childPaths.has(f.path));

    const sortBy = config.sort_by || 'date';
    const sortOrder = config.sort_order || 'desc';
    const orderModifier = sortOrder === 'desc' ? -1 : 1;

    items.sort((a, b) => {
      const valA = a.frontmatter[sortBy];
      const valB = b.frontmatter[sortBy];
      if (sortBy === 'date') {
        const dateA = valA ? new Date(valA as string).getTime() : 0;
        const dateB = valB ? new Date(valB as string).getTime() : 0;
        if (isNaN(dateA) || isNaN(dateB)) return 0;
        return (dateA - dateB) * orderModifier;
      }
      if (typeof valA === 'string' && typeof valB === 'string') {
        return valA.localeCompare(valB) * orderModifier;
      }
      if (typeof valA === 'number' && typeof valB === 'number') {
        return (valA - valB) * orderModifier;
      }
      return 0;
    });

    if (config.limit) {
      const limit = parseInt(config.limit, 10);
      if (!isNaN(limit)) {
        items = items.slice(0, limit);
      }
    }

    // Render the inner block, passing the queried items as a block parameter.
    if (options.data && options.fn) {
        const data = Handlebars.createFrame(options.data);
        const blockParamName = options.data.blockParams?.[0];
        if (blockParamName) {
            data[blockParamName] = items;
        }
        return options.fn(items, { data });
    }
    
    return options.fn(items);
  }
});

================================================================================

File: core/services/renderer/helpers/markdown.helper.ts
// src/core/services/theme-engine/helpers/markdown.helper.ts
import type { SparktypeHelper } from './types';
import Handlebars from 'handlebars';
import { marked } from 'marked';
import DOMPurify from 'dompurify';

export const markdownHelper: SparktypeHelper = () => ({
  /**
   * Safely renders a string of Markdown into HTML.
   * It uses 'marked' to parse the Markdown and 'DOMPurify' to sanitize
   * the resulting HTML, preventing XSS attacks.
   * @example {{{markdown some.body_content}}}
   */
  // --- FIX: The function signature now correctly matches SparktypeHelperFunction ---
  markdown: function(...args: unknown[]): Handlebars.SafeString {
    // The markdown content is the first argument passed to the helper.
    const markdownString = args[0];

    // Type guard: Ensure the input is a non-empty string before processing.
    if (!markdownString || typeof markdownString !== 'string') {
      return new Handlebars.SafeString('');
    }

    // Use marked to parse, then DOMPurify to sanitize against XSS attacks.
    const unsafeHtml = marked.parse(markdownString, { async: false }) as string;
    
    // Check if running in a browser environment before using DOMPurify
    if (typeof window !== 'undefined') {
        const safeHtml = DOMPurify.sanitize(unsafeHtml);
        return new Handlebars.SafeString(safeHtml);
    }

    // If not in a browser (e.g., during server-side testing), return the raw parsed HTML.
    // In a real-world scenario, you might use a Node.js-compatible sanitizer here.
    return new Handlebars.SafeString(unsafeHtml);
  }
});

================================================================================

File: core/services/renderer/helpers/themeData.helper.ts
// src/core/services/renderer/helpers/themeData.helper.ts

import type { SparktypeHelper } from './types';
import { HtmlSanitizerService } from '../../htmlSanitizer.service';
import type { LocalSiteData } from '@/core/types';

export const themeDataHelper: SparktypeHelper = (siteData: LocalSiteData) => ({
  themeData: function(this: unknown, ...args: unknown[]) {
    const fieldName = args[0] as string;
    
    // Access theme data from the site data
    const themeData = siteData.manifest?.theme?.themeData;
    
    if (!themeData || typeof themeData !== 'object') {
      return '';
    }
    
    const value = themeData[fieldName];
    
    if (value === undefined || value === null) {
      return '';
    }
    
    // If it's a string, sanitize it before returning
    if (typeof value === 'string') {
      return HtmlSanitizerService.sanitize(value);
    }
    
    // For non-string values, return as-is
    return String(value);
  }
});

export const rawThemeDataHelper: SparktypeHelper = (siteData: LocalSiteData) => ({
  rawThemeData: function(this: unknown, ...args: unknown[]) {
    const fieldName = args[0] as string;
    
    // Access theme data from the site data (unsanitized)
    const themeData = siteData.manifest?.theme?.themeData;
    
    if (!themeData || typeof themeData !== 'object') {
      return '';
    }
    
    const value = themeData[fieldName];
    
    if (value === undefined || value === null) {
      return '';
    }
    
    return String(value);
  }
});

================================================================================

File: core/services/renderer/helpers/comparison.helper.ts
// src/core/services/theme-engine/helpers/comparison.helper.ts
import type { SparktypeHelper } from './types';

/**
 * Provides a set of comparison helpers for Handlebars templates.
 * These helpers are now type-safe and handle 'unknown' inputs correctly.
 *
 * @example
 * {{#if (eq post.status "published")}} ... {{/if}}
 * {{#if (gt comment.likes 10)}} ... {{/if}}
 */
export const comparisonHelpers: SparktypeHelper = () => ({
  /**
   * Checks for strict equality (===). Safe for any type.
   */
  eq: (a: unknown, b: unknown): boolean => a === b,

  /**
   * Checks if the first argument is greater than the second.
   * Only compares numbers or strings. Returns false for other types.
   */
  gt: (a: unknown, b: unknown): boolean => {

    // Only proceed if both 'a' and 'b' are of the same comparable type.
    if (typeof a === 'number' && typeof b === 'number') {
      return a > b;
    }
    if (typeof a === 'string' && typeof b === 'string') {
      return a > b;
    }
    // For all other type combinations, comparison is not meaningful.
    return false;
  },

  /**
   * Checks if the first argument is less than the second.
   * Only compares numbers or strings. Returns false for other types.
   */
  lt: (a: unknown, b: unknown): boolean => {

    if (typeof a === 'number' && typeof b === 'number') {
      return a < b;
    }
    if (typeof a === 'string' && typeof b === 'string') {
      return a < b;
    }
    return false;
  },
});

================================================================================

File: core/services/renderer/helpers/getUrl.helper.ts
// src/core/services/theme-engine/helpers/getUrl.helper.ts
import type { SparktypeHelper } from './types';
import { getUrlForNode as getUrlUtil } from '@/core/services/urlUtils.service';
import type { StructureNode } from '@/core/types';
import type { HelperOptions } from 'handlebars';

// The helper factory receives the full siteData object.
export const getUrlHelper: SparktypeHelper = (siteData) => ({
  /**
   * A Handlebars helper to expose the getUrlForNode utility to templates.
   * This allows templates to generate correct, context-aware links for pages.
   *
   * @example
   * <a href="{{getUrlForNode this isExport=../options.isExport}}">Link</a>
   */

  getUrlForNode: function(this: unknown, ...args: unknown[]): string {
    // The options object from Handlebars is always the last argument.
    const options = args.pop() as HelperOptions;
    
    // The node object is the first argument passed from the template.
    const node = args[0] as StructureNode;
    
    // Extract the 'isExport' flag from the helper's hash arguments.
    const isExport = options.hash.isExport === true;
    
    // Type guard to ensure the node is valid before proceeding.
    if (!node || typeof node !== 'object' || !('path' in node) || !('slug' in node)) {
        console.warn('Handlebars "getUrlForNode" helper was called with an invalid node object.');
        return '#error-invalid-node';
    }

    // The utility function needs the full manifest to determine if the node is the homepage.
    return getUrlUtil(node, siteData.manifest, isExport);
  }
});

================================================================================

File: core/services/renderer/helpers/types.ts
// src/core/services/theme-engine/helpers/types.ts
import type { LocalSiteData } from '@/core/types';
import Handlebars from 'handlebars';

/**
 * Defines the function signature for a Handlebars helper function within Sparktype.
 * `this` refers to the current template context.
 * `args` are the arguments passed to the helper in the template.
 */
export type SparktypeHelperFunction = (
  /**
   * FIX: Replaced 'any' with 'unknown' for the 'this' context.
   * The context within a Handlebars helper is dynamic. 'unknown' is the
   * type-safe equivalent of 'any', requiring type checks before use.
   */
  this: unknown,
  /**
   * FIX: Replaced 'any[]' with 'unknown[]' for the helper arguments.
   * Helpers can receive a variable number of arguments of any type.
   * 'unknown[]' safely represents this contract.
   */
  ...args: unknown[]
) => string | Handlebars.SafeString | boolean | Promise<Handlebars.SafeString>;

/**
 * Defines a "Helper Factory". It's a function that receives the full site data
 * and returns an object mapping helper names to their implementation functions.
 */
export type SparktypeHelper = (siteData: LocalSiteData) => Record<string, SparktypeHelperFunction>;

================================================================================

File: core/services/renderer/helpers/pager.helper.ts
// src/core/services/theme-engine/helpers/pager.helper.ts

import Handlebars from 'handlebars';
import type { SparktypeHelper } from './types';
import type { PaginationData } from '@/core/types';

/**
 * A type guard to check if an unknown value has the shape of PaginationData.
 * @param data The unknown data to check.
 * @returns {boolean} True if the data is valid PaginationData.
 */
function isPaginationData(data: unknown): data is PaginationData {
    if (typeof data !== 'object' || data === null) {
        return false;
    }
    const d = data as PaginationData;
    return (
        typeof d.currentPage === 'number' &&
        typeof d.totalPages === 'number' &&
        typeof d.hasPrevPage === 'boolean' &&
        typeof d.hasNextPage === 'boolean'
    );
}


/**
 * Renders a complete pagination control component.
 * It generates 'Previous' and 'Next' links and a 'Page X of Y' indicator.
 * The links are disabled when not applicable (e.g., on the first or last page).
 * 
 * @example
 * {{{pager pagination}}}
 */
export const pagerHelper: SparktypeHelper = () => ({
  // --- FIX: The function signature now correctly matches SparktypeHelperFunction ---
  pager: function(...args: unknown[]): Handlebars.SafeString {
    // The pagination object is the first argument passed from the template.
    const pagination = args[0];

    // --- FIX: Use the type guard to validate the input ---
    if (!isPaginationData(pagination) || pagination.totalPages <= 1) {
      return new Handlebars.SafeString('');
    }

    const prevPageUrl = pagination.prevPageUrl ?? '#';
    const nextPageUrl = pagination.nextPageUrl ?? '#';

    const prevLink = pagination.hasPrevPage
      ? `<a href="${prevPageUrl}" class="link dim br-pill ph3 pv2 ba b--black-10 black">â€¹ Previous</a>`
      : `<span class="br-pill ph3 pv2 ba b--black-10 moon-gray o-50 cursor-not-allowed">â€¹ Previous</span>`;

    const nextLink = pagination.hasNextPage
      ? `<a href="${nextPageUrl}" class="link dim br-pill ph3 pv2 ba b--black-10 black">Next â€º</a>`
      : `<span class="br-pill ph3 pv2 ba b--black-10 moon-gray o-50 cursor-not-allowed">Next â€º</span>`;
    
    const pageIndicator = `<div class="f6 mid-gray">Page ${pagination.currentPage} of ${pagination.totalPages}</div>`;

    const pagerHtml = `
      <div class="flex items-center justify-between mt4 pt3 bt b--black-10">
        <div>${prevLink}</div>
        <div>${pageIndicator}</div>
        <div>${nextLink}</div>
      </div>
    `;

    return new Handlebars.SafeString(pagerHtml);
  }
});

================================================================================

File: core/services/renderer/helpers/assign.helper.ts
// src/core/services/theme-engine/helpers/assign.helper.ts
import type { SparktypeHelper } from './types';
import type { HelperOptions } from 'handlebars';

export const assignHelper: SparktypeHelper = () => ({
  /**
   * A Handlebars helper to add a new property to an object's context
   * before rendering a block. This is useful for augmenting data inside a loop.
   *
   * @example
   * {{#assign myItem "newUrl" "https://example.com"}}
   *   <a href="{{this.newUrl}}">{{this.title}}</a>
   * {{/assign}}
   */

  assign: function(this: unknown, ...args: unknown[]): string {
    // The last argument passed by Handlebars is always the options object.
    const options = args.pop() as HelperOptions;

    // We expect 3 arguments from the template: [object, key, value]
    if (args.length !== 3) {
      console.warn('Handlebars "assign" helper called with incorrect number of arguments. Expected 3.');
      // Gracefully fail by rendering the {{else}} block if it exists.
      return options.inverse ? options.inverse(this) : '';
    }

    const [object, key, value] = args;

    // Add type guards to ensure the arguments are used safely.
    if (typeof object !== 'object' || object === null) {
      console.warn(`Handlebars "assign" helper: first argument must be an object, but received type ${typeof object}.`);
      return options.inverse ? options.inverse(this) : '';
    }

    if (typeof key !== 'string' || key === '') {
      console.warn(`Handlebars "assign" helper: second argument must be a non-empty string key, but received type ${typeof key}.`);
      return options.inverse ? options.inverse(this) : '';
    }

    // Create a new context object by spreading the original and adding the new key-value pair.
    const newContext = { ...object, [key]: value };

    // Execute the inner block of the helper, passing the new, augmented context to it.
    // This is what makes the new property available inside the {{#assign}}...{{/assign}} block.
    return options.fn(newContext);
  },
});

================================================================================

File: core/services/renderer/helpers/index.ts
// src/lib/theme-helpers/index.ts
// ... (other helper imports)
import { queryHelper } from './query.helper';
import { comparisonHelpers } from './comparison.helper';
import { markdownHelper } from './markdown.helper';
import { strUtilHelper } from './strUtil.helper';
import { formatDateHelper } from './formatDate.helper';
import { pagerHelper } from './pager.helper';
import type { SparktypeHelper } from './types';
import { getUrlHelper } from './getUrl.helper';
import { assignHelper } from './assign.helper';
import { imageHelper } from './image.helper';
import { concatHelper } from './concat.helper';
import { imageUrlHelper } from './imageUrl.helper';
import { renderLayoutHelper } from './renderLayout.helper';
import { renderItemHelper } from './renderItem.helper';
import { themeDataHelper, rawThemeDataHelper } from './themeData.helper';

export const coreHelpers: SparktypeHelper[] = [
  queryHelper,
  strUtilHelper,
  formatDateHelper,
  comparisonHelpers,
  markdownHelper,
  renderItemHelper, 
  pagerHelper,
  getUrlHelper,
  assignHelper,
  imageHelper,
  concatHelper,
  imageUrlHelper,
  renderLayoutHelper,
  themeDataHelper,
  rawThemeDataHelper
];

================================================================================

File: core/services/renderer/helpers/formatDate.helper.ts
// src/core/services/theme-engine/helpers/formatDate.helper.ts
import type { SparktypeHelper } from './types';

export const formatDateHelper: SparktypeHelper = () => ({
  /**
   * Formats a date string or Date object into a more readable format.
   * @example {{formatDate some.date_string}}
   * @example {{formatDate "2023-10-27"}}
   */

  formatDate: function(...args: unknown[]): string {
    // The date value is the first argument passed to the helper.
    const dateString = args[0];

    // Type guard: Check if the input is a valid type for the Date constructor.
    if (
        !dateString ||
        (typeof dateString !== 'string' &&
         typeof dateString !== 'number' &&
         !(dateString instanceof Date))
    ) {
      // If the input is null, undefined, or an invalid type, return an empty string.
      return '';
    }
    
    // The Date constructor can safely handle string, number, or Date objects.
    const date = new Date(dateString);
    
    // Check if the created date is valid. `new Date('invalid')` results in an invalid date.
    if (isNaN(date.getTime())) {
      console.warn(`Handlebars "formatDate" helper received an invalid date value:`, dateString);
      return ''; // Return empty for invalid dates
    }

    // Format the valid date into a user-friendly string.
    return date.toLocaleDateString('en-GB', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
  }
});

================================================================================

File: core/services/renderer/helpers/renderItem.helper.ts
// src/core/services/themes/helpers/render_item.helper.ts

import Handlebars from 'handlebars';
import type { SparktypeHelper } from './types';
import type { ParsedMarkdownFile, CollectionConfig } from '@/core/types';
import type { LayoutManifest } from '@/core/services/config/configHelpers.service';
import type { HelperOptions } from 'handlebars';

/**
 * Defines the expected shape of the root context object passed by the theme engine.
 */
interface RootContext {
  contentFile: ParsedMarkdownFile;
  layoutManifest: LayoutManifest;
  // ... other root properties
}

/**
 * A Handlebars helper factory for creating the `render_item` helper.
 */
export const renderItemHelper: SparktypeHelper = () => ({
  /**
   * --- FIX: This helper is now `async` ---
   * Renders the correct teaser/partial for a single content item within a collection loop.
   *
   * @example
   * {{#each collectionItems}}
   *   {{{render_item this}}}
   * {{/each}}
   *
   * @param {...unknown[]} args - The arguments passed from the template. Expected:
   *   - args[0]: The current item in the `each` loop (ParsedMarkdownFile).
   *   - The last argument is the Handlebars options object.
   * @returns {Promise<Handlebars.SafeString>} The rendered HTML for the item's teaser.
   */
  render_item: async function(...args: unknown[]): Promise<Handlebars.SafeString> {
    // The Handlebars options object is always the last argument.
    const options = args[args.length - 1] as HelperOptions;
    // The item context is the first argument passed from the template.
    const item = args[0] as ParsedMarkdownFile;

    const root = options.data.root as RootContext;

    // --- Guard Clauses for Robustness ---
    if (!item) {
        console.warn('[render_item] Helper was called without an item context.');
        return new Handlebars.SafeString('');
    }
    if (!root?.layoutManifest?.display_options?.teaser) {
        console.warn('[render_item] The collection layout manifest is missing a `display_options.teaser` configuration.');
        return new Handlebars.SafeString(`<!-- Missing teaser configuration in layout -->`);
    }

    // --- Logic to Determine Which Teaser Template to Use ---
    const teaserOptions = root.layoutManifest.display_options.teaser;
    const collectionConfig = root.contentFile.frontmatter.collection as CollectionConfig | undefined;

    const userChoiceKey = collectionConfig?.teaser as string | undefined;
    const finalChoiceKey = userChoiceKey || teaserOptions.default;
    const templatePath = teaserOptions.options[finalChoiceKey]?.template;

    if (!templatePath) {
        console.warn(`[render_item] Teaser template for choice "${finalChoiceKey}" not found in layout manifest.`);
        return new Handlebars.SafeString(`<!-- Teaser template for "${finalChoiceKey}" not found -->`);
    }
    
    // --- Render the Partial ---
    const layoutId = root.layoutManifest.id;
    // The partial name is namespaced to prevent collisions, e.g., 'blog/partials/card'.
    const partialName = `${layoutId}/${templatePath.replace('.hbs', '')}`;

    const templateSource = Handlebars.partials[partialName];

    if (templateSource) {
        // Compile the template source and render with the item context
        const template = typeof templateSource === 'function' ? templateSource : Handlebars.compile(templateSource);
        // --- FIX: Await the template execution to resolve any nested async helpers ---
        const renderedHtml = await template(item);
        return new Handlebars.SafeString(renderedHtml);
    } else {
        console.warn(`[render_item] Handlebars partial named "${partialName}" could not be found.`);
        return new Handlebars.SafeString(`<!-- Partial "${partialName}" not found -->`);
    }
  }
});

================================================================================

File: core/services/renderer/helpers/image.helper.ts
// src/core/services/theme-engine/helpers/image.helper.ts

import Handlebars from 'handlebars';
import type { SparktypeHelper } from './types';
// --- FIX: Import ImageTransformOptions along with the other types ---
import type { ImageRef, LocalSiteData, ImageTransformOptions } from '@/core/types';
import { getActiveImageService } from '@/core/services/images/images.service';

interface RootTemplateContext {
  options: {
    isExport: boolean;
  };
}

export const imageHelper: SparktypeHelper = (siteData: LocalSiteData) => ({
  /**
   * An async Handlebars helper to generate image URLs with transformations.
   * It reads parameters from the helper's hash.
   * @example {{{image src=logo width=100 height=100}}}
   */
  image: async function(this: unknown, ...args: unknown[]): Promise<Handlebars.SafeString> {
    // The actual options object from Handlebars is always the last argument.
    const options = args[args.length - 1] as Handlebars.HelperOptions;
    
    const rootContext = options.data.root as RootTemplateContext;
    const isExport = rootContext.options?.isExport || false;

    // Destructure properties from the hash object within options.
    const { src, width, height, crop, gravity, alt, lazy = true, class: className = '' } = options.hash;

    if (!src || typeof src !== 'object' || !('serviceId' in src)) {
      return new Handlebars.SafeString('<!-- Invalid ImageRef provided to image helper -->');
    }

    const imageRef = src as ImageRef;

    try {
      const imageService = getActiveImageService(siteData.manifest);
      
      const transformOptions: ImageTransformOptions = { width, height, crop, gravity };

      const displayUrl = await imageService.getDisplayUrl(siteData.manifest, imageRef, transformOptions, isExport);
      
      const lazyAttr = lazy ? 'loading="lazy"' : '';
      const altAttr = `alt="${alt || imageRef.alt || ''}"`;
      const classAttr = className ? `class="${className}"` : '';
      const widthAttr = width ? `width="${width}"` : '';
      const heightAttr = height ? `height="${height}"` : '';

      const imgTag = `<img src="${displayUrl}" ${widthAttr} ${heightAttr} ${altAttr} ${classAttr} ${lazyAttr}>`;

      return new Handlebars.SafeString(imgTag);
    } catch (error) {
      console.error(`[ImageHelper] Failed to render image for src: ${imageRef.src}`, error);
      return new Handlebars.SafeString(`<!-- Image render failed: ${(error as Error).message} -->`);
    }
  }
});

================================================================================

File: core/services/renderer/helpers/__tests__/image.helper.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import { imageHelper } from '../image.helper';
import { getActiveImageService } from '@/core/services/images/images.service';
import { LocalSiteData, ImageRef, Manifest } from '@/core/types';
import Handlebars from 'handlebars';

// Mock the image service
jest.mock('@/core/services/images/images.service', () => ({
  getActiveImageService: jest.fn()
}));

const mockGetActiveImageService = getActiveImageService as jest.MockedFunction<typeof getActiveImageService>;

describe('image.helper', () => {
  // Helper functions
  const createMockSiteData = (): LocalSiteData => ({
    siteId: 'test-site',
    manifest: {
      siteId: 'test-site',
      generatorVersion: '1.0.0',
      title: 'Test Site',
      description: 'Test Site',
      theme: { name: 'default', config: {} },
      structure: [],
      settings: { imageService: 'local' }
    } as Manifest,
    contentFiles: []
  });

  const createMockImageRef = (): ImageRef => ({
    serviceId: 'local',
    src: 'assets/images/test.jpg',
    alt: 'Test Image',
    width: 800,
    height: 600
  });

  const createMockHandlebarsOptions = (hash: Record<string, unknown> = {}): Handlebars.HelperOptions => ({
    hash,
    data: {
      root: {
        options: {
          isExport: false
        }
      }
    },
    fn: jest.fn(),
    inverse: jest.fn(),
    lookupProperty: jest.fn()
  });

  const mockImageService = {
    id: 'local',
    name: 'Local Service',
    upload: jest.fn(),
    getDisplayUrl: jest.fn(),
    getExportableAssets: jest.fn()
  };

  beforeEach(() => {
    jest.clearAllMocks();
    mockGetActiveImageService.mockReturnValue(mockImageService);
    mockImageService.getDisplayUrl.mockResolvedValue('https://example.com/test.jpg');
  });

  describe('image helper', () => {
    test('generates img tag with basic parameters', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300,
        height: 200,
        alt: 'Custom Alt Text'
      });

      const result = await helper.image.call({}, options);

      expect(result).toBeInstanceOf(Handlebars.SafeString);
      const htmlString = result.toString();
      
      expect(htmlString).toContain('<img');
      expect(htmlString).toContain('src="https://example.com/test.jpg"');
      expect(htmlString).toContain('width="300"');
      expect(htmlString).toContain('height="200"');
      expect(htmlString).toContain('alt="Custom Alt Text"');
      expect(htmlString).toContain('loading="lazy"');
      expect(htmlString).toContain('>');
    });

    test('uses imageRef alt when no custom alt provided', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300
      });

      const result = await helper.image.call({}, options);
      const htmlString = result.toString();
      
      expect(htmlString).toContain('alt="Test Image"');
    });

    test('handles missing alt gracefully', async () => {
      const siteData = createMockSiteData();
      const imageRef = { ...createMockImageRef(), alt: undefined };
      const helper = imageHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300
      });

      const result = await helper.image.call({}, options);
      const htmlString = result.toString();
      
      expect(htmlString).toContain('alt=""');
    });

    test('applies CSS class when provided', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300,
        class: 'thumbnail responsive'
      });

      const result = await helper.image.call({}, options);
      const htmlString = result.toString();
      
      expect(htmlString).toContain('class="thumbnail responsive"');
    });

    test('disables lazy loading when lazy=false', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300,
        lazy: false
      });

      const result = await helper.image.call({}, options);
      const htmlString = result.toString();
      
      expect(htmlString).not.toContain('loading="lazy"');
    });

    test('passes transform options to image service', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300,
        height: 200,
        crop: 'fill',
        gravity: 'center'
      });

      await helper.image.call({}, options);

      expect(mockImageService.getDisplayUrl).toHaveBeenCalledWith(
        siteData.manifest,
        imageRef,
        {
          width: 300,
          height: 200,
          crop: 'fill',
          gravity: 'center'
        },
        false
      );
    });

    test('respects export mode from root context', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300
      });
      
      // Set export mode
      options.data.root.options.isExport = true;

      await helper.image.call({}, options);

      expect(mockImageService.getDisplayUrl).toHaveBeenCalledWith(
        siteData.manifest,
        imageRef,
        { width: 300 },
        true // isExport should be true
      );
    });

    test('handles invalid ImageRef gracefully', async () => {
      const siteData = createMockSiteData();
      const helper = imageHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: 'invalid-string',
        width: 300
      });

      const result = await helper.image.call({}, options);
      const htmlString = result.toString();
      
      expect(htmlString).toBe('<!-- Invalid ImageRef provided to image helper -->');
      expect(mockImageService.getDisplayUrl).not.toHaveBeenCalled();
    });

    test('handles missing src parameter', async () => {
      const siteData = createMockSiteData();
      const helper = imageHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        width: 300
      });

      const result = await helper.image.call({}, options);
      const htmlString = result.toString();
      
      expect(htmlString).toBe('<!-- Invalid ImageRef provided to image helper -->');
    });

    test('handles image service errors gracefully', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageHelper(siteData);
      
      const error = new Error('Image processing failed');
      mockImageService.getDisplayUrl.mockRejectedValue(error);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300
      });

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

      const result = await helper.image.call({}, options);
      const htmlString = result.toString();
      
      expect(htmlString).toBe('<!-- Image render failed: Image processing failed -->');
      expect(consoleSpy).toHaveBeenCalledWith(
        '[ImageHelper] Failed to render image for src: assets/images/test.jpg',
        error
      );
      
      consoleSpy.mockRestore();
    });

    test('generates minimal img tag with only required attributes', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef
      });

      const result = await helper.image.call({}, options);
      const htmlString = result.toString();
      
      expect(htmlString).toContain('<img');
      expect(htmlString).toContain('src="https://example.com/test.jpg"');
      expect(htmlString).toContain('alt="Test Image"');
      expect(htmlString).toContain('loading="lazy"');
      expect(htmlString).not.toContain('width=');
      expect(htmlString).not.toContain('height=');
      expect(htmlString).not.toContain('class=');
    });

    test('handles different image service types', async () => {
      const siteData = createMockSiteData();
      siteData.manifest.settings = { imageService: 'cloudinary' };
      
      const cloudinaryService = {
        id: 'cloudinary',
        name: 'Cloudinary Service',
        upload: jest.fn(),
        getDisplayUrl: jest.fn().mockResolvedValue('https://cloudinary.com/test.jpg'),
        getExportableAssets: jest.fn()
      };
      
      mockGetActiveImageService.mockReturnValue(cloudinaryService);
      
      const imageRef = createMockImageRef();
      const helper = imageHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300
      });

      const result = await helper.image.call({}, options);
      const htmlString = result.toString();
      
      expect(htmlString).toContain('src="https://cloudinary.com/test.jpg"');
      expect(cloudinaryService.getDisplayUrl).toHaveBeenCalled();
    });

    test('handles complex transform combinations', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 400,
        height: 300,
        crop: 'fit',
        gravity: 'north',
        alt: 'Complex Transform',
        class: 'featured-image',
        lazy: false
      });

      const result = await helper.image.call({}, options);
      const htmlString = result.toString();
      
      expect(htmlString).toContain('src="https://example.com/test.jpg"');
      expect(htmlString).toContain('width="400"');
      expect(htmlString).toContain('height="300"');
      expect(htmlString).toContain('alt="Complex Transform"');
      expect(htmlString).toContain('class="featured-image"');
      expect(htmlString).not.toContain('loading="lazy"');
      
      expect(mockImageService.getDisplayUrl).toHaveBeenCalledWith(
        siteData.manifest,
        imageRef,
        {
          width: 400,
          height: 300, 
          crop: 'fit',
          gravity: 'north'
        },
        false
      );
    });

    test('maintains proper HTML structure and formatting', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 200,
        height: 150,
        alt: 'Test & Sample "Image"',
        class: 'test-class'
      });

      const result = await helper.image.call({}, options);
      const htmlString = result.toString();
      
      // Should be well-formed HTML
      expect(htmlString).toMatch(/^<img\s[^>]*>$/);
      expect(htmlString).toContain('alt="Test & Sample "Image""');
      
      // Verify no extra whitespace issues
      expect(htmlString).not.toContain('  '); // No double spaces
      expect(htmlString.trim()).toBe(htmlString); // No leading/trailing whitespace
    });

    test('handles concurrent image processing', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300
      });

      // Process multiple images concurrently
      const promises = Array.from({ length: 5 }, () => 
        helper.image.call({}, options)
      );

      const results = await Promise.all(promises);
      
      expect(results).toHaveLength(5);
      results.forEach(result => {
        expect(result).toBeInstanceOf(Handlebars.SafeString);
        expect(result.toString()).toContain('<img');
      });
      
      expect(mockImageService.getDisplayUrl).toHaveBeenCalledTimes(5);
    });
  });

  describe('Helper Factory', () => {
    test('returns object with image helper function', () => {
      const siteData = createMockSiteData();
      const helpers = imageHelper(siteData);
      
      expect(helpers).toHaveProperty('image');
      expect(typeof helpers.image).toBe('function');
    });

    test('helper function is async', () => {
      const siteData = createMockSiteData();
      const helpers = imageHelper(siteData);
      const imageRef = createMockImageRef();
      
      const options = createMockHandlebarsOptions({
        src: imageRef
      });

      const result = helpers.image.call({}, options);
      expect(result).toBeInstanceOf(Promise);
    });

    test('different site data creates independent helpers', () => {
      const siteData1 = createMockSiteData();
      const siteData2 = { ...createMockSiteData(), siteId: 'different-site' };
      
      const helpers1 = imageHelper(siteData1);
      const helpers2 = imageHelper(siteData2);
      
      expect(helpers1).not.toBe(helpers2);
      expect(helpers1.image).not.toBe(helpers2.image);
    });
  });
});

================================================================================

File: core/services/renderer/helpers/__tests__/imageUrl.helper.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import { imageUrlHelper } from '../imageUrl.helper';
import { getActiveImageService } from '@/core/services/images/images.service';
import { LocalSiteData, ImageRef, Manifest } from '@/core/types';
import Handlebars from 'handlebars';

// Mock the image service
jest.mock('@/core/services/images/images.service', () => ({
  getActiveImageService: jest.fn()
}));

const mockGetActiveImageService = getActiveImageService as jest.MockedFunction<typeof getActiveImageService>;

describe('imageUrl.helper', () => {
  // Helper functions
  const createMockSiteData = (): LocalSiteData => ({
    siteId: 'test-site',
    manifest: {
      siteId: 'test-site',
      generatorVersion: '1.0.0',
      title: 'Test Site',
      description: 'Test Site',
      theme: { name: 'default', config: {} },
      structure: [],
      settings: { imageService: 'local' }
    } as Manifest,
    contentFiles: []
  });

  const createMockImageRef = (): ImageRef => ({
    serviceId: 'local',
    src: 'assets/images/test.jpg',
    alt: 'Test Image',
    width: 800,
    height: 600
  });

  const createMockHandlebarsOptions = (hash: Record<string, unknown> = {}): Handlebars.HelperOptions => ({
    hash,
    data: {
      root: {
        options: {
          isExport: false
        }
      }
    },
    fn: jest.fn(),
    inverse: jest.fn(),
    lookupProperty: jest.fn()
  });

  const mockImageService = {
    id: 'local',
    name: 'Local Service',
    upload: jest.fn(),
    getDisplayUrl: jest.fn(),
    getExportableAssets: jest.fn()
  };

  beforeEach(() => {
    jest.clearAllMocks();
    mockGetActiveImageService.mockReturnValue(mockImageService);
    mockImageService.getDisplayUrl.mockResolvedValue('https://example.com/test.jpg');
  });

  describe('image_url helper', () => {
    test('returns URL as SafeString with basic parameters', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageUrlHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300,
        height: 200
      });

      const result = await helper.image_url.call({}, options);

      expect(result).toBeInstanceOf(Handlebars.SafeString);
      expect(result.toString()).toBe('https://example.com/test.jpg');
    });

    test('passes transform options to image service', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageUrlHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300,
        height: 200,
        crop: 'fill',
        gravity: 'center'
      });

      await helper.image_url.call({}, options);

      expect(mockImageService.getDisplayUrl).toHaveBeenCalledWith(
        siteData.manifest,
        imageRef,
        {
          width: 300,
          height: 200,
          crop: 'fill',
          gravity: 'center'
        },
        false
      );
    });

    test('respects export mode from root context', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageUrlHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300
      });
      
      // Set export mode
      options.data.root.options.isExport = true;

      await helper.image_url.call({}, options);

      expect(mockImageService.getDisplayUrl).toHaveBeenCalledWith(
        siteData.manifest,
        imageRef,
        { width: 300 },
        true // isExport should be true
      );
    });

    test('handles missing export context gracefully', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageUrlHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300
      });
      
      // Remove export context
      delete options.data.root.options;

      await helper.image_url.call({}, options);

      expect(mockImageService.getDisplayUrl).toHaveBeenCalledWith(
        siteData.manifest,
        imageRef,
        { width: 300 },
        false // should default to false
      );
    });

    test('handles invalid ImageRef with string src', async () => {
      const siteData = createMockSiteData();
      const helper = imageUrlHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: 'invalid-string',
        width: 300
      });

      const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation();

      const result = await helper.image_url.call({}, options);
      
      expect(result).toBeInstanceOf(Handlebars.SafeString);
      expect(result.toString()).toBe('');
      expect(consoleWarnSpy).toHaveBeenCalledWith('[image_url] Invalid or missing ImageRef object provided.');
      expect(mockImageService.getDisplayUrl).not.toHaveBeenCalled();
      
      consoleWarnSpy.mockRestore();
    });

    test('handles missing src parameter', async () => {
      const siteData = createMockSiteData();
      const helper = imageUrlHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        width: 300
      });

      const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation();

      const result = await helper.image_url.call({}, options);
      
      expect(result).toBeInstanceOf(Handlebars.SafeString);
      expect(result.toString()).toBe('');
      expect(consoleWarnSpy).toHaveBeenCalledWith('[image_url] Invalid or missing ImageRef object provided.');
      
      consoleWarnSpy.mockRestore();
    });

    test('handles null src parameter', async () => {
      const siteData = createMockSiteData();
      const helper = imageUrlHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: null,
        width: 300
      });

      const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation();

      const result = await helper.image_url.call({}, options);
      
      expect(result).toBeInstanceOf(Handlebars.SafeString);
      expect(result.toString()).toBe('');
      expect(consoleWarnSpy).toHaveBeenCalled();
      
      consoleWarnSpy.mockRestore();
    });

    test('handles object without serviceId', async () => {
      const siteData = createMockSiteData();
      const helper = imageUrlHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: { url: 'some-url' }, // Missing serviceId
        width: 300
      });

      const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation();

      const result = await helper.image_url.call({}, options);
      
      expect(result).toBeInstanceOf(Handlebars.SafeString);
      expect(result.toString()).toBe('');
      expect(consoleWarnSpy).toHaveBeenCalled();
      
      consoleWarnSpy.mockRestore();
    });

    test('handles image service errors gracefully', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageUrlHelper(siteData);
      
      const error = new Error('Image processing failed');
      mockImageService.getDisplayUrl.mockRejectedValue(error);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300
      });

      const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();

      const result = await helper.image_url.call({}, options);
      
      expect(result).toBeInstanceOf(Handlebars.SafeString);
      expect(result.toString()).toBe('');
      expect(consoleErrorSpy).toHaveBeenCalledWith(
        '[image_url] Failed to generate URL for src: assets/images/test.jpg',
        error
      );
      
      consoleErrorSpy.mockRestore();
    });

    test('returns URL without transform options when none provided', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageUrlHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef
      });

      const result = await helper.image_url.call({}, options);
      
      expect(result.toString()).toBe('https://example.com/test.jpg');
      expect(mockImageService.getDisplayUrl).toHaveBeenCalledWith(
        siteData.manifest,
        imageRef,
        {}, // Empty transform options
        false
      );
    });

    test('handles partial transform options', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageUrlHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 400,
        crop: 'fit'
        // height and gravity intentionally omitted
      });

      await helper.image_url.call({}, options);
      
      expect(mockImageService.getDisplayUrl).toHaveBeenCalledWith(
        siteData.manifest,
        imageRef,
        {
          width: 400,
          crop: 'fit'
          // height and gravity should be undefined
        },
        false
      );
    });

    test('handles different image service types', async () => {
      const siteData = createMockSiteData();
      siteData.manifest.settings = { imageService: 'cloudinary' };
      
      const cloudinaryService = {
        id: 'cloudinary',
        name: 'Cloudinary Service',
        upload: jest.fn(),
        getDisplayUrl: jest.fn().mockResolvedValue('https://cloudinary.com/test.jpg'),
        getExportableAssets: jest.fn()
      };
      
      mockGetActiveImageService.mockReturnValue(cloudinaryService);
      
      const imageRef = createMockImageRef();
      const helper = imageUrlHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300
      });

      const result = await helper.image_url.call({}, options);
      
      expect(result.toString()).toBe('https://cloudinary.com/test.jpg');
      expect(cloudinaryService.getDisplayUrl).toHaveBeenCalled();
    });

    test('handles complex URLs with special characters', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageUrlHelper(siteData);
      
      const complexUrl = 'https://example.com/images/test%20image.jpg?v=123&format=webp';
      mockImageService.getDisplayUrl.mockResolvedValue(complexUrl);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300
      });

      const result = await helper.image_url.call({}, options);
      
      expect(result).toBeInstanceOf(Handlebars.SafeString);
      expect(result.toString()).toBe(complexUrl);
    });

    test('handles concurrent URL generation', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageUrlHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300
      });

      // Process multiple URLs concurrently
      const promises = Array.from({ length: 5 }, () => 
        helper.image_url.call({}, options)
      );

      const results = await Promise.all(promises);
      
      expect(results).toHaveLength(5);
      results.forEach(result => {
        expect(result).toBeInstanceOf(Handlebars.SafeString);
        expect(result.toString()).toBe('https://example.com/test.jpg');
      });
      
      expect(mockImageService.getDisplayUrl).toHaveBeenCalledTimes(5);
    });

    test('handles all supported transform options', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageUrlHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 800,
        height: 600,
        crop: 'scale',
        gravity: 'south'
      });

      await helper.image_url.call({}, options);
      
      expect(mockImageService.getDisplayUrl).toHaveBeenCalledWith(
        siteData.manifest,
        imageRef,
        {
          width: 800,
          height: 600,
          crop: 'scale',
          gravity: 'south'
        },
        false
      );
    });

    test('ignores non-transform hash parameters', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageUrlHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300,
        alt: 'Should be ignored',
        class: 'Should also be ignored',
        lazy: true,
        unknownParam: 'Also ignored'
      });

      await helper.image_url.call({}, options);
      
      expect(mockImageService.getDisplayUrl).toHaveBeenCalledWith(
        siteData.manifest,
        imageRef,
        {
          width: 300
          // Only width should be passed, other params ignored
        },
        false
      );
    });

    test('returns empty string for various error conditions', async () => {
      const siteData = createMockSiteData();
      const helper = imageUrlHelper(siteData);
      
      const testCases = [
        { src: undefined },
        { src: null },
        { src: '' },
        { src: 123 },
        { src: [] },
        { src: {} },
        { src: { notServiceId: 'test' } }
      ];

      const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation();

      for (const testCase of testCases) {
        const options = createMockHandlebarsOptions(testCase);
        const result = await helper.image_url.call({}, options);
        
        expect(result).toBeInstanceOf(Handlebars.SafeString);
        expect(result.toString()).toBe('');
      }
      
      consoleWarnSpy.mockRestore();
    });
  });

  describe('Helper Factory', () => {
    test('returns object with image_url helper function', () => {
      const siteData = createMockSiteData();
      const helpers = imageUrlHelper(siteData);
      
      expect(helpers).toHaveProperty('image_url');
      expect(typeof helpers.image_url).toBe('function');
    });

    test('helper function is async', () => {
      const siteData = createMockSiteData();
      const helpers = imageUrlHelper(siteData);
      const imageRef = createMockImageRef();
      
      const options = createMockHandlebarsOptions({
        src: imageRef
      });

      const result = helpers.image_url.call({}, options);
      expect(result).toBeInstanceOf(Promise);
    });

    test('different site data creates independent helpers', () => {
      const siteData1 = createMockSiteData();
      const siteData2 = { ...createMockSiteData(), siteId: 'different-site' };
      
      const helpers1 = imageUrlHelper(siteData1);
      const helpers2 = imageUrlHelper(siteData2);
      
      expect(helpers1).not.toBe(helpers2);
      expect(helpers1.image_url).not.toBe(helpers2.image_url);
    });

    test('maintains site data context correctly', async () => {
      const siteData = createMockSiteData();
      const imageRef = createMockImageRef();
      const helper = imageUrlHelper(siteData);
      
      const options = createMockHandlebarsOptions({
        src: imageRef,
        width: 300
      });

      await helper.image_url.call({}, options);
      
      expect(mockGetActiveImageService).toHaveBeenCalledWith(siteData.manifest);
      expect(mockImageService.getDisplayUrl).toHaveBeenCalledWith(
        siteData.manifest,
        imageRef,
        { width: 300 },
        false
      );
    });
  });
});

================================================================================

File: core/services/renderer/helpers/__tests__/themeData.helper.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import { themeDataHelper, rawThemeDataHelper } from '../themeData.helper';
import type { LocalSiteData } from '@/core/types';
import { HtmlSanitizerService } from '../../../htmlSanitizer.service';

// Mock the HTML sanitizer service
jest.mock('../../../htmlSanitizer.service', () => ({
  HtmlSanitizerService: {
    sanitize: jest.fn((html: string) => `sanitized:${html}`)
  }
}));

describe('themeData helpers', () => {
  const mockSiteData: LocalSiteData = {
    siteId: 'test-site',
    manifest: {
      title: 'Test Site',
      description: 'Test description',
      structure: [],
      theme: {
        name: 'default',
        config: {},
        themeData: {
          footer_text: '<p>Copyright &copy; 2024 Test Site</p>',
          header_announcement: '<div class="alert">Important announcement!</div>',
          plain_text: 'Simple text content',
          number_value: 42,
          boolean_value: true,
          null_value: null,
          undefined_value: undefined
        }
      }
    }
  };

  const mockSiteDataNoThemeData: LocalSiteData = {
    siteId: 'test-site-no-data',
    manifest: {
      title: 'Test Site',
      description: 'Test description',
      structure: [],
      theme: {
        name: 'default',
        config: {}
      }
    }
  };

  describe('themeData helper', () => {
    let helper: any;

    beforeEach(() => {
      jest.clearAllMocks();
      const helperMap = themeDataHelper(mockSiteData);
      helper = helperMap.themeData;
    });

    test('returns sanitized HTML content for existing field', () => {
      const result = helper.call({}, 'footer_text');
      
      expect(HtmlSanitizerService.sanitize).toHaveBeenCalledWith('<p>Copyright &copy; 2024 Test Site</p>');
      expect(result).toBe('sanitized:<p>Copyright &copy; 2024 Test Site</p>');
    });

    test('returns sanitized HTML content for another field', () => {
      const result = helper.call({}, 'header_announcement');
      
      expect(HtmlSanitizerService.sanitize).toHaveBeenCalledWith('<div class="alert">Important announcement!</div>');
      expect(result).toBe('sanitized:<div class="alert">Important announcement!</div>');
    });

    test('returns string representation of non-string values without sanitization', () => {
      const numberResult = helper.call({}, 'number_value');
      const booleanResult = helper.call({}, 'boolean_value');
      
      expect(numberResult).toBe('42');
      expect(booleanResult).toBe('true');
      expect(HtmlSanitizerService.sanitize).not.toHaveBeenCalledWith(42);
      expect(HtmlSanitizerService.sanitize).not.toHaveBeenCalledWith(true);
    });

    test('returns empty string for null values', () => {
      const result = helper.call({}, 'null_value');
      expect(result).toBe('');
    });

    test('returns empty string for undefined values', () => {
      const result = helper.call({}, 'undefined_value');
      expect(result).toBe('');
    });

    test('returns empty string for non-existent field', () => {
      const result = helper.call({}, 'non_existent_field');
      expect(result).toBe('');
    });

    test('returns empty string when no theme data exists', () => {
      const helperMapNoData = themeDataHelper(mockSiteDataNoThemeData);
      const helperNoData = helperMapNoData.themeData;
      
      const result = helperNoData.call({}, 'footer_text');
      expect(result).toBe('');
    });

    test('returns empty string when theme data is not an object', () => {
      const siteDataInvalidThemeData: LocalSiteData = {
        ...mockSiteData,
        manifest: {
          ...mockSiteData.manifest,
          theme: {
            ...mockSiteData.manifest.theme,
            themeData: 'invalid-data' as any
          }
        }
      };

      const helperMapInvalid = themeDataHelper(siteDataInvalidThemeData);
      const helperInvalid = helperMapInvalid.themeData;
      
      const result = helperInvalid.call({}, 'footer_text');
      expect(result).toBe('');
    });
  });

  describe('rawThemeData helper', () => {
    let helper: any;

    beforeEach(() => {
      jest.clearAllMocks();
      const helperMap = rawThemeDataHelper(mockSiteData);
      helper = helperMap.rawThemeData;
    });

    test('returns raw HTML content without sanitization', () => {
      const result = helper.call({}, 'footer_text');
      
      expect(HtmlSanitizerService.sanitize).not.toHaveBeenCalled();
      expect(result).toBe('<p>Copyright &copy; 2024 Test Site</p>');
    });

    test('returns raw content for another field', () => {
      const result = helper.call({}, 'header_announcement');
      
      expect(result).toBe('<div class="alert">Important announcement!</div>');
      expect(HtmlSanitizerService.sanitize).not.toHaveBeenCalled();
    });

    test('returns string representation of non-string values', () => {
      const numberResult = helper.call({}, 'number_value');
      const booleanResult = helper.call({}, 'boolean_value');
      
      expect(numberResult).toBe('42');
      expect(booleanResult).toBe('true');
    });

    test('returns empty string for null values', () => {
      const result = helper.call({}, 'null_value');
      expect(result).toBe('');
    });

    test('returns empty string for undefined values', () => {
      const result = helper.call({}, 'undefined_value');
      expect(result).toBe('');
    });

    test('returns empty string for non-existent field', () => {
      const result = helper.call({}, 'non_existent_field');
      expect(result).toBe('');
    });

    test('returns empty string when no theme data exists', () => {
      const helperMapNoData = rawThemeDataHelper(mockSiteDataNoThemeData);
      const helperNoData = helperMapNoData.rawThemeData;
      
      const result = helperNoData.call({}, 'footer_text');
      expect(result).toBe('');
    });
  });

  describe('helper function signatures', () => {
    test('themeData helper accepts variable arguments', () => {
      const helperMap = themeDataHelper(mockSiteData);
      const helper = helperMap.themeData;
      
      // Should work with multiple arguments (Handlebars can pass extra args)
      const result = helper.call({}, 'footer_text', 'extra_arg', { option: 'value' });
      expect(result).toBe('sanitized:<p>Copyright &copy; 2024 Test Site</p>');
    });

    test('rawThemeData helper accepts variable arguments', () => {
      const helperMap = rawThemeDataHelper(mockSiteData);
      const helper = helperMap.rawThemeData;
      
      // Should work with multiple arguments (Handlebars can pass extra args)
      const result = helper.call({}, 'footer_text', 'extra_arg', { option: 'value' });
      expect(result).toBe('<p>Copyright &copy; 2024 Test Site</p>');
    });
  });

  describe('edge cases', () => {
    test('handles empty string field name', () => {
      const helperMap = themeDataHelper(mockSiteData);
      const helper = helperMap.themeData;
      
      const result = helper.call({}, '');
      expect(result).toBe('');
    });

    test('handles numeric field name', () => {
      const siteDataWithNumericKey: LocalSiteData = {
        ...mockSiteData,
        manifest: {
          ...mockSiteData.manifest,
          theme: {
            ...mockSiteData.manifest.theme,
            themeData: {
              '123': 'numeric key value'
            }
          }
        }
      };

      const helperMap = themeDataHelper(siteDataWithNumericKey);
      const helper = helperMap.themeData;
      
      const result = helper.call({}, '123');
      expect(result).toBe('sanitized:numeric key value');
    });

    test('handles object values', () => {
      const siteDataWithObject: LocalSiteData = {
        ...mockSiteData,
        manifest: {
          ...mockSiteData.manifest,
          theme: {
            ...mockSiteData.manifest.theme,
            themeData: {
              complex_data: { nested: 'value', count: 5 }
            }
          }
        }
      };

      const helperMap = themeDataHelper(siteDataWithObject);
      const helper = helperMap.themeData;
      
      const result = helper.call({}, 'complex_data');
      expect(result).toBe('[object Object]');
    });
  });
});

================================================================================

File: core/services/config/theme.service.ts
// core/services/theme.service.ts

import type { RJSFSchema } from '@rjsf/utils';
import type { ThemeConfig } from '@/core/types';

// Extract default values from JSON schema
const extractDefaultsFromSchema = (schema: RJSFSchema): Record<string, unknown> => {
  const defaults: Record<string, unknown> = {};
  
  if (schema.properties) {
    Object.entries(schema.properties).forEach(([key, property]) => {
      if (typeof property === 'object' && property !== null && 'default' in property) {
        defaults[key] = property.default;
      }
    });
  }
  
  return defaults;
};

// Smart field-by-field config merging
const getMergedThemeConfig = (
  themeSchema: RJSFSchema,
  savedConfig: ThemeConfig['config'],
  isThemeChange: boolean = false
): ThemeConfig['config'] => {
  const defaults = extractDefaultsFromSchema(themeSchema) as ThemeConfig['config'];
  
  if (!isThemeChange) {
    // Same theme: Use saved values, fall back to defaults for missing fields
    return { ...defaults, ...savedConfig };
  }
  
  // Theme change: Field-by-field merge to preserve matching user preferences
  const merged = { ...defaults };
  
  // For each saved setting, check if it exists in the new theme
  Object.entries(savedConfig).forEach(([key, value]) => {
    const fieldExists = themeSchema.properties?.[key];
    const hasValidType = typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
    
    if (fieldExists && hasValidType) {
      // Field exists in new theme and has valid type - preserve user's value
      merged[key] = value;
    }
    // If field doesn't exist or has invalid type, use default (already set above)
  });
  
  return merged;
};

// Smart theme data merging (similar to appearance config)
const getMergedThemeData = (
  themeDataSchema: RJSFSchema,
  savedThemeData: Record<string, unknown> = {},
  isThemeChange: boolean = false
): Record<string, unknown> => {
  const defaults = extractDefaultsFromSchema(themeDataSchema);
  
  if (!isThemeChange) {
    // Same theme: Use saved values, fall back to defaults for missing fields
    return { ...defaults, ...savedThemeData };
  }
  
  // Theme change: Field-by-field merge to preserve matching user preferences
  const merged = { ...defaults };
  
  // For each saved setting, check if it exists in the new theme
  Object.entries(savedThemeData).forEach(([key, value]) => {
    const fieldExists = themeDataSchema.properties?.[key];
    
    if (fieldExists) {
      // Field exists in new theme - preserve user's value
      merged[key] = value;
    }
    // If field doesn't exist, use default (already set above)
  });
  
  return merged;
};

// Updated main function with smart merging for appearance config
export const getMergedThemeDataForForm = async (
  themeName: string,
  savedConfig: ThemeConfig['config'] = {},
  currentThemeName?: string
): Promise<{ schema: RJSFSchema | null; initialConfig: ThemeConfig['config'] }> => {
  try {
    // Load the theme data (this function should already exist)
    const themeData = await getThemeData(themeName);
    const schema = themeData?.appearanceSchema;
    
    if (!schema || !schema.properties) {
      return { schema: null, initialConfig: {} };
    }
    
    // Determine if this is a theme change
    const isThemeChange = Boolean(currentThemeName && currentThemeName !== themeName);
    
    // Use smart merging logic
    const mergedConfig = getMergedThemeConfig(schema, savedConfig, isThemeChange);
    
    return {
      schema,
      initialConfig: mergedConfig
    };
    
  } catch (error) {
    console.error('Error loading theme data:', error);
    return { schema: null, initialConfig: {} };
  }
};

// New function for theme data schema and merging
export const getMergedThemeDataFieldsForForm = async (
  themeName: string,
  savedThemeData: Record<string, unknown> = {},
  currentThemeName?: string
): Promise<{ schema: RJSFSchema | null; initialData: Record<string, unknown> }> => {
  try {
    // Load the theme data
    const themeData = await getThemeData(themeName);
    const schema = themeData?.themeDataSchema;
    
    if (!schema || !schema.properties) {
      return { schema: null, initialData: {} };
    }
    
    // Determine if this is a theme change
    const isThemeChange = Boolean(currentThemeName && currentThemeName !== themeName);
    
    // Use smart merging logic
    const mergedData = getMergedThemeData(schema, savedThemeData, isThemeChange);
    
    return {
      schema,
      initialData: mergedData
    };
    
  } catch (error) {
    console.error('Error loading theme data schema:', error);
    return { schema: null, initialData: {} };
  }
};

// Helper function to get theme data using existing infrastructure
const getThemeData = async (themeName: string) => {
  // Use the existing infrastructure to load theme.json
  const response = await fetch(`/themes/${themeName}/theme.json`);
  if (!response.ok) {
    throw new Error(`Failed to load theme: ${themeName}`);
  }
  return response.json();
};

================================================================================

File: core/services/config/configHelpers.service.ts
// src/core/services/configHelpers.service.ts

import type { RJSFSchema, UiSchema } from '@rjsf/utils';
import { CORE_LAYOUTS, CORE_THEMES } from '@/config/editorConfig';
import type {
    LocalSiteData,
    Manifest,
    LayoutInfo,
    ThemeInfo,
    RawFile,
    DisplayOption,
    ImageTransformOptions
} from '@/core/types';

// ============================================================================
// TYPE DEFINITIONS FOR LAYOUT AND THEME MANIFESTS
// ============================================================================

/** A stricter version of UiSchema for internal use, allowing for custom grouping options. */
export type StrictUiSchema = UiSchema & { 'ui:groups'?: { title: string; fields: string[] }[] };

/** Defines the types of files that can be declared in an asset manifest. */
export type AssetFileType = 'manifest' | 'base' | 'template' | 'partial' | 'stylesheet' | 'script' | 'asset';

/** Represents a single file entry within an asset manifest's `files` array. */
export interface AssetFile {
  path: string;
  type: AssetFileType;
  /** A name used for registering partials (e.g., 'header', 'footer'). */
  name?: string;
}

/** The base properties shared by all asset manifests (layouts and themes). */
export interface BaseAssetManifest {
  name: string;
  version: string;
  description?: string;
  icon?: string;
  files: AssetFile[];
}

/** The structure of a theme.json file. */
export interface ThemeManifest extends BaseAssetManifest {
  /** A JSON schema defining theme-wide appearance options (colors, fonts). */
  appearanceSchema?: RJSFSchema;
  /** A JSON schema defining arbitrary theme data fields (footer text, etc.). */
  themeDataSchema?: RJSFSchema;
}
/**
 * Defines a single, named image transformation preset within a layout.
 */
interface ImagePreset extends ImageTransformOptions {
    /** The frontmatter field to use as the source for this image (e.g., "featured_image"). */
    source: string;
}

/**
 * Defines the structure of a single entry in a layout's `data_files` array.
 */
interface DataFileDefinition {
  id: string;
  path_template: string;
  schema: RJSFSchema;
  initial_content: unknown[];
}

/**
 * Defines the structure of a single entry in a layout's `dynamic_routes` map.
 */
interface DynamicRoute {
  data_source: { id: string; };
  path_template: string;
  layout: string;
  content_filter: {
    by_frontmatter_field: string;
    contains_value_from: string;
  };
}

/** 
 * The structure for a layout.json file. It defines a self-contained
 * layout bundle, including its data requirements and display options.
 */
export interface LayoutManifest extends BaseAssetManifest {
  id: string;
  /** The fundamental type of the layout: 'page' for single content, 'collection' for groups. */
  layoutType: 'page' | 'collection';
  /** For Collection Layouts, this defines the schema for each item in the collection. */
  itemSchema?: RJSFSchema;
  /** The corresponding UI Schema for the itemSchema. */
  itemUiSchema?: StrictUiSchema;
  /** A map of user-selectable display variants (e.g., list vs. grid view). */
  display_options?: Record<string, DisplayOption>;
  image_presets?: Record<string, ImagePreset>;
  data_files?: DataFileDefinition[];
  dynamic_routes?: Record<string, DynamicRoute>;
  /** For Page/Collection Layouts, this defines the schema for the page itself. */
   schema?: RJSFSchema;
  /** The corresponding UI Schema for the main schema. */
  uiSchema?: StrictUiSchema;
}

/** A minimal subset of site data needed by the asset helper functions. */
export type SiteDataForAssets = Pick<LocalSiteData, 'manifest' | 'layoutFiles' | 'themeFiles'>;

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/** An in-memory cache to prevent re-fetching public asset files during a session. */
const fileContentCache = new Map<string, Promise<string | null>>();

/**
 * Checks if a given theme path corresponds to a core (built-in) theme.
 * @param path The path/ID of the theme (e.g., 'default').
 */
export const isCoreTheme = (path: string) => CORE_THEMES.some((t: ThemeInfo) => t.path === path);

/**
 * Checks if a given layout path corresponds to a core (built-in) layout.
 * @param path The path/ID of the layout (e.g., 'page', 'blog').
 */
export const isCoreLayout = (path: string) => CORE_LAYOUTS.some((l: LayoutInfo) => l.id === path);

/**
 * A helper function to merge multiple JSON Schemas into one.
 * It combines properties and required fields from all provided schemas.
 */
export function mergeSchemas(...schemas: (RJSFSchema | null | undefined)[]): RJSFSchema {
    const finalSchema: RJSFSchema = { type: 'object', properties: {}, required: [] };
    for (const schema of schemas) {
        if (schema?.properties) {
            finalSchema.properties = { ...finalSchema.properties, ...schema.properties };
        }
        if (schema?.required) {
            finalSchema.required = [...new Set([...(finalSchema.required || []), ...schema.required])];
        }
    }
    return finalSchema;
}

/**
 * A helper function to merge multiple UI Schemas into one.
 */
export function mergeUiSchemas(...schemas: (UiSchema | null | undefined)[]): UiSchema {
    let finalUiSchema: UiSchema = {};
    for (const schema of schemas) {
        if (schema) {
            finalUiSchema = { ...finalUiSchema, ...schema };
        }
    }
    return finalUiSchema;
}


/**
 * Fetches the raw string content of a theme or layout asset.
 * It intelligently fetches from either the `/public` directory (for core assets)
 * or the `LocalSiteData` object (for user-provided custom assets), with caching.
 */
export async function getAssetContent(siteData: SiteDataForAssets, assetType: 'theme' | 'layout', path: string, fileName: string): Promise<string | null> {
    const isCore = assetType === 'theme' ? isCoreTheme(path) : isCoreLayout(path);
    const sourcePath = `/${assetType}s/${path}/${fileName}`;

    if (isCore) {
      if (fileContentCache.has(sourcePath)) {
        return fileContentCache.get(sourcePath)!;
      }
      const promise = fetch(sourcePath)
        .then(res => res.ok ? res.text() : null)
        .catch(() => null);
      fileContentCache.set(sourcePath, promise);
      return promise;
    } else {
      // Logic for custom, user-uploaded layouts/themes would go here.
      // For now, it reads from the in-memory store.
      const fileStore: RawFile[] | undefined =
          assetType === 'theme' ? siteData.themeFiles
          : assetType === 'layout' ? siteData.layoutFiles
          : undefined;

      const fullPath = `${assetType}s/${path}/${fileName}`;
      return fileStore?.find(f => f.path === fullPath)?.content ?? null;
    }
}

/**
 * A generic function to fetch and parse any JSON asset manifest (theme.json, layout.json).
 */
export async function getJsonAsset<T>(siteData: SiteDataForAssets, assetType: 'theme' | 'layout', path: string, fileName: string): Promise<T | null> {
    const content = await getAssetContent(siteData, assetType, path, fileName);
    if (!content) return null;
    try {
      return JSON.parse(content) as T;
    } catch (e) {
      console.error(`Failed to parse JSON from ${assetType}/${path}/${fileName}:`, e);
      return null;
    }
}

// ============================================================================
// PUBLIC API
// ============================================================================

/**
 * Gets a list of all available themes (core and custom).
 */
/**
 * Gets a list of all available themes (core and custom) for a site.
 * This is used to populate the theme selection dropdown in the site settings.
 * It ensures that custom themes from the site's manifest are included and
 * that there are no duplicates if a custom theme shares an ID with a core theme.
 * @param {Manifest | undefined} manifest The site's manifest, which may contain a list of custom themes.
 * @returns {ThemeInfo[]} A de-duplicated array of all available themes.
 */
export function getAvailableThemes(manifest?: Manifest): ThemeInfo[] {
  // Start with a fresh copy of the core, built-in themes.
  const available = [...CORE_THEMES];
  
  // If a manifest is provided and it contains custom theme definitions...
  if (manifest?.themes) {
    // Filter the custom themes to only include those that don't already exist in the core list.
    // This prevents duplicates and ensures core themes can't be accidentally overridden by name.
    const customThemes = manifest.themes.filter(customTheme => 
      !available.some(coreTheme => coreTheme.path === customTheme.path)
    );
    // Add the unique custom themes to the list.
    available.push(...customThemes);
  }
  
  return available;
}

/**
 * Fetches and processes the manifest for a specific layout.
 * This is a simple fetch-and-parse operation now, as schema merging is handled
 * by the component that needs it (e.g., FrontmatterSidebar).
 *
 * @param siteData The site's data.
 * @param layoutPath The ID of the layout to fetch (e.g., 'blog').
 * @returns The parsed LayoutManifest object, or null if not found.
 */
export async function getLayoutManifest(siteData: SiteDataForAssets, layoutPath: string): Promise<LayoutManifest | null> {
    const manifest = await getJsonAsset<LayoutManifest>(siteData, 'layout', layoutPath, 'layout.json');
    if (manifest) {
        // Set the id field from the layoutPath since it's not included in the JSON files
        manifest.id = layoutPath;
    }
    return manifest;
}

/**
 * Gets a list of the full manifest objects for all available layouts,
 * optionally filtered by a specific layout type ('page' or 'collection').
 * This is used to populate UI dropdowns for layout selection.
 */
export async function getAvailableLayouts(
  siteData: SiteDataForAssets,
  type?: LayoutManifest['layoutType']
): Promise<LayoutManifest[]> {
  const coreLayoutIds = CORE_LAYOUTS.map(l => l.id);
  const customLayoutIds = siteData.manifest.layouts?.map(l => l.id) || [];
  const allLayoutIds = [...new Set([...coreLayoutIds, ...customLayoutIds])];

  const manifestPromises = allLayoutIds.map(layoutId =>
    getLayoutManifest(siteData, layoutId)
  );

  const allManifests = (await Promise.all(manifestPromises))
    .filter((m): m is LayoutManifest => m !== null);

  if (type) {
    return allManifests.filter(m => m.layoutType === type);
  }

  return allManifests;
}

================================================================================

File: core/services/images/images.service.ts
// src/core/services/images/images.service.ts

import type { ImageService, Manifest } from '@/core/types';
import { localImageService } from './localImage.service';
import { cloudinaryImageService } from './cloudinaryImage.service';

const services: Record<string, ImageService> = {
  local: localImageService,
  cloudinary: cloudinaryImageService,
};

export function getActiveImageService(manifest: Manifest): ImageService {
  const serviceId = manifest.settings?.imageService || 'local';
  return services[serviceId] || localImageService;
}

================================================================================

File: core/services/images/types.ts
// src/core/services/theme-engine/helpers/types.ts
import type { LocalSiteData } from '@/core/types';
import Handlebars from 'handlebars';

/**
 * Defines the function signature for a Handlebars helper function within Sparktype.
 * `this` refers to the current template context.
 * `args` are the arguments passed to the helper in the template.
 */
export type SparktypeHelperFunction = (
  this: unknown,
  ...args: unknown[]
) => string | Handlebars.SafeString | boolean | Promise<Handlebars.SafeString>;

/**
 * Defines a "Helper Factory". It's a function that receives the full site data
 * and returns an object mapping helper names to their implementation functions.
 */
export type SparktypeHelper = (siteData: LocalSiteData) => Record<string, SparktypeHelperFunction>;

================================================================================

File: core/services/images/localImage.service.ts
// src/core/services/images/localImage.service.ts

import type { ImageService, ImageRef, ImageTransformOptions, Manifest } from '@/core/types';
import * as localSiteFs from '@/core/services/localFileSystem.service';
import { slugify } from '@/core/libraries/utils';
import { getCachedDerivative, setCachedDerivative, getAllCacheKeys } from './derivativeCache.service';
import imageCompression from 'browser-image-compression';
import { MEMORY_CONFIG } from '@/config/editorConfig';
import { toast } from 'sonner';

/**
 * This service manages images stored locally within the browser's IndexedDB.
 * It handles uploading, generating transformed "derivatives" (e.g., thumbnails),
 * caching those derivatives for performance, and bundling all necessary assets for a static site export.
 * It acts as the "backend" for the local storage image strategy.
 */

// In-memory caches to reduce redundant processing and DB reads within a session.
const sourceImageCache = new Map<string, Blob>();
const processingPromises = new Map<string, Promise<Blob>>();

// --- FIX: Add a new Map to handle concurrent requests for the SAME source blob. ---
const sourceBlobPromises = new Map<string, Promise<Blob>>();

/**
 * A strongly-typed interface for the options passed to the browser-image-compression library.
 * This improves type safety and code clarity.
 */
interface CompressionOptions {
  maxSizeMB: number;
  initialQuality: number;
  useWebWorker: boolean;
  exifOrientation: number;
  maxWidthOrHeight?: number;
  maxWidth?: number;
  maxHeight?: number;
}

/**
 * A utility function to get the dimensions of an image from its Blob data.
 * @param blob The image Blob.
 * @returns A promise that resolves to the image's width and height.
 */
const getImageDimensions = (blob: Blob): Promise<{ width: number; height: number }> => {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = () => {
      resolve({ width: img.width, height: img.height });
      URL.revokeObjectURL(url);
    };
    img.onerror = (err) => {
      reject(err);
      URL.revokeObjectURL(url);
    };
    img.src = url;
  });
};

/**
 * Implements the ImageService interface for handling images stored locally
 * within the site's data in the browser (IndexedDB).
 */
class LocalImageService implements ImageService {
  id = 'local';
  name = 'Store in Site Bundle';

  /**
   * Validates and uploads a user-provided image file.
   * This is the primary entry point for adding a new local image asset. It performs
   * validation against `MEMORY_CONFIG` before saving the file to IndexedDB.
   * @param {File} file The user's selected file.
   * @param {string} siteId The ID of the site the image belongs to.
   * @returns {Promise<ImageRef>} A promise that resolves to an ImageRef object representing the saved file.
   * @throws {Error} If the file type is unsupported or the file size exceeds the configured limits.
   */
  public async upload(file: File, siteId: string): Promise<ImageRef> {
    // --- Validation Block ---
    const isSvg = file.type === 'image/svg+xml';

    // 1. Check if the MIME type is supported.
    if (!MEMORY_CONFIG.SUPPORTED_IMAGE_TYPES.includes(file.type as typeof MEMORY_CONFIG.SUPPORTED_IMAGE_TYPES[number])) {
      const errorMsg = `Unsupported file type: ${file.type}.`;
      toast.error(errorMsg);
      throw new Error(errorMsg);
    }

    // 2. Check if the file exceeds its specific size limit.
    const maxSize = isSvg ? MEMORY_CONFIG.MAX_SVG_SIZE : MEMORY_CONFIG.MAX_UPLOAD_SIZE;
    if (file.size > maxSize) {
        const maxSizeFormatted = (maxSize / 1024 / (isSvg ? 1 : 1024)).toFixed(1);
        const unit = isSvg ? 'KB' : 'MB';
        const errorMsg = `Image is too large. Max size is ${maxSizeFormatted}${unit}.`;
        toast.error(errorMsg);
        throw new Error(errorMsg);
    }
    // --- End Validation Block ---

    const extIndex = file.name.lastIndexOf('.');
    if (extIndex === -1) {
      throw new Error("Uploaded file is missing an extension.");
    }
    const baseName = file.name.substring(0, extIndex);
    const extension = file.name.substring(extIndex);
    const slugifiedBaseName = slugify(baseName);
    const fileName = `${Date.now()}-${slugifiedBaseName}${extension}`;
    const relativePath = `assets/images/${fileName}`;

    await localSiteFs.saveImageAsset(siteId, relativePath, file as Blob);

    let width: number, height: number;
    try {
      const dimensions = await getImageDimensions(file as Blob);
      width = dimensions.width;
      height = dimensions.height;
    } catch (error) {
      console.error('Failed to get image dimensions, using defaults:', error);
      width = 0;
      height = 0;
    }

    return {
      serviceId: 'local',
      src: relativePath,
      alt: file.name,
      width,
      height,
    };
  }

  /**
   * Generates a URL for an image, potentially creating a transformed derivative.
   * It handles SVGs, cached derivatives, and new processing requests.
   * @param {Manifest} manifest The site's manifest.
   * @param {ImageRef} ref The reference to the source image.
   * @param {ImageTransformOptions} options The requested transformations (width, height, etc.).
   * @param {boolean} isExport If true, returns a relative path for static export. If false, returns a temporary `blob:` URL for live preview.
   * @returns {Promise<string>} A promise that resolves to the displayable URL or relative path.
   */
  public async getDisplayUrl(manifest: Manifest, ref: ImageRef, options: ImageTransformOptions, isExport: boolean): Promise<string> {
    // SVGs are returned directly without processing.
    if (ref.src.toLowerCase().endsWith('.svg')) {
      if (isExport) return ref.src;
      const sourceBlob = await this.getSourceBlob(manifest.siteId, ref.src);
      return URL.createObjectURL(sourceBlob);
    }

    // Construct a unique filename and cache key for the requested derivative.
    const { width, height, crop = 'scale', gravity = 'center' } = options;
    const extIndex = ref.src.lastIndexOf('.');
    if (extIndex === -1) throw new Error("Source image has no extension.");
    
    const pathWithoutExt = ref.src.substring(0, extIndex);
    const ext = ref.src.substring(extIndex);
    const derivativeFileName = `${pathWithoutExt}_w${width || 'auto'}_h${height || 'auto'}_c-${crop}_g-${gravity}${ext}`;
    const cacheKey = `${manifest.siteId}/${derivativeFileName}`;

    const finalBlob = await this.getOrProcessDerivative(manifest.siteId, ref.src, cacheKey, options);
    
    return isExport ? derivativeFileName : URL.createObjectURL(finalBlob);
  }

  /**
   * Retrieves a derivative blob, either from the cache or by initiating a new processing job.
   * This method uses an in-memory map of promises to prevent race conditions where the same
   * derivative is requested multiple times before the first job completes.
   * @private
   * @param {string} siteId The site's ID.
   * @param {string} srcPath The path to the original source image.
   * @param {string} cacheKey The unique, namespaced key for the derivative.
   * @param {ImageTransformOptions} options The transformation options.
   * @returns {Promise<Blob>} A promise that resolves to the final derivative blob.
   */
  private async getOrProcessDerivative(siteId: string, srcPath: string, cacheKey: string, options: ImageTransformOptions): Promise<Blob> {
    // 1. Check persistent cache (IndexedDB) first.
    const cachedBlob = await getCachedDerivative(cacheKey);
    if (cachedBlob) return cachedBlob;

    // 2. Check if this exact derivative is already being processed.
    if (processingPromises.has(cacheKey)) return processingPromises.get(cacheKey)!;
    
    // 3. If not, create and store a new processing promise.
    const processingPromise = (async (): Promise<Blob> => {
      try {
        const sourceBlob = await this.getSourceBlob(siteId, srcPath);
        const sourceDimensions = await getImageDimensions(sourceBlob);

        const compressionOptions: CompressionOptions = {
            maxSizeMB: 1.5,
            initialQuality: 0.85,
            useWebWorker: true,
            exifOrientation: -1,
        };

        // Prevent upscaling by capping requested dimensions at the source's dimensions.
        const { width, height, crop } = options;
        const targetWidth = width ? Math.min(width, sourceDimensions.width) : undefined;
        const targetHeight = height ? Math.min(height, sourceDimensions.height) : undefined;

        if (crop === 'fill' && targetWidth && targetHeight) {
          compressionOptions.maxWidth = targetWidth;
          compressionOptions.maxHeight = targetHeight;
        } else {
          const maxDim = Math.max(targetWidth || 0, targetHeight || 0);
          if (maxDim > 0) compressionOptions.maxWidthOrHeight = maxDim;
        }

        console.log(`[ImageService] Processing new derivative: ${cacheKey}`);
        
        // Add timeout wrapper for imageCompression to prevent hanging
        const compressionPromise = imageCompression(sourceBlob as File, compressionOptions);
        const timeoutPromise = new Promise<never>((_, reject) => {
          setTimeout(() => reject(new Error('Image compression timed out after 30 seconds')), 30000);
        });
        
        const derivativeBlob = await Promise.race([compressionPromise, timeoutPromise]);
        
        // 4. Store the result in the persistent cache.
        await setCachedDerivative(cacheKey, derivativeBlob);
        return derivativeBlob;
      } catch (error) {
        console.error(`[ImageService] Failed to process derivative ${cacheKey}:`, error);
        throw error;
      } finally {
        // 5. Clean up the promise map once the job is complete.
        processingPromises.delete(cacheKey);
      }
    })();

    processingPromises.set(cacheKey, processingPromise);
    return processingPromise;
  }

  /**
   * --- FIX: This function is now concurrency-safe. ---
   * Retrieves the original source image blob, using an in-memory cache and a promise map
   * to avoid repeated reads from IndexedDB during concurrent requests.
   * @private
   * @param {string} siteId The site's ID.
   * @param {string} srcPath The path of the source image to retrieve.
   * @returns {Promise<Blob>} A promise that resolves to the source image blob.
   */
  private async getSourceBlob(siteId: string, srcPath: string): Promise<Blob> {
    // 1. Check in-memory cache for an already resolved blob.
    if (sourceImageCache.has(srcPath)) {
      return sourceImageCache.get(srcPath)!;
    }

    // 2. Check if a fetch for this blob is already in progress.
    if (sourceBlobPromises.has(srcPath)) {
      return sourceBlobPromises.get(srcPath)!;
    }

    // 3. If not, create a new promise to fetch the blob.
    const promise = (async () => {
      try {
        const blobData = await localSiteFs.getImageAsset(siteId, srcPath);
        if (!blobData) {
          throw new Error(`Source image not found in local storage: ${srcPath}`);
        }
        // Cache the resolved blob in memory for subsequent synchronous access.
        sourceImageCache.set(srcPath, blobData);
        return blobData;
      } finally {
        // 4. Clean up the promise from the map once it has settled.
        sourceBlobPromises.delete(srcPath);
      }
    })();

    // 5. Store the promise in the map *before* awaiting it. This is the key to handling the race.
    sourceBlobPromises.set(srcPath, promise);

    return promise;
  }

  /**
   * Gathers all assets (source images and cached derivatives) needed for a full site export.
   * @param {string} siteId The ID of the site to export.
   * @param {ImageRef[]} allImageRefs An array of all image references found in the site's content and manifest.
   * @returns {Promise<{ path: string; data: Blob; }[]>} A promise resolving to an array of assets to be zipped.
   */
  public async getExportableAssets(siteId: string, allImageRefs: ImageRef[]): Promise<{ path: string; data: Blob; }[]> {
    const exportableMap = new Map<string, Blob>();
    
    // 1. Add all original source images for this site to the export map.
    for (const ref of allImageRefs) {
      if (ref.serviceId === 'local' && !exportableMap.has(ref.src)) {
        const sourceBlob = await localSiteFs.getImageAsset(siteId, ref.src);
        if (sourceBlob) {
          exportableMap.set(ref.src, sourceBlob);
        }
      }
    }
    
    // 2. Add all of this site's existing derivatives from the cache to the export map.
    const derivativeKeys = await getAllCacheKeys(siteId);
    for (const key of derivativeKeys) {
      const filename = key.substring(siteId.length + 1);
      if (!exportableMap.has(filename)) {
        const derivativeBlob = await getCachedDerivative(key);
        if (derivativeBlob) {
          exportableMap.set(filename, derivativeBlob);
        }
      }
    }
    
    return Array.from(exportableMap.entries()).map(([path, data]) => ({ path, data }));
  }
}

// Export a singleton instance of the service.
export const localImageService = new LocalImageService();

================================================================================

File: core/services/images/derivativeCache.service.ts
// src/core/services/images/derivativeCache.service.ts
import localforage from 'localforage';

/**
 * Manages the storage and retrieval of generated image "derivatives" (e.g., thumbnails, resized images).
 * This service acts as a persistent cache in the browser's IndexedDB to avoid re-processing
 * images unnecessarily between sessions, which significantly improves performance.
 *
 */

// A single, global IndexedDB store is used for all derivatives.
// Scoping is handled by prefixing keys with the site's ID.
const derivativeCacheStore = localforage.createInstance({
  name: 'SparktypeDB',
  storeName: 'derivativeCacheStore',
});

/**
 * Retrieves a cached image derivative from IndexedDB by its full, namespaced key.
 * @param key The unique key for the derivative, including the `siteId` prefix (e.g., "site-abc/assets/images/foo_w100.jpg").
 * @returns A promise that resolves to the derivative Blob, or null if not found.
 */
export async function getCachedDerivative(key: string): Promise<Blob | null> {
  return derivativeCacheStore.getItem<Blob>(key);
}

/**
 * Stores an image derivative Blob in IndexedDB using its full, namespaced key.
 * @param key The unique key for the derivative, including the `siteId` prefix.
 * @param blob The derivative image data as a Blob to be cached.
 */
export async function setCachedDerivative(key: string, blob: Blob): Promise<void> {
  await derivativeCacheStore.setItem(key, blob);
}

/**
 * Retrieves all cache keys that belong to a specific site.
 * This is crucial for the site exporter to find and bundle all generated images for a single site.
 * @param siteId The ID of the site whose cache keys are needed.
 * @returns A promise that resolves to an array of all keys (strings) for the specified site.
 */
export async function getAllCacheKeys(siteId: string): Promise<string[]> {
  // 1. Get all keys from the store.
  const allKeys = await derivativeCacheStore.keys();
  
  // 2. Filter the keys to return only those that start with the required "siteId/" prefix.
  const sitePrefix = `${siteId}/`;
  return allKeys.filter(key => key.startsWith(sitePrefix));
}

/**
 * Removes all cached derivatives for a specific site.
 * This should be called when deleting a site to prevent cache pollution.
 * @param siteId The ID of the site whose cache should be cleared.
 */
export async function clearSiteDerivativeCache(siteId: string): Promise<void> {
  try {
    const siteKeys = await getAllCacheKeys(siteId);
    await Promise.all(siteKeys.map(key => derivativeCacheStore.removeItem(key)));
    console.log(`[DerivativeCache] Cleared ${siteKeys.length} cached derivatives for site ${siteId}`);
  } catch (error) {
    console.error(`[DerivativeCache] Failed to clear cache for site ${siteId}:`, error);
  }
}

/**
 * Clears the entire derivative cache. Used for IndexedDB recovery.
 */
export async function clearAllDerivativeCache(): Promise<void> {
  try {
    await derivativeCacheStore.clear();
    console.log('[DerivativeCache] Cleared entire cache for recovery');
  } catch (error) {
    console.error('[DerivativeCache] Failed to clear entire cache:', error);
  }
}

================================================================================

File: core/services/images/imageCache.service.ts
// src/core/services/images/derivativeCache.service.ts
import localforage from 'localforage';

const derivativeCacheStore = localforage.createInstance({
  name: 'SparktypeDB',
  storeName: 'derivativeCacheStore',
});

/**
 * Retrieves a cached image derivative from IndexedDB by its key.
 * @param key The unique key for the derivative.
 * @returns A promise that resolves to the derivative Blob, or null if not found.
 */
export async function getCachedDerivative(key: string): Promise<Blob | null> {
  return derivativeCacheStore.getItem<Blob>(key);
}

/**
 * Stores an image derivative Blob in IndexedDB.
 * @param key The unique key for the derivative.
 * @param blob The derivative image data as a Blob.
 */
export async function setCachedDerivative(key: string, blob: Blob): Promise<void> {
  await derivativeCacheStore.setItem(key, blob);
}

/**
 * Retrieves all keys currently stored in the derivative cache.
 * @returns A promise that resolves to an array of all keys (strings).
 */
export async function getAllCacheKeys(): Promise<string[]> {
  return derivativeCacheStore.keys();
}

================================================================================

File: core/services/images/cloudinaryImage.service.ts
// src/core/services/images/cloudinaryImage.service.ts
import type { ImageService, ImageRef, ImageTransformOptions, Manifest } from '@/core/types';
import { useAppStore } from '@/core/state/useAppStore';
import { Cloudinary } from "@cloudinary/url-gen";
import { fill, fit, scale } from "@cloudinary/url-gen/actions/resize";
import { Gravity } from "@cloudinary/url-gen/qualifiers/gravity";
import { format, quality } from "@cloudinary/url-gen/actions/delivery";

interface UploadWidgetResultInfo {
  public_id: string;
  version: number;
  format: string;
  width: number;
  height: number;
  original_filename?: string;
}

interface UploadWidgetResult {
  event: 'success';
  info: UploadWidgetResultInfo;
}

interface UploadWidgetError {
  message: string;
}

declare const cloudinary: {
  createUploadWidget: (
    options: object,
    callback: (error: UploadWidgetError | null, result: UploadWidgetResult | null) => void
  ) => { open: () => void; close: () => void; };
};

class CloudinaryImageService implements ImageService {
  id = 'cloudinary';
  name = 'Upload to Cloudinary';

  async upload(file: File, siteId: string): Promise<ImageRef> {
    const site = useAppStore.getState().getSiteById(siteId);
    if (!site) throw new Error(`Site with ID "${siteId}" not found in state.`);

    const cloudName = site.manifest?.settings?.cloudinary?.cloudName;
    const uploadPreset = site.secrets?.cloudinary?.uploadPreset;

    if (!cloudName || !uploadPreset) throw new Error("Cloudinary Cloud Name and Upload Preset must be configured.");

    return new Promise((resolve, reject) => {
      const widget = cloudinary.createUploadWidget(
        { cloudName, uploadPreset, sources: ['local', 'url', 'camera'], multiple: false },
        (error, result) => {
          if (error) {
            console.error('Cloudinary Upload Error:', error);
            widget.close();
            return reject(new Error(error.message || 'Image upload failed. Please try again.'));
          }

          if (result && result.event === 'success') {
            const { public_id, width, height } = result.info;
            const srcPath = public_id;
            
            widget.close();
            resolve({
              serviceId: 'cloudinary', src: srcPath,
              alt: result.info.original_filename || 'Uploaded image', width, height,
            });
          }
        }
      );
      widget.open();
    });
  }

  async getDisplayUrl(manifest: Manifest, ref: ImageRef, options: ImageTransformOptions): Promise<string> {
    const cloudName = manifest.settings?.cloudinary?.cloudName;
    if (!cloudName) return ''; // Return empty string or a placeholder if not configured
    
    const cld = new Cloudinary({ cloud: { cloudName: cloudName } });
    const cldImage = cld.image(ref.src);

    const { width, height, crop = 'scale', gravity } = options;

    switch (crop) {
        case 'fill':
            const fillResize = fill(width, height);
            if (gravity === 'auto') fillResize.gravity(Gravity.autoGravity());
            else if (gravity && ['north', 'south', 'east', 'west'].includes(gravity)) fillResize.gravity(Gravity.compass(gravity));
            else if (gravity === 'center') fillResize.gravity(Gravity.xyCenter());
            cldImage.resize(fillResize);
            break;
        case 'fit': cldImage.resize(fit(width, height)); break;
        case 'scale': default: cldImage.resize(scale(width, height)); break;
    }

    cldImage.delivery(format('auto')).delivery(quality('auto'));
    return cldImage.toURL();
  }

  async getExportableAssets(): Promise<{ path: string; data: Blob; }[]> {
    // Cloudinary assets are remote, so there are no local files to export.
    return Promise.resolve([]);
  }
}

export const cloudinaryImageService = new CloudinaryImageService();

================================================================================

File: core/services/images/__tests__/derivativeCache.service.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import {
  getCachedDerivative,
  setCachedDerivative,
  getAllCacheKeys,
  clearSiteDerivativeCache,
  clearAllDerivativeCache
} from '../derivativeCache.service';

// Mock localforage
jest.mock('localforage', () => {
  const mockLocalForageInstance = {
    getItem: jest.fn(),
    setItem: jest.fn(),
    keys: jest.fn(),
    removeItem: jest.fn(),
    clear: jest.fn()
  };

  return {
    createInstance: jest.fn(() => mockLocalForageInstance)
  };
});

// Get the mocked instance for test usage
const localforage = require('localforage');
const mockLocalForageInstance = localforage.createInstance();

describe('derivativeCache.service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    // Clear console mocks
    jest.spyOn(console, 'log').mockImplementation();
    jest.spyOn(console, 'error').mockImplementation();
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  // Helper function to create mock image blobs
  const createMockBlob = (content: string, type = 'image/jpeg'): Blob => {
    return new Blob([content], { type });
  };

  describe('getCachedDerivative', () => {
    test('retrieves cached derivative blob by key', async () => {
      const key = 'test-site/assets/images/photo_w300.jpg';
      const expectedBlob = createMockBlob('cached-image-data');

      mockLocalForageInstance.getItem.mockResolvedValue(expectedBlob);

      const result = await getCachedDerivative(key);

      expect(result).toBe(expectedBlob);
      expect(mockLocalForageInstance.getItem).toHaveBeenCalledWith(key);
    });

    test('returns null when derivative not found', async () => {
      const key = 'test-site/assets/images/nonexistent_w300.jpg';

      mockLocalForageInstance.getItem.mockResolvedValue(null);

      const result = await getCachedDerivative(key);

      expect(result).toBeNull();
      expect(mockLocalForageInstance.getItem).toHaveBeenCalledWith(key);
    });

    test('handles different key formats', async () => {
      const testKeys = [
        'site-123/assets/images/simple.jpg',
        'my-blog-abc/nested/path/image_w100_h200.png',
        'test/complex_w300_h200_c-fill_g-center.webp'
      ];

      for (const key of testKeys) {
        const mockBlob = createMockBlob(`data-for-${key}`);
        mockLocalForageInstance.getItem.mockResolvedValue(mockBlob);

        const result = await getCachedDerivative(key);

        expect(result).toBe(mockBlob);
        expect(mockLocalForageInstance.getItem).toHaveBeenCalledWith(key);
        
        jest.clearAllMocks();
      }
    });

    test('propagates storage errors', async () => {
      const key = 'test-site/assets/images/error.jpg';
      const storageError = new Error('IndexedDB connection failed');

      mockLocalForageInstance.getItem.mockRejectedValue(storageError);

      await expect(getCachedDerivative(key)).rejects.toThrow('IndexedDB connection failed');
    });

    test('handles empty key', async () => {
      mockLocalForageInstance.getItem.mockResolvedValue(null);

      const result = await getCachedDerivative('');

      expect(result).toBeNull();
      expect(mockLocalForageInstance.getItem).toHaveBeenCalledWith('');
    });
  });

  describe('setCachedDerivative', () => {
    test('stores derivative blob with correct key', async () => {
      const key = 'test-site/assets/images/photo_w300.jpg';
      const blob = createMockBlob('compressed-image-data');

      mockLocalForageInstance.setItem.mockResolvedValue(undefined);

      await setCachedDerivative(key, blob);

      expect(mockLocalForageInstance.setItem).toHaveBeenCalledWith(key, blob);
    });

    test('stores different blob types', async () => {
      const testCases = [
        { key: 'site1/image.jpg', blob: createMockBlob('jpeg-data', 'image/jpeg') },
        { key: 'site2/image.png', blob: createMockBlob('png-data', 'image/png') },
        { key: 'site3/image.webp', blob: createMockBlob('webp-data', 'image/webp') }
      ];

      for (const { key, blob } of testCases) {
        mockLocalForageInstance.setItem.mockResolvedValue(undefined);

        await setCachedDerivative(key, blob);

        expect(mockLocalForageInstance.setItem).toHaveBeenCalledWith(key, blob);
        
        jest.clearAllMocks();
      }
    });

    test('handles large blob storage', async () => {
      const key = 'test-site/assets/images/large_w1000.jpg';
      const largeData = 'x'.repeat(1024 * 1024); // 1MB of data
      const largeBlob = createMockBlob(largeData);

      mockLocalForageInstance.setItem.mockResolvedValue(undefined);

      await setCachedDerivative(key, largeBlob);

      expect(mockLocalForageInstance.setItem).toHaveBeenCalledWith(key, largeBlob);
    });

    test('propagates storage errors', async () => {
      const key = 'test-site/assets/images/error.jpg';
      const blob = createMockBlob('test-data');
      const storageError = new Error('Storage quota exceeded');

      mockLocalForageInstance.setItem.mockRejectedValue(storageError);

      await expect(setCachedDerivative(key, blob)).rejects.toThrow('Storage quota exceeded');
    });

    test('overwrites existing cached derivative', async () => {
      const key = 'test-site/assets/images/update.jpg';
      const originalBlob = createMockBlob('original-data');
      const updatedBlob = createMockBlob('updated-data');

      // First storage
      mockLocalForageInstance.setItem.mockResolvedValueOnce(undefined);
      await setCachedDerivative(key, originalBlob);

      // Update storage
      mockLocalForageInstance.setItem.mockResolvedValueOnce(undefined);
      await setCachedDerivative(key, updatedBlob);

      expect(mockLocalForageInstance.setItem).toHaveBeenCalledTimes(2);
      expect(mockLocalForageInstance.setItem).toHaveBeenLastCalledWith(key, updatedBlob);
    });
  });

  describe('getAllCacheKeys', () => {
    test('returns all keys for a specific site', async () => {
      const allKeys = [
        'site-123/assets/images/photo1_w300.jpg',
        'site-123/assets/images/photo2_w200.png',
        'site-456/assets/images/other_w100.jpg',
        'site-123/nested/path/image_w500.webp',
        'another-site/test.jpg'
      ];

      mockLocalForageInstance.keys.mockResolvedValue(allKeys);

      const result = await getAllCacheKeys('site-123');

      expect(result).toEqual([
        'site-123/assets/images/photo1_w300.jpg',
        'site-123/assets/images/photo2_w200.png',
        'site-123/nested/path/image_w500.webp'
      ]);
      expect(mockLocalForageInstance.keys).toHaveBeenCalled();
    });

    test('returns empty array when no keys match site', async () => {
      const allKeys = [
        'other-site/image1.jpg',
        'another-site/image2.png'
      ];

      mockLocalForageInstance.keys.mockResolvedValue(allKeys);

      const result = await getAllCacheKeys('non-existent-site');

      expect(result).toEqual([]);
    });

    test('returns empty array when no keys exist', async () => {
      mockLocalForageInstance.keys.mockResolvedValue([]);

      const result = await getAllCacheKeys('any-site');

      expect(result).toEqual([]);
    });

    test('handles site IDs with special characters', async () => {
      const siteId = 'my-blog-2024';
      const allKeys = [
        'my-blog-2024/assets/images/post_w300.jpg',
        'my-blog-2023/assets/images/old_w300.jpg',
        'my-blog-2024-test/assets/images/test_w300.jpg'
      ];

      mockLocalForageInstance.keys.mockResolvedValue(allKeys);

      const result = await getAllCacheKeys(siteId);

      expect(result).toEqual(['my-blog-2024/assets/images/post_w300.jpg']);
    });

    test('handles site ID that is a prefix of another site ID', async () => {
      const allKeys = [
        'site/image1.jpg',
        'site-extended/image2.jpg',
        'site/sub/image3.jpg'
      ];

      mockLocalForageInstance.keys.mockResolvedValue(allKeys);

      const result = await getAllCacheKeys('site');

      expect(result).toEqual([
        'site/image1.jpg',
        'site/sub/image3.jpg'
      ]);
    });

    test('propagates storage errors', async () => {
      const storageError = new Error('Failed to retrieve keys');
      mockLocalForageInstance.keys.mockRejectedValue(storageError);

      await expect(getAllCacheKeys('test-site')).rejects.toThrow('Failed to retrieve keys');
    });

    test('handles empty site ID', async () => {
      const allKeys = ['site1/image.jpg', 'site2/image.jpg'];
      mockLocalForageInstance.keys.mockResolvedValue(allKeys);

      const result = await getAllCacheKeys('');

      expect(result).toEqual([]);
    });
  });

  describe('clearSiteDerivativeCache', () => {
    test('clears all derivatives for a specific site', async () => {
      const siteId = 'test-site';
      const siteKeys = [
        'test-site/assets/images/photo1_w300.jpg',
        'test-site/assets/images/photo2_w200.png',
        'test-site/nested/image_w100.webp'
      ];

      const allKeys = [
        ...siteKeys,
        'other-site/image.jpg'
      ];

      mockLocalForageInstance.keys.mockResolvedValue(allKeys);
      mockLocalForageInstance.removeItem.mockResolvedValue(undefined);

      await clearSiteDerivativeCache(siteId);

      expect(mockLocalForageInstance.removeItem).toHaveBeenCalledTimes(3);
      expect(mockLocalForageInstance.removeItem).toHaveBeenCalledWith('test-site/assets/images/photo1_w300.jpg');
      expect(mockLocalForageInstance.removeItem).toHaveBeenCalledWith('test-site/assets/images/photo2_w200.png');
      expect(mockLocalForageInstance.removeItem).toHaveBeenCalledWith('test-site/nested/image_w100.webp');
      
      expect(console.log).toHaveBeenCalledWith('[DerivativeCache] Cleared 3 cached derivatives for site test-site');
    });

    test('handles site with no cached derivatives', async () => {
      const siteId = 'empty-site';
      mockLocalForageInstance.keys.mockResolvedValue([]);

      await clearSiteDerivativeCache(siteId);

      expect(mockLocalForageInstance.removeItem).not.toHaveBeenCalled();
      expect(console.log).toHaveBeenCalledWith('[DerivativeCache] Cleared 0 cached derivatives for site empty-site');
    });

    test('continues clearing even if some removals fail', async () => {
      const siteId = 'test-site';
      const siteKeys = [
        'test-site/image1.jpg',
        'test-site/image2.jpg',
        'test-site/image3.jpg'
      ];

      mockLocalForageInstance.keys.mockResolvedValue(siteKeys);
      mockLocalForageInstance.removeItem
        .mockResolvedValueOnce(undefined) // First succeeds
        .mockRejectedValueOnce(new Error('Remove failed')) // Second fails
        .mockResolvedValueOnce(undefined); // Third succeeds

      await clearSiteDerivativeCache(siteId);

      expect(mockLocalForageInstance.removeItem).toHaveBeenCalledTimes(3);
      // Should still complete despite one failure
    });

    test('logs error when clearing fails', async () => {
      const siteId = 'error-site';
      const keysError = new Error('Failed to get keys');

      mockLocalForageInstance.keys.mockRejectedValue(keysError);

      await clearSiteDerivativeCache(siteId);

      expect(console.error).toHaveBeenCalledWith(
        '[DerivativeCache] Failed to clear cache for site error-site:',
        keysError
      );
    });

    test('handles concurrent clear operations', async () => {
      const siteIds = ['site1', 'site2', 'site3'];
      
      mockLocalForageInstance.keys.mockImplementation(() => 
        Promise.resolve(['site1/image.jpg', 'site2/image.jpg', 'site3/image.jpg'])
      );
      mockLocalForageInstance.removeItem.mockResolvedValue(undefined);

      const promises = siteIds.map(siteId => clearSiteDerivativeCache(siteId));
      await Promise.all(promises);

      expect(mockLocalForageInstance.removeItem).toHaveBeenCalledTimes(3);
      expect(console.log).toHaveBeenCalledTimes(3);
    });

    test('properly filters site keys with exact match', async () => {
      const siteId = 'site';
      const allKeys = [
        'site/image1.jpg',
        'site-test/image2.jpg', // Should not be included
        'site/sub/image3.jpg',
        'other-site/image4.jpg' // Should not be included
      ];

      mockLocalForageInstance.keys.mockResolvedValue(allKeys);
      mockLocalForageInstance.removeItem.mockResolvedValue(undefined);

      await clearSiteDerivativeCache(siteId);

      expect(mockLocalForageInstance.removeItem).toHaveBeenCalledTimes(2);
      expect(mockLocalForageInstance.removeItem).toHaveBeenCalledWith('site/image1.jpg');
      expect(mockLocalForageInstance.removeItem).toHaveBeenCalledWith('site/sub/image3.jpg');
    });
  });

  describe('clearAllDerivativeCache', () => {
    test('clears entire derivative cache', async () => {
      mockLocalForageInstance.clear.mockResolvedValue(undefined);

      await clearAllDerivativeCache();

      expect(mockLocalForageInstance.clear).toHaveBeenCalled();
      expect(console.log).toHaveBeenCalledWith('[DerivativeCache] Cleared entire cache for recovery');
    });

    test('logs error when clear all fails', async () => {
      const clearError = new Error('Failed to clear cache');
      mockLocalForageInstance.clear.mockRejectedValue(clearError);

      await clearAllDerivativeCache();

      expect(console.error).toHaveBeenCalledWith(
        '[DerivativeCache] Failed to clear entire cache:',
        clearError
      );
    });

    test('handles multiple concurrent clear all operations', async () => {
      mockLocalForageInstance.clear.mockResolvedValue(undefined);

      const promises = [
        clearAllDerivativeCache(),
        clearAllDerivativeCache(),
        clearAllDerivativeCache()
      ];

      await Promise.all(promises);

      expect(mockLocalForageInstance.clear).toHaveBeenCalledTimes(3);
    });

    test('completes successfully even with concurrent site clears', async () => {
      mockLocalForageInstance.clear.mockResolvedValue(undefined);
      mockLocalForageInstance.keys.mockResolvedValue(['site1/image.jpg']);
      mockLocalForageInstance.removeItem.mockResolvedValue(undefined);

      const promises = [
        clearAllDerivativeCache(),
        clearSiteDerivativeCache('site1')
      ];

      await Promise.all(promises);

      expect(mockLocalForageInstance.clear).toHaveBeenCalled();
      expect(mockLocalForageInstance.removeItem).toHaveBeenCalled();
    });
  });

  describe('Integration and Performance', () => {
    test('handles complete derivative lifecycle', async () => {
      const key = 'test-site/assets/images/lifecycle_w300.jpg';
      const originalBlob = createMockBlob('original-derivative');
      const updatedBlob = createMockBlob('updated-derivative');

      // Store initial derivative
      mockLocalForageInstance.setItem.mockResolvedValue(undefined);
      await setCachedDerivative(key, originalBlob);

      // Retrieve derivative
      mockLocalForageInstance.getItem.mockResolvedValue(originalBlob);
      const retrieved = await getCachedDerivative(key);
      expect(retrieved).toBe(originalBlob);

      // Update derivative
      mockLocalForageInstance.setItem.mockResolvedValue(undefined);
      await setCachedDerivative(key, updatedBlob);

      // Verify in getAllCacheKeys
      mockLocalForageInstance.keys.mockResolvedValue([key]);
      const allKeys = await getAllCacheKeys('test-site');
      expect(allKeys).toContain(key);

      // Clear the site cache
      mockLocalForageInstance.removeItem.mockResolvedValue(undefined);
      await clearSiteDerivativeCache('test-site');

      expect(mockLocalForageInstance.removeItem).toHaveBeenCalledWith(key);
    });

    test('handles high volume of cache operations', async () => {
      const siteId = 'bulk-test-site';
      const operations = 100;
      
      // Generate many cache keys
      const keys = Array.from({ length: operations }, (_, i) => 
        `${siteId}/assets/images/bulk${i}_w300.jpg`
      );

      // Mock bulk storage
      mockLocalForageInstance.setItem.mockResolvedValue(undefined);
      const storePromises = keys.map(key => 
        setCachedDerivative(key, createMockBlob(`data-${key}`))
      );

      const start = performance.now();
      await Promise.all(storePromises);
      const end = performance.now();

      expect(end - start).toBeLessThan(1000); // Should complete quickly
      expect(mockLocalForageInstance.setItem).toHaveBeenCalledTimes(operations);
    });

    test('maintains data integrity across operations', async () => {
      const testData = [
        { key: 'site1/image1.jpg', data: 'data1' },
        { key: 'site1/image2.png', data: 'data2' },
        { key: 'site2/image3.webp', data: 'data3' }
      ];

      // Store all data
      mockLocalForageInstance.setItem.mockResolvedValue(undefined);
      for (const { key, data } of testData) {
        await setCachedDerivative(key, createMockBlob(data));
      }

      // Verify retrieval
      for (const { key, data } of testData) {
        const expectedBlob = createMockBlob(data);
        mockLocalForageInstance.getItem.mockResolvedValue(expectedBlob);
        
        const result = await getCachedDerivative(key);
        expect(result).toBe(expectedBlob);
      }

      // Verify site filtering
      mockLocalForageInstance.keys.mockResolvedValue(testData.map(d => d.key));
      const site1Keys = await getAllCacheKeys('site1');
      const site2Keys = await getAllCacheKeys('site2');

      expect(site1Keys).toHaveLength(2);
      expect(site2Keys).toHaveLength(1);
      expect(site1Keys).toEqual(expect.arrayContaining(['site1/image1.jpg', 'site1/image2.png']));
      expect(site2Keys).toEqual(['site2/image3.webp']);
    });

    test('handles storage errors gracefully in batch operations', async () => {
      const keys = [
        'test-site/success1.jpg',
        'test-site/error.jpg',
        'test-site/success2.jpg'
      ];

      mockLocalForageInstance.setItem
        .mockResolvedValueOnce(undefined) // First succeeds
        .mockRejectedValueOnce(new Error('Storage error')) // Second fails
        .mockResolvedValueOnce(undefined); // Third succeeds

      const results = await Promise.allSettled(
        keys.map(key => setCachedDerivative(key, createMockBlob('data')))
      );

      expect(results[0].status).toBe('fulfilled');
      expect(results[1].status).toBe('rejected');
      expect(results[2].status).toBe('fulfilled');
    });
  });

  describe('Edge Cases', () => {
    test('handles keys with special characters', async () => {
      const specialKeys = [
        'site-123/assets/images/cafÃ©_w300.jpg',
        'my-blog/images/photo (1)_w200.png',
        'test/assets/Ã¼mlaut_w100.webp'
      ];

      mockLocalForageInstance.getItem.mockResolvedValue(createMockBlob('test'));
      
      for (const key of specialKeys) {
        await getCachedDerivative(key);
        expect(mockLocalForageInstance.getItem).toHaveBeenCalledWith(key);
      }
    });

    test('handles very long cache keys', async () => {
      const longKey = 'site/' + 'a'.repeat(1000) + '_w300.jpg';
      const blob = createMockBlob('long-key-data');

      mockLocalForageInstance.setItem.mockResolvedValue(undefined);
      mockLocalForageInstance.getItem.mockResolvedValue(blob);

      await setCachedDerivative(longKey, blob);
      const result = await getCachedDerivative(longKey);

      expect(result).toBe(blob);
    });

    test('handles empty blob', async () => {
      const key = 'test-site/empty.jpg';
      const emptyBlob = new Blob([], { type: 'image/jpeg' });

      mockLocalForageInstance.setItem.mockResolvedValue(undefined);
      await setCachedDerivative(key, emptyBlob);

      expect(mockLocalForageInstance.setItem).toHaveBeenCalledWith(key, emptyBlob);
    });

    test('handles site ID with forward slashes', async () => {
      const siteId = 'user/project/site';
      const keys = [
        'user/project/site/image1.jpg',
        'user/project/site-other/image2.jpg',
        'user/project/site/sub/image3.jpg'
      ];

      mockLocalForageInstance.keys.mockResolvedValue(keys);

      const result = await getAllCacheKeys(siteId);

      expect(result).toEqual([
        'user/project/site/image1.jpg',
        'user/project/site/sub/image3.jpg'
      ]);
    });
  });
});

================================================================================

File: core/services/images/__tests__/images.service.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import { getActiveImageService } from '../images.service';
import { localImageService } from '../localImage.service';
import { cloudinaryImageService } from '../cloudinaryImage.service';
import { Manifest } from '@/core/types';

// Mock the image services
jest.mock('../localImage.service', () => ({
  localImageService: {
    id: 'local',
    name: 'Store in Site Bundle',
    upload: jest.fn(),
    getDisplayUrl: jest.fn(),
    getExportableAssets: jest.fn()
  }
}));

jest.mock('../cloudinaryImage.service', () => ({
  cloudinaryImageService: {
    id: 'cloudinary',
    name: 'Cloudinary CDN',
    upload: jest.fn(),
    getDisplayUrl: jest.fn(),
    getExportableAssets: jest.fn()
  }
}));

describe('images.service', () => {
  // Helper function to create test manifests
  const createManifest = (imageService?: 'local' | 'cloudinary'): Manifest => ({
    siteId: 'test-site',
    generatorVersion: '1.0.0',
    title: 'Test Site',
    description: 'Test Site Description',
    theme: { name: 'default', config: {} },
    structure: [],
    settings: imageService ? { imageService } : undefined
  });

  describe('getActiveImageService', () => {
    test('returns local service when no image service is configured', () => {
      const manifest = createManifest();
      
      const result = getActiveImageService(manifest);
      
      expect(result).toBe(localImageService);
      expect(result.id).toBe('local');
    });

    test('returns local service when explicitly configured', () => {
      const manifest = createManifest('local');
      
      const result = getActiveImageService(manifest);
      
      expect(result).toBe(localImageService);
      expect(result.id).toBe('local');
    });

    test('returns cloudinary service when configured', () => {
      const manifest = createManifest('cloudinary');
      
      const result = getActiveImageService(manifest);
      
      expect(result).toBe(cloudinaryImageService);
      expect(result.id).toBe('cloudinary');
    });

    test('falls back to local service for invalid service ID', () => {
      const manifest: Manifest = {
        siteId: 'test-site',
        generatorVersion: '1.0.0',
        title: 'Test Site',
        description: 'Test Site Description',
        theme: { name: 'default', config: {} },
        structure: [],
        settings: {
          imageService: 'invalid-service' as any
        }
      };
      
      const result = getActiveImageService(manifest);
      
      expect(result).toBe(localImageService);
      expect(result.id).toBe('local');
    });

    test('handles manifest without settings object', () => {
      const manifest: Manifest = {
        siteId: 'test-site',
        generatorVersion: '1.0.0',
        title: 'Test Site',
        description: 'Test Site Description',
        theme: { name: 'default', config: {} },
        structure: []
        // No settings property
      };
      
      const result = getActiveImageService(manifest);
      
      expect(result).toBe(localImageService);
      expect(result.id).toBe('local');
    });

    test('handles empty settings object', () => {
      const manifest: Manifest = {
        siteId: 'test-site',
        generatorVersion: '1.0.0',
        title: 'Test Site',
        description: 'Test Site Description',
        theme: { name: 'default', config: {} },
        structure: [],
        settings: {}
      };
      
      const result = getActiveImageService(manifest);
      
      expect(result).toBe(localImageService);
      expect(result.id).toBe('local');
    });

    test('preserves service properties and methods', () => {
      const localResult = getActiveImageService(createManifest('local'));
      const cloudinaryResult = getActiveImageService(createManifest('cloudinary'));
      
      // Verify local service properties
      expect(localResult.id).toBe('local');
      expect(localResult.name).toBe('Store in Site Bundle');
      expect(typeof localResult.upload).toBe('function');
      expect(typeof localResult.getDisplayUrl).toBe('function');
      expect(typeof localResult.getExportableAssets).toBe('function');
      
      // Verify cloudinary service properties
      expect(cloudinaryResult.id).toBe('cloudinary');
      expect(cloudinaryResult.name).toBe('Cloudinary CDN');
      expect(typeof cloudinaryResult.upload).toBe('function');
      expect(typeof cloudinaryResult.getDisplayUrl).toBe('function');
      expect(typeof cloudinaryResult.getExportableAssets).toBe('function');
    });

    test('returns consistent references for same service type', () => {
      const manifest1 = createManifest('local');
      const manifest2 = createManifest('local');
      
      const service1 = getActiveImageService(manifest1);
      const service2 = getActiveImageService(manifest2);
      
      expect(service1).toBe(service2);
      expect(service1 === service2).toBe(true);
    });

    test('handles different manifest structures', () => {
      const testCases = [
        // Minimal manifest
        {
          siteId: 'minimal',
          generatorVersion: '1.0.0',
          title: 'Minimal',
          description: 'Minimal',
          theme: { name: 'default', config: {} },
          structure: []
        },
        // Rich manifest with other settings
        {
          siteId: 'rich',
          generatorVersion: '1.0.0',
          title: 'Rich',
          description: 'Rich',
          author: 'Test Author',
          baseUrl: 'https://test.com',
          theme: { name: 'custom', config: { color: 'blue' } },
          structure: [],
          settings: {
            imageService: 'cloudinary' as const,
            cloudinary: { cloudName: 'test-cloud' },
            otherSetting: 'value'
          }
        }
      ];

      for (const manifest of testCases) {
        const result = getActiveImageService(manifest as Manifest);
        expect(result).toBeDefined();
        expect(typeof result.id).toBe('string');
        expect(['local', 'cloudinary']).toContain(result.id);
      }
    });

    test('maintains service registry integrity', () => {
      // Test that services are properly registered and accessible
      const localManifest = createManifest('local');
      const cloudinaryManifest = createManifest('cloudinary');
      
      const localService = getActiveImageService(localManifest);
      const cloudinaryService = getActiveImageService(cloudinaryManifest);
      
      expect(localService).not.toBe(cloudinaryService);
      expect(localService.id).not.toBe(cloudinaryService.id);
    });
  });

  describe('Service Integration', () => {
    test('returned services maintain their interface contracts', () => {
      const manifest = createManifest('local');
      const service = getActiveImageService(manifest);
      
      // Verify the service implements the ImageService interface
      expect(service).toHaveProperty('id');
      expect(service).toHaveProperty('name');
      expect(service).toHaveProperty('upload');
      expect(service).toHaveProperty('getDisplayUrl');
      expect(service).toHaveProperty('getExportableAssets');
      
      expect(typeof service.id).toBe('string');
      expect(typeof service.name).toBe('string');
      expect(typeof service.upload).toBe('function');
      expect(typeof service.getDisplayUrl).toBe('function');
      expect(typeof service.getExportableAssets).toBe('function');
    });

    test('service switching works correctly', () => {
      const localManifest = createManifest('local');
      const cloudinaryManifest = createManifest('cloudinary');
      
      let activeService = getActiveImageService(localManifest);
      expect(activeService.id).toBe('local');
      
      activeService = getActiveImageService(cloudinaryManifest);
      expect(activeService.id).toBe('cloudinary');
      
      // Switch back
      activeService = getActiveImageService(localManifest);
      expect(activeService.id).toBe('local');
    });

    test('handles rapid service switching', () => {
      const manifests = [
        createManifest('local'),
        createManifest('cloudinary'),
        createManifest('local'),
        createManifest('cloudinary'),
        createManifest()
      ];
      
      const expectedServices = ['local', 'cloudinary', 'local', 'cloudinary', 'local'];
      
      for (let i = 0; i < manifests.length; i++) {
        const service = getActiveImageService(manifests[i]);
        expect(service.id).toBe(expectedServices[i]);
      }
    });
  });

  describe('Edge Cases', () => {
    test('handles null/undefined service configuration gracefully', () => {
      const manifest: Manifest = {
        siteId: 'test',
        generatorVersion: '1.0.0',
        title: 'Test',
        description: 'Test',
        theme: { name: 'default', config: {} },
        structure: [],
        settings: {
          imageService: null as any
        }
      };
      
      const result = getActiveImageService(manifest);
      expect(result).toBe(localImageService);
    });

    test('handles manifest with complex settings structure', () => {
      const manifest: Manifest = {
        siteId: 'complex',
        generatorVersion: '1.0.0',
        title: 'Complex',
        description: 'Complex',
        theme: { name: 'default', config: {} },
        structure: [],
        settings: {
          imageService: 'cloudinary',
          cloudinary: {
            cloudName: 'test-cloud'
          },
          nestedSettings: {
            imageService: 'local' // This should be ignored
          }
        }
      };
      
      const result = getActiveImageService(manifest);
      expect(result.id).toBe('cloudinary');
    });

    test('maintains performance with repeated calls', () => {
      const manifest = createManifest('local');
      
      const start = performance.now();
      for (let i = 0; i < 1000; i++) {
        getActiveImageService(manifest);
      }
      const end = performance.now();
      
      expect(end - start).toBeLessThan(100); // Should be very fast
    });
  });
});

================================================================================

File: core/services/images/__tests__/localImage.service.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import { localImageService } from '../localImage.service';
import { ImageRef, ImageTransformOptions, Manifest } from '@/core/types';
import { MEMORY_CONFIG } from '@/config/editorConfig';

// Mock external dependencies
jest.mock('@/core/services/localFileSystem.service', () => ({
  saveImageAsset: jest.fn(),
  getImageAsset: jest.fn()
}));

jest.mock('../derivativeCache.service', () => ({
  getCachedDerivative: jest.fn(),
  setCachedDerivative: jest.fn(),
  getAllCacheKeys: jest.fn()
}));

jest.mock('browser-image-compression', () => ({
  __esModule: true,
  default: jest.fn()
}));

jest.mock('@/core/libraries/utils', () => ({
  slugify: jest.fn()
}));

jest.mock('sonner', () => ({
  toast: {
    error: jest.fn()
  }
}));

import * as localSiteFs from '@/core/services/localFileSystem.service';
import { getCachedDerivative, setCachedDerivative, getAllCacheKeys } from '../derivativeCache.service';
import imageCompression from 'browser-image-compression';
import { slugify } from '@/core/libraries/utils';
import { toast } from 'sonner';

const mockSaveImageAsset = localSiteFs.saveImageAsset as jest.MockedFunction<typeof localSiteFs.saveImageAsset>;
const mockGetImageAsset = localSiteFs.getImageAsset as jest.MockedFunction<typeof localSiteFs.getImageAsset>;
const mockGetCachedDerivative = getCachedDerivative as jest.MockedFunction<typeof getCachedDerivative>;
const mockSetCachedDerivative = setCachedDerivative as jest.MockedFunction<typeof setCachedDerivative>;
const mockGetAllCacheKeys = getAllCacheKeys as jest.MockedFunction<typeof getAllCacheKeys>;
const mockImageCompression = imageCompression as jest.MockedFunction<typeof imageCompression>;
const mockSlugify = slugify as jest.MockedFunction<typeof slugify>;
const mockToastError = toast.error as jest.MockedFunction<typeof toast.error>;

// Mock global URL methods
const mockCreateObjectURL = jest.fn();
const mockRevokeObjectURL = jest.fn();
global.URL.createObjectURL = mockCreateObjectURL;
global.URL.revokeObjectURL = mockRevokeObjectURL;

// Mock Image constructor
const mockImage = {
  onload: jest.fn(),
  onerror: jest.fn(),
  width: 800,
  height: 600,
  src: ''
};
global.Image = jest.fn(() => mockImage) as any;

describe('localImage.service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    // Reset Date.now to a consistent value
    jest.spyOn(Date, 'now').mockReturnValue(1640995200000); // 2022-01-01
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  // Helper functions
  const createMockFile = (
    name: string, 
    type: string, 
    size: number,
    content?: string
  ): File => {
    // Create content that matches the target size
    const targetContent = content || 'x'.repeat(size);
    const blob = new Blob([targetContent], { type });
    
    // Create a File with the exact size
    const file = new File([blob], name, { type });
    
    // Mock the size property to ensure it matches our target
    Object.defineProperty(file, 'size', {
      value: size,
      writable: false
    });
    
    return file;
  };

  const createManifest = (siteId: string): Manifest => ({
    siteId,
    generatorVersion: '1.0.0',
    title: 'Test Site',
    description: 'Test Site',
    theme: { name: 'default', config: {} },
    structure: []
  });

  describe('Service Properties', () => {
    test('has correct service identification', () => {
      expect(localImageService.id).toBe('local');
      expect(localImageService.name).toBe('Store in Site Bundle');
    });
  });

  describe('upload', () => {
    beforeEach(() => {
      mockSlugify.mockImplementation((str) => str.toLowerCase().replace(/[^a-z0-9]/g, '-'));
      mockSaveImageAsset.mockResolvedValue(undefined);
      
      // Mock successful image dimension retrieval
      setTimeout(() => {
        mockImage.onload();
      }, 0);
    });

    test('successfully uploads a valid JPEG image', async () => {
      const file = createMockFile('test-image.jpg', 'image/jpeg', 1024 * 1024); // 1MB
      const siteId = 'test-site';

      mockCreateObjectURL.mockReturnValue('blob:mock-url');

      const result = await localImageService.upload(file, siteId);

      expect(result).toEqual({
        serviceId: 'local',
        src: 'assets/images/1640995200000-test-image.jpg',
        alt: 'test-image.jpg',
        width: 800,
        height: 600
      });

      expect(mockSlugify).toHaveBeenCalledWith('test-image');
      expect(mockSaveImageAsset).toHaveBeenCalledWith(
        siteId,
        'assets/images/1640995200000-test-image.jpg',
        file
      );
    });

    test('successfully uploads a valid PNG image', async () => {
      const file = createMockFile('my-photo.png', 'image/png', 2 * 1024 * 1024); // 2MB
      const siteId = 'test-site';

      mockCreateObjectURL.mockReturnValue('blob:mock-url');

      const result = await localImageService.upload(file, siteId);

      expect(result).toEqual({
        serviceId: 'local',
        src: 'assets/images/1640995200000-my-photo.png',
        alt: 'my-photo.png',
        width: 800,
        height: 600
      });
    });

    test('successfully uploads a valid SVG image', async () => {
      const file = createMockFile('icon.svg', 'image/svg+xml', 100 * 1024); // 100KB
      const siteId = 'test-site';

      mockCreateObjectURL.mockReturnValue('blob:mock-url');

      const result = await localImageService.upload(file, siteId);

      expect(result.serviceId).toBe('local');
      expect(result.src).toBe('assets/images/1640995200000-icon.svg');
      expect(result.alt).toBe('icon.svg');
    });

    test('handles special characters in filename', async () => {
      const file = createMockFile('My Photo (2024)!.jpg', 'image/jpeg', 1024 * 1024);
      const siteId = 'test-site';

      mockSlugify.mockReturnValue('my-photo-2024');
      mockCreateObjectURL.mockReturnValue('blob:mock-url');

      const result = await localImageService.upload(file, siteId);

      expect(result.src).toBe('assets/images/1640995200000-my-photo-2024.jpg');
      expect(mockSlugify).toHaveBeenCalledWith('My Photo (2024)!');
    });

    test('throws error for unsupported file type', async () => {
      const file = createMockFile('document.pdf', 'application/pdf', 1024);
      const siteId = 'test-site';

      await expect(localImageService.upload(file, siteId)).rejects.toThrow(
        'Unsupported file type: application/pdf.'
      );

      expect(mockToastError).toHaveBeenCalledWith('Unsupported file type: application/pdf.');
      expect(mockSaveImageAsset).not.toHaveBeenCalled();
    });

    test('throws error for oversized JPEG image', async () => {
      const file = createMockFile('huge.jpg', 'image/jpeg', 10 * 1024 * 1024); // 10MB > 5MB limit
      const siteId = 'test-site';

      await expect(localImageService.upload(file, siteId)).rejects.toThrow(
        'Image is too large. Max size is 5.0MB.'
      );

      expect(mockToastError).toHaveBeenCalledWith('Image is too large. Max size is 5.0MB.');
      expect(mockSaveImageAsset).not.toHaveBeenCalled();
    });

    test('throws error for oversized SVG image', async () => {
      const file = createMockFile('huge.svg', 'image/svg+xml', 1024 * 1024); // 1MB > 512KB limit
      const siteId = 'test-site';

      await expect(localImageService.upload(file, siteId)).rejects.toThrow(
        'Image is too large. Max size is 512.0KB.'
      );

      expect(mockToastError).toHaveBeenCalledWith('Image is too large. Max size is 512.0KB.');
      expect(mockSaveImageAsset).not.toHaveBeenCalled();
    });

    test('throws error for file without extension', async () => {
      const file = createMockFile('imagefile', 'image/jpeg', 1024);
      const siteId = 'test-site';

      await expect(localImageService.upload(file, siteId)).rejects.toThrow(
        'Uploaded file is missing an extension.'
      );

      expect(mockSaveImageAsset).not.toHaveBeenCalled();
    });

    test('handles image dimension retrieval failure gracefully', async () => {
      const file = createMockFile('test.jpg', 'image/jpeg', 1024);
      const siteId = 'test-site';

      // Mock failed image loading
      setTimeout(() => {
        mockImage.onerror(new Error('Failed to load'));
      }, 0);

      const result = await localImageService.upload(file, siteId);

      expect(result.width).toBe(0);
      expect(result.height).toBe(0);
    });

    test('validates against memory config limits', async () => {
      // Test that the service uses MEMORY_CONFIG constants
      const jpegFile = createMockFile('test.jpg', 'image/jpeg', MEMORY_CONFIG.MAX_UPLOAD_SIZE + 1);
      const svgFile = createMockFile('test.svg', 'image/svg+xml', MEMORY_CONFIG.MAX_SVG_SIZE + 1);

      await expect(localImageService.upload(jpegFile, 'test-site')).rejects.toThrow(/too large/);
      await expect(localImageService.upload(svgFile, 'test-site')).rejects.toThrow(/too large/);
    });

    test('supports all configured image types', async () => {
      const supportedTypes = MEMORY_CONFIG.SUPPORTED_IMAGE_TYPES;
      
      for (const type of supportedTypes) {
        const file = createMockFile(`test.${type.split('/')[1]}`, type, 1024);
        mockCreateObjectURL.mockReturnValue('blob:mock-url');
        
        await expect(localImageService.upload(file, 'test-site')).resolves.toBeDefined();
      }
    });
  });

  describe('getDisplayUrl', () => {
    const manifest = createManifest('test-site');
    const imageRef: ImageRef = {
      serviceId: 'local',
      src: 'assets/images/test.jpg',
      alt: 'Test Image',
      width: 800,
      height: 600
    };

    beforeEach(() => {
      mockGetImageAsset.mockResolvedValue(new Blob(['mock-image-data'], { type: 'image/jpeg' }));
      mockCreateObjectURL.mockReturnValue('blob:mock-display-url');
    });

    test('returns relative path for SVG in export mode', async () => {
      const svgRef: ImageRef = {
        serviceId: 'local',
        src: 'assets/images/icon.svg',
        alt: 'Icon'
      };

      const options: ImageTransformOptions = { width: 100 };
      const result = await localImageService.getDisplayUrl(manifest, svgRef, options, true);

      expect(result).toBe('assets/images/icon.svg');
      expect(mockGetImageAsset).not.toHaveBeenCalled();
    });

    test('returns blob URL for SVG in preview mode', async () => {
      const svgRef: ImageRef = {
        serviceId: 'local',
        src: 'assets/images/icon.svg',
        alt: 'Icon'
      };

      const options: ImageTransformOptions = { width: 100 };
      const result = await localImageService.getDisplayUrl(manifest, svgRef, options, false);

      expect(result).toBe('blob:mock-display-url');
      expect(mockGetImageAsset).toHaveBeenCalledWith('test-site', 'assets/images/icon.svg');
      expect(mockCreateObjectURL).toHaveBeenCalled();
    });

    test('generates derivative filename with transform options', async () => {
      const options: ImageTransformOptions = {
        width: 300,
        height: 200,
        crop: 'fill',
        gravity: 'north'
      };

      mockGetCachedDerivative.mockResolvedValue(null); // Not cached
      mockImageCompression.mockResolvedValue(new Blob(['compressed'], { type: 'image/jpeg' }));

      // Mock successful image loading for dimensions
      setTimeout(() => {
        mockImage.onload();
      }, 0);

      const result = await localImageService.getDisplayUrl(manifest, imageRef, options, true);

      const expectedFilename = 'assets/images/test_w300_h200_c-fill_g-north.jpg';
      expect(result).toBe(expectedFilename);
    });

    test('uses cached derivative when available', async () => {
      const options: ImageTransformOptions = { width: 300 };
      const cachedBlob = new Blob(['cached-image'], { type: 'image/jpeg' });

      mockGetCachedDerivative.mockResolvedValue(cachedBlob);

      const result = await localImageService.getDisplayUrl(manifest, imageRef, options, false);

      expect(result).toBe('blob:mock-display-url');
      expect(mockCreateObjectURL).toHaveBeenCalledWith(cachedBlob);
      expect(mockImageCompression).not.toHaveBeenCalled();
    });

    test('processes new derivative when not cached', async () => {
      const options: ImageTransformOptions = { width: 300, height: 200 };
      const compressedBlob = new Blob(['compressed'], { type: 'image/jpeg' });

      mockGetCachedDerivative.mockResolvedValue(null);
      mockImageCompression.mockResolvedValue(compressedBlob);

      // Mock successful image loading
      setTimeout(() => {
        mockImage.onload();
      }, 0);

      const result = await localImageService.getDisplayUrl(manifest, imageRef, options, false);

      expect(result).toBe('blob:mock-display-url');
      expect(mockImageCompression).toHaveBeenCalled();
      expect(mockSetCachedDerivative).toHaveBeenCalled();
    });

    test('handles different crop modes correctly', async () => {
      const testCases = [
        { crop: 'fill' as const, width: 300, height: 200 },
        { crop: 'fit' as const, width: 300 },
        { crop: 'scale' as const, height: 200 }
      ];

      mockGetCachedDerivative.mockResolvedValue(null);
      mockImageCompression.mockResolvedValue(new Blob(['compressed'], { type: 'image/jpeg' }));

      for (const options of testCases) {
        setTimeout(() => {
          mockImage.onload();
        }, 0);

        await localImageService.getDisplayUrl(manifest, imageRef, options, true);
        
        expect(mockImageCompression).toHaveBeenCalled();
        jest.clearAllMocks();
        mockGetCachedDerivative.mockResolvedValue(null);
        mockImageCompression.mockResolvedValue(new Blob(['compressed'], { type: 'image/jpeg' }));
      }
    });

    test('prevents upscaling by capping dimensions', async () => {
      const options: ImageTransformOptions = {
        width: 1600, // Larger than source (800)
        height: 1200, // Larger than source (600)
        crop: 'fill'
      };

      mockGetCachedDerivative.mockResolvedValue(null);
      mockImageCompression.mockResolvedValue(new Blob(['compressed'], { type: 'image/jpeg' }));

      // Mock image dimensions from getImageDimensions
      setTimeout(() => {
        mockImage.width = 800;
        mockImage.height = 600;
        mockImage.onload();
      }, 0);

      await localImageService.getDisplayUrl(manifest, imageRef, options, false);

      expect(mockImageCompression).toHaveBeenCalledWith(
        expect.any(Blob),
        expect.objectContaining({
          maxWidth: 800, // Capped at source width
          maxHeight: 600  // Capped at source height
        })
      );
    });

    test('handles compression timeout', async () => {
      const options: ImageTransformOptions = { width: 300 };

      mockGetCachedDerivative.mockResolvedValue(null);
      
      // Mock compression that never resolves
      mockImageCompression.mockImplementation(() => new Promise(() => {}));

      setTimeout(() => {
        mockImage.onload();
      }, 0);

      // Fast forward time to trigger timeout
      jest.useFakeTimers();
      const promise = localImageService.getDisplayUrl(manifest, imageRef, options, false);
      jest.advanceTimersByTime(31000); // 31 seconds > 30 second timeout

      await expect(promise).rejects.toThrow('Image compression timed out after 30 seconds');
      
      jest.useRealTimers();
    });

    test('throws error for image without extension', async () => {
      const invalidRef: ImageRef = {
        serviceId: 'local',
        src: 'assets/images/noextension',
        alt: 'Invalid'
      };

      const options: ImageTransformOptions = { width: 300 };

      await expect(
        localImageService.getDisplayUrl(manifest, invalidRef, options, false)
      ).rejects.toThrow('Source image has no extension.');
    });

    test('handles missing source image', async () => {
      const options: ImageTransformOptions = { width: 300 };

      mockGetImageAsset.mockResolvedValue(null);
      mockGetCachedDerivative.mockResolvedValue(null);

      await expect(
        localImageService.getDisplayUrl(manifest, imageRef, options, false)
      ).rejects.toThrow('Source image not found in local storage: assets/images/test.jpg');
    });

    test('deduplicates concurrent processing requests', async () => {
      const options: ImageTransformOptions = { width: 300 };

      mockGetCachedDerivative.mockResolvedValue(null);
      mockImageCompression.mockImplementation(() => 
        new Promise(resolve => setTimeout(() => resolve(new Blob(['compressed'])), 100))
      );

      setTimeout(() => {
        mockImage.onload();
      }, 0);

      // Start multiple concurrent requests for the same derivative
      const promises = [
        localImageService.getDisplayUrl(manifest, imageRef, options, false),
        localImageService.getDisplayUrl(manifest, imageRef, options, false),
        localImageService.getDisplayUrl(manifest, imageRef, options, false)
      ];

      await Promise.all(promises);

      // Should only process once, not three times
      expect(mockImageCompression).toHaveBeenCalledTimes(1);
    });
  });

  describe('getExportableAssets', () => {
    const siteId = 'test-site';

    test('exports source images and cached derivatives', async () => {
      const imageRefs: ImageRef[] = [
        {
          serviceId: 'local',
          src: 'assets/images/photo1.jpg',
          alt: 'Photo 1'
        },
        {
          serviceId: 'local',
          src: 'assets/images/photo2.png',
          alt: 'Photo 2'
        },
        {
          serviceId: 'cloudinary', // Should be ignored
          src: 'cloudinary-url',
          alt: 'Cloudinary Image'
        }
      ];

      const photo1Blob = new Blob(['photo1-data'], { type: 'image/jpeg' });
      const photo2Blob = new Blob(['photo2-data'], { type: 'image/png' });
      const derivative1Blob = new Blob(['derivative1-data'], { type: 'image/jpeg' });
      const derivative2Blob = new Blob(['derivative2-data'], { type: 'image/jpeg' });

      mockGetImageAsset
        .mockResolvedValueOnce(photo1Blob)
        .mockResolvedValueOnce(photo2Blob);

      mockGetAllCacheKeys.mockResolvedValue([
        'test-site/assets/images/photo1_w300.jpg',
        'test-site/assets/images/photo2_w200.png'
      ]);

      mockGetCachedDerivative
        .mockResolvedValueOnce(derivative1Blob)
        .mockResolvedValueOnce(derivative2Blob);

      const result = await localImageService.getExportableAssets(siteId, imageRefs);

      expect(result).toHaveLength(4); // 2 sources + 2 derivatives
      
      const resultMap = new Map(result.map(asset => [asset.path, asset.data]));
      expect(resultMap.get('assets/images/photo1.jpg')).toBe(photo1Blob);
      expect(resultMap.get('assets/images/photo2.png')).toBe(photo2Blob);
      expect(resultMap.get('assets/images/photo1_w300.jpg')).toBe(derivative1Blob);
      expect(resultMap.get('assets/images/photo2_w200.png')).toBe(derivative2Blob);
    });

    test('handles missing source images gracefully', async () => {
      const imageRefs: ImageRef[] = [
        {
          serviceId: 'local',
          src: 'assets/images/missing.jpg',
          alt: 'Missing Image'
        }
      ];

      mockGetImageAsset.mockResolvedValue(null); // Missing source
      mockGetAllCacheKeys.mockResolvedValue([]);

      const result = await localImageService.getExportableAssets(siteId, imageRefs);

      expect(result).toHaveLength(0);
    });

    test('handles missing derivatives gracefully', async () => {
      const imageRefs: ImageRef[] = [
        {
          serviceId: 'local',
          src: 'assets/images/photo.jpg',
          alt: 'Photo'
        }
      ];

      const photoBlob = new Blob(['photo-data'], { type: 'image/jpeg' });

      mockGetImageAsset.mockResolvedValue(photoBlob);
      mockGetAllCacheKeys.mockResolvedValue(['test-site/assets/images/missing_derivative.jpg']);
      mockGetCachedDerivative.mockResolvedValue(null); // Missing derivative

      const result = await localImageService.getExportableAssets(siteId, imageRefs);

      expect(result).toHaveLength(1); // Only source image
      expect(result[0].path).toBe('assets/images/photo.jpg');
      expect(result[0].data).toBe(photoBlob);
    });

    test('deduplicates assets with same path', async () => {
      const imageRefs: ImageRef[] = [
        {
          serviceId: 'local',
          src: 'assets/images/photo.jpg',
          alt: 'Photo 1'
        },
        {
          serviceId: 'local',
          src: 'assets/images/photo.jpg', // Duplicate path
          alt: 'Photo 2'
        }
      ];

      const photoBlob = new Blob(['photo-data'], { type: 'image/jpeg' });
      mockGetImageAsset.mockResolvedValue(photoBlob);
      mockGetAllCacheKeys.mockResolvedValue([]);

      const result = await localImageService.getExportableAssets(siteId, imageRefs);

      expect(result).toHaveLength(1); // Deduplicated
      expect(mockGetImageAsset).toHaveBeenCalledTimes(1); // Only called once
    });

    test('filters out non-local images', async () => {
      const imageRefs: ImageRef[] = [
        {
          serviceId: 'cloudinary',
          src: 'cloudinary-url',
          alt: 'Cloudinary Image'
        },
        {
          serviceId: 'local',
          src: 'assets/images/local.jpg',
          alt: 'Local Image'
        }
      ];

      const localBlob = new Blob(['local-data'], { type: 'image/jpeg' });
      mockGetImageAsset.mockResolvedValue(localBlob);
      mockGetAllCacheKeys.mockResolvedValue([]);

      const result = await localImageService.getExportableAssets(siteId, imageRefs);

      expect(result).toHaveLength(1);
      expect(result[0].path).toBe('assets/images/local.jpg');
      expect(mockGetImageAsset).toHaveBeenCalledWith(siteId, 'assets/images/local.jpg');
    });

    test('handles empty image refs array', async () => {
      mockGetAllCacheKeys.mockResolvedValue([]);

      const result = await localImageService.getExportableAssets(siteId, []);

      expect(result).toHaveLength(0);
      expect(mockGetImageAsset).not.toHaveBeenCalled();
    });

    test('properly extracts derivative filenames from cache keys', async () => {
      const imageRefs: ImageRef[] = [];
      const derivativeBlob = new Blob(['derivative'], { type: 'image/jpeg' });

      mockGetAllCacheKeys.mockResolvedValue([
        'test-site/assets/images/complex_w300_h200_c-fill_g-center.jpg',
        'test-site/nested/path/image_w100.png'
      ]);

      mockGetCachedDerivative.mockResolvedValue(derivativeBlob);

      const result = await localImageService.getExportableAssets(siteId, imageRefs);

      expect(result).toHaveLength(2);
      expect(result[0].path).toBe('assets/images/complex_w300_h200_c-fill_g-center.jpg');
      expect(result[1].path).toBe('nested/path/image_w100.png');
    });
  });

  describe('Edge Cases and Performance', () => {
    test('handles very large file names', async () => {
      const longName = 'a'.repeat(200) + '.jpg';
      const file = createMockFile(longName, 'image/jpeg', 1024);

      mockSlugify.mockReturnValue('a'.repeat(200));
      mockCreateObjectURL.mockReturnValue('blob:mock-url');

      const result = await localImageService.upload(file, 'test-site');

      expect(result.src).toContain('a'.repeat(200));
    });

    test('maintains performance with multiple concurrent uploads', async () => {
      const files = Array.from({ length: 10 }, (_, i) => 
        createMockFile(`image${i}.jpg`, 'image/jpeg', 1024)
      );

      mockSlugify.mockImplementation((str) => str);
      mockCreateObjectURL.mockReturnValue('blob:mock-url');

      const start = performance.now();
      const promises = files.map(file => localImageService.upload(file, 'test-site'));
      await Promise.all(promises);
      const end = performance.now();

      expect(end - start).toBeLessThan(1000); // Should complete quickly
      expect(mockSaveImageAsset).toHaveBeenCalledTimes(10);
    });

    test('properly cleans up object URLs', async () => {
      const imageRef: ImageRef = {
        serviceId: 'local',
        src: 'assets/images/test.svg',
        alt: 'Test SVG'
      };

      mockGetImageAsset.mockResolvedValue(new Blob(['svg-data'], { type: 'image/svg+xml' }));
      mockCreateObjectURL.mockReturnValue('blob:mock-url');

      await localImageService.getDisplayUrl(createManifest('test-site'), imageRef, {}, false);

      // Verify URL creation but not revocation (as that happens outside our control)
      expect(mockCreateObjectURL).toHaveBeenCalled();
    });
  });
});

================================================================================

File: core/services/__tests__/urlUtils.service.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import { getUrlForNode } from '../urlUtils.service';
import { Manifest, StructureNode } from '@/core/types';

describe('urlUtils.service', () => {
  // Helper function to create a mock manifest
  const createManifest = (structure: StructureNode[]): Manifest => ({
    siteId: 'test-site',
    generatorVersion: '1.0.0',
    title: 'Test Site',
    description: 'A test site',
    theme: {
      name: 'default',
      config: {}
    },
    structure
  });

  // Helper function to create mock nodes
  const createNode = (path: string, slug: string): StructureNode => ({
    type: 'page',
    title: path.replace('content/', '').replace('.md', ''),
    path,
    slug
  });

  // Sample structure for testing
  const sampleStructure: StructureNode[] = [
    createNode('content/home.md', 'home'),
    createNode('content/about.md', 'about'),
    createNode('content/blog.md', 'blog'),
    createNode('content/contact.md', 'contact')
  ];

  const manifest = createManifest(sampleStructure);

  describe('getUrlForNode', () => {
    describe('Homepage Detection', () => {
      test('identifies first node as homepage', () => {
        const homeNode = sampleStructure[0]; // content/home.md
        
        // Export mode
        expect(getUrlForNode(homeNode, manifest, true)).toBe('index.html');
        
        // Preview mode
        expect(getUrlForNode(homeNode, manifest, false)).toBe('');
      });

      test('does not treat other nodes as homepage', () => {
        const aboutNode = sampleStructure[1]; // content/about.md
        
        // Export mode
        expect(getUrlForNode(aboutNode, manifest, true)).toBe('about/index.html');
        
        // Preview mode
        expect(getUrlForNode(aboutNode, manifest, false)).toBe('about');
      });

      test('handles empty structure gracefully', () => {
        const emptyManifest = createManifest([]);
        const testNode = createNode('content/test.md', 'test');
        
        // Should not be treated as homepage since structure is empty
        expect(getUrlForNode(testNode, emptyManifest, true)).toBe('test/index.html');
        expect(getUrlForNode(testNode, emptyManifest, false)).toBe('test');
      });

      test('handles single node structure', () => {
        const singleNodeStructure = [createNode('content/only.md', 'only')];
        const singleNodeManifest = createManifest(singleNodeStructure);
        const onlyNode = singleNodeStructure[0];
        
        // Single node should be treated as homepage
        expect(getUrlForNode(onlyNode, singleNodeManifest, true)).toBe('index.html');
        expect(getUrlForNode(onlyNode, singleNodeManifest, false)).toBe('');
      });
    });

    describe('Export Mode URLs', () => {
      test('generates correct URLs for regular pages', () => {
        expect(getUrlForNode(sampleStructure[1], manifest, true)).toBe('about/index.html');
        expect(getUrlForNode(sampleStructure[2], manifest, true)).toBe('blog/index.html');
        expect(getUrlForNode(sampleStructure[3], manifest, true)).toBe('contact/index.html');
      });

      test('handles pages with complex slugs', () => {
        const complexNode = createNode('content/my-long-page-name.md', 'my-long-page-name');
        expect(getUrlForNode(complexNode, manifest, true)).toBe('my-long-page-name/index.html');
      });

      test('handles pages with nested slugs', () => {
        const nestedNode = createNode('content/blog/post1.md', 'blog/post1');
        expect(getUrlForNode(nestedNode, manifest, true)).toBe('blog/post1/index.html');
      });

      test('handles pages with special characters in slugs', () => {
        const specialNode = createNode('content/cafÃ©-niÃ±o.md', 'cafe-nino');
        expect(getUrlForNode(specialNode, manifest, true)).toBe('cafe-nino/index.html');
      });
    });

    describe('Preview Mode URLs', () => {
      test('generates correct URLs for regular pages', () => {
        expect(getUrlForNode(sampleStructure[1], manifest, false)).toBe('about');
        expect(getUrlForNode(sampleStructure[2], manifest, false)).toBe('blog');
        expect(getUrlForNode(sampleStructure[3], manifest, false)).toBe('contact');
      });

      test('handles pages with complex slugs', () => {
        const complexNode = createNode('content/my-long-page-name.md', 'my-long-page-name');
        expect(getUrlForNode(complexNode, manifest, false)).toBe('my-long-page-name');
      });

      test('handles pages with nested slugs', () => {
        const nestedNode = createNode('content/blog/post1.md', 'blog/post1');
        expect(getUrlForNode(nestedNode, manifest, false)).toBe('blog/post1');
      });

      test('handles empty slug gracefully', () => {
        const emptySlugNode = createNode('content/empty.md', '');
        expect(getUrlForNode(emptySlugNode, manifest, false)).toBe('');
      });
    });

    describe('Pagination Support', () => {
      describe('Homepage Pagination', () => {
        test('handles homepage pagination in export mode', () => {
          const homeNode = sampleStructure[0];
          
          expect(getUrlForNode(homeNode, manifest, true, 1)).toBe('index.html');
          expect(getUrlForNode(homeNode, manifest, true, 2)).toBe('page/2/index.html');
          expect(getUrlForNode(homeNode, manifest, true, 3)).toBe('page/3/index.html');
          expect(getUrlForNode(homeNode, manifest, true, 10)).toBe('page/10/index.html');
        });

        test('handles homepage pagination in preview mode', () => {
          const homeNode = sampleStructure[0];
          
          expect(getUrlForNode(homeNode, manifest, false, 1)).toBe('');
          expect(getUrlForNode(homeNode, manifest, false, 2)).toBe('page/2');
          expect(getUrlForNode(homeNode, manifest, false, 3)).toBe('page/3');
          expect(getUrlForNode(homeNode, manifest, false, 10)).toBe('page/10');
        });

        test('handles edge cases for homepage pagination', () => {
          const homeNode = sampleStructure[0];
          
          // Page 0 should be treated as page 1
          expect(getUrlForNode(homeNode, manifest, true, 0)).toBe('index.html');
          expect(getUrlForNode(homeNode, manifest, false, 0)).toBe('');
          
          // Negative page numbers
          expect(getUrlForNode(homeNode, manifest, true, -1)).toBe('index.html');
          expect(getUrlForNode(homeNode, manifest, false, -1)).toBe('');
        });
      });

      describe('Regular Page Pagination', () => {
        test('handles regular page pagination in export mode', () => {
          const blogNode = sampleStructure[2]; // blog
          
          expect(getUrlForNode(blogNode, manifest, true, 1)).toBe('blog/index.html');
          expect(getUrlForNode(blogNode, manifest, true, 2)).toBe('blog/page/2/index.html');
          expect(getUrlForNode(blogNode, manifest, true, 3)).toBe('blog/page/3/index.html');
          expect(getUrlForNode(blogNode, manifest, true, 10)).toBe('blog/page/10/index.html');
        });

        test('handles regular page pagination in preview mode', () => {
          const blogNode = sampleStructure[2]; // blog
          
          expect(getUrlForNode(blogNode, manifest, false, 1)).toBe('blog');
          expect(getUrlForNode(blogNode, manifest, false, 2)).toBe('blog/page/2');
          expect(getUrlForNode(blogNode, manifest, false, 3)).toBe('blog/page/3');
          expect(getUrlForNode(blogNode, manifest, false, 10)).toBe('blog/page/10');
        });

        test('handles nested page pagination', () => {
          const nestedNode = createNode('content/blog/category.md', 'blog/category');
          
          expect(getUrlForNode(nestedNode, manifest, true, 1)).toBe('blog/category/index.html');
          expect(getUrlForNode(nestedNode, manifest, true, 2)).toBe('blog/category/page/2/index.html');
          
          expect(getUrlForNode(nestedNode, manifest, false, 1)).toBe('blog/category');
          expect(getUrlForNode(nestedNode, manifest, false, 2)).toBe('blog/category/page/2');
        });

        test('handles edge cases for regular page pagination', () => {
          const aboutNode = sampleStructure[1];
          
          // Page 0 and negative numbers should be treated as page 1
          expect(getUrlForNode(aboutNode, manifest, true, 0)).toBe('about/index.html');
          expect(getUrlForNode(aboutNode, manifest, false, 0)).toBe('about');
          
          expect(getUrlForNode(aboutNode, manifest, true, -5)).toBe('about/index.html');
          expect(getUrlForNode(aboutNode, manifest, false, -5)).toBe('about');
        });
      });

      test('handles undefined page number (should default to page 1)', () => {
        const homeNode = sampleStructure[0];
        const aboutNode = sampleStructure[1];
        
        expect(getUrlForNode(homeNode, manifest, true, undefined)).toBe('index.html');
        expect(getUrlForNode(homeNode, manifest, false, undefined)).toBe('');
        
        expect(getUrlForNode(aboutNode, manifest, true, undefined)).toBe('about/index.html');
        expect(getUrlForNode(aboutNode, manifest, false, undefined)).toBe('about');
      });
    });

    describe('Edge Cases and Validation', () => {
      test('handles nodes with different path formats', () => {
        const variations = [
          createNode('content/page.md', 'page'),
          createNode('content/section/page.md', 'section/page'),
          createNode('content/deep/nested/page.md', 'deep/nested/page')
        ];
        
        variations.forEach(node => {
          expect(getUrlForNode(node, manifest, true)).toBe(`${node.slug}/index.html`);
          expect(getUrlForNode(node, manifest, false)).toBe(node.slug);
        });
      });

      test('handles node with same path as homepage but different object', () => {
        const homeNode = sampleStructure[0];
        const duplicatePathNode = createNode(homeNode.path, homeNode.slug);
        
        // Should still be treated as homepage because path matches
        expect(getUrlForNode(duplicatePathNode, manifest, true)).toBe('index.html');
        expect(getUrlForNode(duplicatePathNode, manifest, false)).toBe('');
      });

      test('handles manifest with complex structure', () => {
        const complexStructure = [
          createNode('content/index.md', ''), // Empty slug homepage
          createNode('content/about/index.md', 'about'),
          createNode('content/blog/index.md', 'blog'),
          createNode('content/projects/web/index.md', 'projects/web')
        ];
        const complexManifest = createManifest(complexStructure);
        
        // First node should be homepage regardless of slug
        expect(getUrlForNode(complexStructure[0], complexManifest, true)).toBe('index.html');
        expect(getUrlForNode(complexStructure[0], complexManifest, false)).toBe('');
        
        // Other nodes should use their slugs
        expect(getUrlForNode(complexStructure[1], complexManifest, true)).toBe('about/index.html');
        expect(getUrlForNode(complexStructure[3], complexManifest, true)).toBe('projects/web/index.html');
      });

      test('preserves slug formatting', () => {
        const specialSlugs = [
          createNode('content/test.md', 'my-page'),
          createNode('content/test.md', 'my_page'),
          createNode('content/test.md', 'mypage'),
          createNode('content/test.md', 'my-page-123'),
          createNode('content/test.md', 'blog/2024/post')
        ];
        
        specialSlugs.forEach(node => {
          expect(getUrlForNode(node, manifest, true)).toBe(`${node.slug}/index.html`);
          expect(getUrlForNode(node, manifest, false)).toBe(node.slug);
        });
      });

      test('handles very long page numbers', () => {
        const aboutNode = sampleStructure[1];
        const largePage = 9999;
        
        expect(getUrlForNode(aboutNode, manifest, true, largePage)).toBe(`about/page/${largePage}/index.html`);
        expect(getUrlForNode(aboutNode, manifest, false, largePage)).toBe(`about/page/${largePage}`);
      });

      test('maintains consistent behavior across different node properties', () => {
        const nodeWithExtraProps: StructureNode = {
          type: 'page',
          title: 'Special Page',
          path: 'content/special.md',
          slug: 'special',
          menuTitle: 'Special Menu',
          navOrder: 5,
          customProperty: 'custom value'
        };
        
        expect(getUrlForNode(nodeWithExtraProps, manifest, true)).toBe('special/index.html');
        expect(getUrlForNode(nodeWithExtraProps, manifest, false)).toBe('special');
        expect(getUrlForNode(nodeWithExtraProps, manifest, true, 2)).toBe('special/page/2/index.html');
      });
    });

    describe('Performance and Consistency', () => {
      test('performs consistently with large structures', () => {
        const largeStructure = Array.from({ length: 1000 }, (_, i) =>
          createNode(`content/page${i}.md`, `page${i}`)
        );
        const largeManifest = createManifest(largeStructure);
        
        const start = performance.now();
        
        // Test first node (homepage)
        expect(getUrlForNode(largeStructure[0], largeManifest, true)).toBe('index.html');
        
        // Test random nodes
        expect(getUrlForNode(largeStructure[500], largeManifest, true)).toBe('page500/index.html');
        expect(getUrlForNode(largeStructure[999], largeManifest, true)).toBe('page999/index.html');
        
        const end = performance.now();
        expect(end - start).toBeLessThan(10); // Should be very fast
      });

      test('maintains referential transparency (pure function)', () => {
        const testNode = sampleStructure[1];
        
        // Multiple calls with same inputs should return same results
        const result1 = getUrlForNode(testNode, manifest, true, 2);
        const result2 = getUrlForNode(testNode, manifest, true, 2);
        const result3 = getUrlForNode(testNode, manifest, true, 2);
        
        expect(result1).toBe(result2);
        expect(result2).toBe(result3);
        expect(result1).toBe('about/page/2/index.html');
      });

      test('does not mutate input objects', () => {
        const originalNode = { ...sampleStructure[1] };
        const originalManifest = { ...manifest };
        
        getUrlForNode(sampleStructure[1], manifest, true, 5);
        
        expect(sampleStructure[1]).toEqual(originalNode);
        expect(manifest.siteId).toBe(originalManifest.siteId);
        expect(manifest.structure.length).toBe(originalManifest.structure.length);
      });
    });
  });
});

================================================================================

File: core/services/__tests__/navigationStructure.service.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import { generateNavLinks } from '../navigationStructure.service';
import type { LocalSiteData, StructureNode, Manifest, ParsedMarkdownFile, NavLinkItem, MarkdownFrontmatter } from '@/core/types';

// Mock the dependencies
jest.mock('../urlUtils.service', () => ({
  getUrlForNode: jest.fn()
}));

jest.mock('../relativePaths.service', () => ({
  getRelativePath: jest.fn()
}));

import { getUrlForNode } from '../urlUtils.service';
import { getRelativePath } from '../relativePaths.service';

const mockGetUrlForNode = getUrlForNode as jest.MockedFunction<typeof getUrlForNode>;
const mockGetRelativePath = getRelativePath as jest.MockedFunction<typeof getRelativePath>;

describe('navigationStructure.service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // Helper functions to create test data
  const createFrontmatter = (overrides: Partial<MarkdownFrontmatter> = {}): MarkdownFrontmatter => ({
    title: 'Default Title',
    layout: 'page',
    ...overrides
  });

  const createContentFile = (
    path: string, 
    frontmatter: Partial<MarkdownFrontmatter> = {}
  ): ParsedMarkdownFile => ({
    slug: path.replace('content/', '').replace('.md', ''),
    path,
    frontmatter: createFrontmatter(frontmatter),
    content: `# ${frontmatter.title || 'Default Title'}\n\nSample content.`
  });

  const createNode = (
    path: string, 
    title: string,
    navOrder?: number,
    menuTitle?: string,
    children?: StructureNode[]
  ): StructureNode => ({
    type: 'page',
    title,
    path,
    slug: path.replace('content/', '').replace('.md', ''),
    navOrder,
    menuTitle,
    children
  });

  const createManifest = (structure: StructureNode[]): Manifest => ({
    siteId: 'test-site',
    generatorVersion: '1.0.0',
    title: 'Test Site',
    description: 'A test site',
    theme: { name: 'default', config: {} },
    structure
  });

  const createSiteData = (
    structure: StructureNode[],
    contentFiles: ParsedMarkdownFile[]
  ): LocalSiteData => ({
    siteId: 'test-site',
    manifest: createManifest(structure),
    contentFiles
  });

  describe('generateNavLinks', () => {
    describe('Basic Navigation Generation', () => {
      test('generates navigation links for simple structure', () => {
        const structure = [
          createNode('content/home.md', 'Home', 1),
          createNode('content/about.md', 'About', 2),
          createNode('content/contact.md', 'Contact', 3)
        ];

        const contentFiles = [
          createContentFile('content/home.md', { title: 'Home' }),
          createContentFile('content/about.md', { title: 'About' }),
          createContentFile('content/contact.md', { title: 'Contact' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        mockGetUrlForNode
          .mockReturnValueOnce('') // Home
          .mockReturnValueOnce('about') // About
          .mockReturnValueOnce('contact'); // Contact

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result).toHaveLength(3);
        expect(result[0]).toEqual({
          href: '/site',
          label: 'Home',
          children: []
        });
        expect(result[1]).toEqual({
          href: '/site/about',
          label: 'About',
          children: []
        });
        expect(result[2]).toEqual({
          href: '/site/contact',
          label: 'Contact',
          children: []
        });
      });

      test('filters out nodes without navOrder', () => {
        const structure = [
          createNode('content/home.md', 'Home', 1),
          createNode('content/about.md', 'About'), // No navOrder
          createNode('content/contact.md', 'Contact', 3)
        ];

        const contentFiles = [
          createContentFile('content/home.md', { title: 'Home' }),
          createContentFile('content/about.md', { title: 'About' }),
          createContentFile('content/contact.md', { title: 'Contact' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        mockGetUrlForNode
          .mockReturnValueOnce('') // Home
          .mockReturnValueOnce('contact'); // Contact

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result).toHaveLength(2);
        expect(result[0].label).toBe('Home');
        expect(result[1].label).toBe('Contact');
      });

      test('sorts nodes by navOrder', () => {
        const structure = [
          createNode('content/contact.md', 'Contact', 30),
          createNode('content/home.md', 'Home', 10),
          createNode('content/about.md', 'About', 20)
        ];

        const contentFiles = [
          createContentFile('content/contact.md', { title: 'Contact' }),
          createContentFile('content/home.md', { title: 'Home' }),
          createContentFile('content/about.md', { title: 'About' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        mockGetUrlForNode
          .mockReturnValueOnce('') // Home
          .mockReturnValueOnce('about') // About
          .mockReturnValueOnce('contact'); // Contact

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result).toHaveLength(3);
        expect(result[0].label).toBe('Home'); // navOrder 10
        expect(result[1].label).toBe('About'); // navOrder 20
        expect(result[2].label).toBe('Contact'); // navOrder 30
      });

      test('uses menuTitle when available', () => {
        const structure = [
          createNode('content/about.md', 'About Us Page', 1, 'About'),
          createNode('content/contact.md', 'Contact Information', 2, 'Get in Touch')
        ];

        const contentFiles = [
          createContentFile('content/about.md', { title: 'About Us Page' }),
          createContentFile('content/contact.md', { title: 'Contact Information' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        mockGetUrlForNode
          .mockReturnValueOnce('about')
          .mockReturnValueOnce('contact');

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result[0].label).toBe('About'); // menuTitle, not title
        expect(result[1].label).toBe('Get in Touch'); // menuTitle, not title
      });

      test('falls back to title when menuTitle not available', () => {
        const structure = [
          createNode('content/home.md', 'Home Page', 1), // No menuTitle
          createNode('content/about.md', 'About', 2, 'About Us') // Has menuTitle
        ];

        const contentFiles = [
          createContentFile('content/home.md', { title: 'Home Page' }),
          createContentFile('content/about.md', { title: 'About' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        mockGetUrlForNode
          .mockReturnValueOnce('')
          .mockReturnValueOnce('about');

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result[0].label).toBe('Home Page'); // Uses title
        expect(result[1].label).toBe('About Us'); // Uses menuTitle
      });
    });

    describe('Nested Navigation', () => {
      test('generates nested navigation structure', () => {
        const structure = [
          createNode('content/home.md', 'Home', 1),
          createNode('content/products.md', 'Products', 2, undefined, [
            createNode('content/products/software.md', 'Software', 1),
            createNode('content/products/hardware.md', 'Hardware', 2)
          ])
        ];

        const contentFiles = [
          createContentFile('content/home.md', { title: 'Home' }),
          createContentFile('content/products.md', { title: 'Products' }),
          createContentFile('content/products/software.md', { title: 'Software' }),
          createContentFile('content/products/hardware.md', { title: 'Hardware' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        mockGetUrlForNode
          .mockReturnValueOnce('')
          .mockReturnValueOnce('products')
          .mockReturnValueOnce('products/software')
          .mockReturnValueOnce('products/hardware');

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result).toHaveLength(2);
        expect(result[0].label).toBe('Home');
        expect(result[0].children).toEqual([]);

        expect(result[1].label).toBe('Products');
        expect(result[1].children).toHaveLength(2);
        expect(result[1].children[0]).toEqual({
          href: '/site/products/software',
          label: 'Software',
          children: []
        });
        expect(result[1].children[1]).toEqual({
          href: '/site/products/hardware',
          label: 'Hardware',
          children: []
        });
      });

      test('filters children without navOrder', () => {
        const structure = [
          createNode('content/products.md', 'Products', 1, undefined, [
            createNode('content/products/software.md', 'Software', 1),
            createNode('content/products/services.md', 'Services'), // No navOrder
            createNode('content/products/hardware.md', 'Hardware', 2)
          ])
        ];

        const contentFiles = [
          createContentFile('content/products.md', { title: 'Products' }),
          createContentFile('content/products/software.md', { title: 'Software' }),
          createContentFile('content/products/services.md', { title: 'Services' }),
          createContentFile('content/products/hardware.md', { title: 'Hardware' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        mockGetUrlForNode
          .mockReturnValueOnce('products')
          .mockReturnValueOnce('products/software')
          .mockReturnValueOnce('products/hardware');

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result[0].children).toHaveLength(2); // services filtered out
        expect(result[0].children[0].label).toBe('Software');
        expect(result[0].children[1].label).toBe('Hardware');
      });

      test('handles deeply nested structures', () => {
        const structure = [
          createNode('content/docs.md', 'Documentation', 1, undefined, [
            createNode('content/docs/api.md', 'API', 1, undefined, [
              createNode('content/docs/api/auth.md', 'Authentication', 1),
              createNode('content/docs/api/endpoints.md', 'Endpoints', 2)
            ])
          ])
        ];

        const contentFiles = [
          createContentFile('content/docs.md', { title: 'Documentation' }),
          createContentFile('content/docs/api.md', { title: 'API' }),
          createContentFile('content/docs/api/auth.md', { title: 'Authentication' }),
          createContentFile('content/docs/api/endpoints.md', { title: 'Endpoints' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        mockGetUrlForNode
          .mockReturnValueOnce('docs')
          .mockReturnValueOnce('docs/api')
          .mockReturnValueOnce('docs/api/auth')
          .mockReturnValueOnce('docs/api/endpoints');

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result).toHaveLength(1);
        expect(result[0].label).toBe('Documentation');
        expect(result[0].children).toHaveLength(1);
        expect(result[0].children[0].label).toBe('API');
        expect(result[0].children[0].children).toHaveLength(2);
        expect(result[0].children[0].children[0].label).toBe('Authentication');
        expect(result[0].children[0].children[1].label).toBe('Endpoints');
      });
    });

    describe('Collection Page Handling', () => {
      test('excludes children of collection pages from navigation', () => {
        const structure = [
          createNode('content/blog.md', 'Blog', 1, undefined, [
            createNode('content/blog/post1.md', 'Post 1', 1),
            createNode('content/blog/post2.md', 'Post 2', 2)
          ])
        ];

        const contentFiles = [
          createContentFile('content/blog.md', { 
            title: 'Blog',
            collection: { sort_by: 'date', sort_order: 'desc' }
          }),
          createContentFile('content/blog/post1.md', { title: 'Post 1' }),
          createContentFile('content/blog/post2.md', { title: 'Post 2' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        mockGetUrlForNode.mockReturnValueOnce('blog');

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result).toHaveLength(1);
        expect(result[0].label).toBe('Blog');
        expect(result[0].children).toEqual([]); // Children excluded because it's a collection
      });

      test('includes children of non-collection pages', () => {
        const structure = [
          createNode('content/services.md', 'Services', 1, undefined, [
            createNode('content/services/web.md', 'Web Development', 1),
            createNode('content/services/mobile.md', 'Mobile Apps', 2)
          ])
        ];

        const contentFiles = [
          createContentFile('content/services.md', { 
            title: 'Services'
            // No collection property
          }),
          createContentFile('content/services/web.md', { title: 'Web Development' }),
          createContentFile('content/services/mobile.md', { title: 'Mobile Apps' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        mockGetUrlForNode
          .mockReturnValueOnce('services')
          .mockReturnValueOnce('services/web')
          .mockReturnValueOnce('services/mobile');

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result[0].children).toHaveLength(2); // Children included
        expect(result[0].children[0].label).toBe('Web Development');
        expect(result[0].children[1].label).toBe('Mobile Apps');
      });
    });

    describe('URL Generation Modes', () => {
      test('generates preview mode URLs correctly', () => {
        const structure = [
          createNode('content/home.md', 'Home', 1),
          createNode('content/about.md', 'About', 2)
        ];

        const contentFiles = [
          createContentFile('content/home.md', { title: 'Home' }),
          createContentFile('content/about.md', { title: 'About' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/mysite' };

        mockGetUrlForNode
          .mockReturnValueOnce('') // Home returns empty string
          .mockReturnValueOnce('about');

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result[0].href).toBe('/mysite'); // Empty URL becomes root
        expect(result[1].href).toBe('/mysite/about');
      });

      test('generates export mode URLs correctly', () => {
        const structure = [
          createNode('content/home.md', 'Home', 1),
          createNode('content/about.md', 'About', 2)
        ];

        const contentFiles = [
          createContentFile('content/home.md', { title: 'Home' }),
          createContentFile('content/about.md', { title: 'About' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: true, siteRootPath: '/export' };

        mockGetUrlForNode
          .mockReturnValueOnce('index.html')
          .mockReturnValueOnce('about/index.html');

        mockGetRelativePath
          .mockReturnValueOnce('./index.html')
          .mockReturnValueOnce('./about/index.html');

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result[0].href).toBe('./index.html');
        expect(result[1].href).toBe('./about/index.html');

        expect(mockGetRelativePath).toHaveBeenCalledWith('content/current.md', 'index.html');
        expect(mockGetRelativePath).toHaveBeenCalledWith('content/current.md', 'about/index.html');
      });

      test('handles root path variations in preview mode', () => {
        const structure = [
          createNode('content/about.md', 'About', 1)
        ];

        const contentFiles = [
          createContentFile('content/about.md', { title: 'About' })
        ];

        const siteData = createSiteData(structure, contentFiles);

        // Test empty root path
        mockGetUrlForNode.mockReturnValue('about');
        let options = { isExport: false, siteRootPath: '' };
        let result = generateNavLinks(siteData, 'content/current.md', options);
        expect(result[0].href).toBe('/about');

        // Test root path with slash  
        mockGetUrlForNode.mockReturnValue('about');
        options = { isExport: false, siteRootPath: '/' };
        result = generateNavLinks(siteData, 'content/current.md', options);
        expect(result[0].href).toBe('//about'); // "/" + "/about" = "//about"

        // Test root path with directory
        mockGetUrlForNode.mockReturnValue('about');
        options = { isExport: false, siteRootPath: '/site' };
        result = generateNavLinks(siteData, 'content/current.md', options);
        expect(result[0].href).toBe('/site/about');
      });

      test('handles homepage URLs in preview mode', () => {
        const structure = [
          createNode('content/home.md', 'Home', 1)
        ];

        const contentFiles = [
          createContentFile('content/home.md', { title: 'Home' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        mockGetUrlForNode.mockReturnValue(''); // Homepage returns empty string

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result[0].href).toBe('/site'); // Empty string becomes site root
      });
    });

    describe('Edge Cases and Error Handling', () => {
      test('handles empty structure', () => {
        const siteData = createSiteData([], []);
        const options = { isExport: false, siteRootPath: '/site' };

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result).toEqual([]);
      });

      test('handles structure with no navigation items', () => {
        const structure = [
          createNode('content/page1.md', 'Page 1'), // No navOrder
          createNode('content/page2.md', 'Page 2') // No navOrder
        ];

        const contentFiles = [
          createContentFile('content/page1.md', { title: 'Page 1' }),
          createContentFile('content/page2.md', { title: 'Page 2' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result).toEqual([]);
      });

      test('handles missing content files gracefully', () => {
        const structure = [
          createNode('content/home.md', 'Home', 1),
          createNode('content/missing.md', 'Missing', 2)
        ];

        const contentFiles = [
          createContentFile('content/home.md', { title: 'Home' })
          // Missing content file for missing.md
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        mockGetUrlForNode
          .mockReturnValueOnce('')
          .mockReturnValueOnce('missing');

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result).toHaveLength(2);
        expect(result[0].label).toBe('Home');
        expect(result[1].label).toBe('Missing'); // Still includes the node
        expect(result[1].children).toEqual([]); // No children since no collection
      });

      test('handles nodes with zero navOrder', () => {
        const structure = [
          createNode('content/first.md', 'First', 0),
          createNode('content/second.md', 'Second', 1)
        ];

        const contentFiles = [
          createContentFile('content/first.md', { title: 'First' }),
          createContentFile('content/second.md', { title: 'Second' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        mockGetUrlForNode
          .mockReturnValueOnce('first')
          .mockReturnValueOnce('second');

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result).toHaveLength(2);
        expect(result[0].label).toBe('First'); // navOrder 0 comes first
        expect(result[1].label).toBe('Second');
      });

      test('handles duplicate navOrder values', () => {
        const structure = [
          createNode('content/alpha.md', 'Alpha', 1),
          createNode('content/beta.md', 'Beta', 1), // Same navOrder
          createNode('content/gamma.md', 'Gamma', 1) // Same navOrder
        ];

        const contentFiles = [
          createContentFile('content/alpha.md', { title: 'Alpha' }),
          createContentFile('content/beta.md', { title: 'Beta' }),
          createContentFile('content/gamma.md', { title: 'Gamma' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        mockGetUrlForNode
          .mockReturnValueOnce('alpha')
          .mockReturnValueOnce('beta')
          .mockReturnValueOnce('gamma');

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result).toHaveLength(3);
        // Order should be stable (original array order)
        expect(result[0].label).toBe('Alpha');
        expect(result[1].label).toBe('Beta');
        expect(result[2].label).toBe('Gamma');
      });

      test('preserves all required properties in NavLinkItem', () => {
        const structure = [
          createNode('content/test.md', 'Test Page', 1, 'Test Menu')
        ];

        const contentFiles = [
          createContentFile('content/test.md', { title: 'Test Page' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        mockGetUrlForNode.mockReturnValue('test');

        const result = generateNavLinks(siteData, 'content/current.md', options);

        expect(result[0]).toHaveProperty('href');
        expect(result[0]).toHaveProperty('label');
        expect(result[0]).toHaveProperty('children');
        expect(typeof result[0].href).toBe('string');
        expect(typeof result[0].label).toBe('string');
        expect(Array.isArray(result[0].children)).toBe(true);
      });
    });

    describe('Performance and Consistency', () => {
      test('performs well with large navigation structures', () => {
        const largeStructure = Array.from({ length: 100 }, (_, i) =>
          createNode(`content/page${i}.md`, `Page ${i}`, i + 1)
        );

        const largeContentFiles = largeStructure.map(node =>
          createContentFile(node.path, { title: node.title })
        );

        const siteData = createSiteData(largeStructure, largeContentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        // Mock all URL calls
        mockGetUrlForNode.mockImplementation((node) => node.slug);

        const start = performance.now();
        const result = generateNavLinks(siteData, 'content/current.md', options);
        const end = performance.now();

        expect(result).toHaveLength(100);
        expect(end - start).toBeLessThan(50); // Should be fast
      });

      test('maintains referential transparency', () => {
        const structure = [
          createNode('content/test.md', 'Test', 1)
        ];

        const contentFiles = [
          createContentFile('content/test.md', { title: 'Test' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        mockGetUrlForNode.mockReturnValue('test');

        // Multiple calls should return consistent results
        const result1 = generateNavLinks(siteData, 'content/current.md', options);
        const result2 = generateNavLinks(siteData, 'content/current.md', options);
        const result3 = generateNavLinks(siteData, 'content/current.md', options);

        expect(result1).toEqual(result2);
        expect(result2).toEqual(result3);
      });

      test('does not mutate input data', () => {
        const structure = [
          createNode('content/test.md', 'Test', 1)
        ];

        const contentFiles = [
          createContentFile('content/test.md', { title: 'Test' })
        ];

        const siteData = createSiteData(structure, contentFiles);
        const options = { isExport: false, siteRootPath: '/site' };

        const originalStructure = JSON.parse(JSON.stringify(structure));
        const originalContentFiles = JSON.parse(JSON.stringify(contentFiles));

        mockGetUrlForNode.mockReturnValue('test');

        generateNavLinks(siteData, 'content/current.md', options);

        expect(siteData.manifest.structure).toEqual(originalStructure);
        expect(siteData.contentFiles).toEqual(originalContentFiles);
      });
    });
  });
});

================================================================================

File: core/services/__tests__/pageResolver.service.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import { resolvePageContent } from '../pageResolver.service';
import type { 
  LocalSiteData, 
  ParsedMarkdownFile, 
  MarkdownFrontmatter, 
  StructureNode, 
  Manifest,
  PageType,
  CollectionConfig,
  PageResolutionResult
} from '@/core/types';

// Mock the fileTree service functions
jest.mock('../fileTree.service', () => ({
  findNodeByPath: jest.fn(),
  findChildNodes: jest.fn()
}));

// Mock the urlUtils service
jest.mock('../urlUtils.service', () => ({
  getUrlForNode: jest.fn()
}));

import { findNodeByPath, findChildNodes } from '../fileTree.service';
import { getUrlForNode } from '../urlUtils.service';

const mockFindNodeByPath = findNodeByPath as jest.MockedFunction<typeof findNodeByPath>;
const mockFindChildNodes = findChildNodes as jest.MockedFunction<typeof findChildNodes>;
const mockGetUrlForNode = getUrlForNode as jest.MockedFunction<typeof getUrlForNode>;

describe('pageResolver.service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // Helper functions to create test data
  const createFrontmatter = (overrides: Partial<MarkdownFrontmatter> = {}): MarkdownFrontmatter => ({
    title: 'Default Title',
    layout: 'page',
    ...overrides
  });

  const createContentFile = (
    path: string, 
    frontmatter: Partial<MarkdownFrontmatter> = {}
  ): ParsedMarkdownFile => ({
    slug: path.replace('content/', '').replace('.md', ''),
    path,
    frontmatter: createFrontmatter(frontmatter),
    content: `# ${frontmatter.title || 'Default Title'}\n\nSample content.`
  });

  const createNode = (path: string, title?: string): StructureNode => ({
    type: 'page',
    title: title || path.replace('content/', '').replace('.md', ''),
    path,
    slug: path.replace('content/', '').replace('.md', '')
  });

  const createManifest = (structure: StructureNode[]): Manifest => ({
    siteId: 'test-site',
    generatorVersion: '1.0.0',
    title: 'Test Site',
    description: 'A test site',
    theme: { name: 'default', config: {} },
    structure
  });

  const createSiteData = (
    structure: StructureNode[],
    contentFiles: ParsedMarkdownFile[]
  ): LocalSiteData => ({
    siteId: 'test-site',
    manifest: createManifest(structure),
    contentFiles
  });

  describe('resolvePageContent', () => {
    describe('Homepage Resolution', () => {
      test('resolves homepage when slug array is empty', () => {
        const homepageFile = createContentFile('content/home.md', { 
          title: 'Welcome Home',
          homepage: true 
        });
        const homeNode = createNode('content/home.md', 'Welcome Home');
        
        const siteData = createSiteData([homeNode], [homepageFile]);
        
        mockFindNodeByPath.mockReturnValue(homeNode);
        
        const result = resolvePageContent(siteData, [], 1);
        
        expect(result.type).toBe(PageType.SinglePage);
        if (result.type === PageType.SinglePage) {
          expect(result.pageTitle).toBe('Welcome Home');
          expect(result.contentFile).toBe(homepageFile);
          expect(result.layoutPath).toBe('page');
        }
        
        expect(mockFindNodeByPath).toHaveBeenCalledWith(siteData.manifest.structure, 'content/home.md');
      });

      test('resolves homepage when slug array has empty string', () => {
        const homepageFile = createContentFile('content/index.md', { 
          title: 'Home Page',
          homepage: true 
        });
        const homeNode = createNode('content/index.md', 'Home Page');
        
        const siteData = createSiteData([homeNode], [homepageFile]);
        
        mockFindNodeByPath.mockReturnValue(homeNode);
        
        const result = resolvePageContent(siteData, [''], 1);
        
        expect(result.type).toBe(PageType.SinglePage);
        if (result.type === PageType.SinglePage) {
          expect(result.pageTitle).toBe('Home Page');
          expect(result.contentFile).toBe(homepageFile);
        }
      });

      test('returns not found when no homepage is designated', () => {
        const normalFile = createContentFile('content/page.md', { 
          title: 'Normal Page',
          homepage: false 
        });
        const normalNode = createNode('content/page.md', 'Normal Page');
        
        const siteData = createSiteData([normalNode], [normalFile]);
        
        const result = resolvePageContent(siteData, [], 1);
        
        expect(result.type).toBe(PageType.NotFound);
        if (result.type === PageType.NotFound) {
          expect(result.errorMessage).toBe('No homepage has been designated for this site.');
        }
      });

      test('handles multiple files where only one is homepage', () => {
        const homepageFile = createContentFile('content/home.md', { 
          title: 'Homepage',
          homepage: true 
        });
        const aboutFile = createContentFile('content/about.md', { 
          title: 'About',
          homepage: false 
        });
        const blogFile = createContentFile('content/blog.md', { 
          title: 'Blog' 
          // No homepage property
        });
        
        const homeNode = createNode('content/home.md', 'Homepage');
        const siteData = createSiteData([homeNode], [homepageFile, aboutFile, blogFile]);
        
        mockFindNodeByPath.mockReturnValue(homeNode);
        
        const result = resolvePageContent(siteData, [], 1);
        
        expect(result.type).toBe(PageType.SinglePage);
        if (result.type === PageType.SinglePage) {
          expect(result.contentFile).toBe(homepageFile);
        }
      });
    });

    describe('Regular Page Resolution', () => {
      test('resolves regular page by slug', () => {
        const aboutFile = createContentFile('content/about.md', { 
          title: 'About Us',
          layout: 'page' 
        });
        const aboutNode = createNode('content/about.md', 'About Us');
        
        const siteData = createSiteData([aboutNode], [aboutFile]);
        
        mockFindNodeByPath.mockReturnValue(aboutNode);
        
        const result = resolvePageContent(siteData, ['about'], 1);
        
        expect(result.type).toBe(PageType.SinglePage);
        if (result.type === PageType.SinglePage) {
          expect(result.pageTitle).toBe('About Us');
          expect(result.contentFile).toBe(aboutFile);
          expect(result.layoutPath).toBe('page');
        }
        
        expect(mockFindNodeByPath).toHaveBeenCalledWith(siteData.manifest.structure, 'content/about.md');
      });

      test('resolves nested page by slug array', () => {
        const postFile = createContentFile('content/blog/post1.md', { 
          title: 'First Post',
          layout: 'post' 
        });
        const postNode = createNode('content/blog/post1.md', 'First Post');
        
        const siteData = createSiteData([postNode], [postFile]);
        
        mockFindNodeByPath.mockReturnValue(postNode);
        
        const result = resolvePageContent(siteData, ['blog', 'post1'], 1);
        
        expect(result.type).toBe(PageType.SinglePage);
        if (result.type === PageType.SinglePage) {
          expect(result.pageTitle).toBe('First Post');
          expect(result.contentFile).toBe(postFile);
          expect(result.layoutPath).toBe('post');
        }
        
        expect(mockFindNodeByPath).toHaveBeenCalledWith(siteData.manifest.structure, 'content/blog/post1.md');
      });

      test('uses default layout when not specified', () => {
        const pageFile = createContentFile('content/page.md', { 
          title: 'Test Page'
          // No layout specified
        });
        const pageNode = createNode('content/page.md', 'Test Page');
        
        const siteData = createSiteData([pageNode], [pageFile]);
        
        mockFindNodeByPath.mockReturnValue(pageNode);
        
        const result = resolvePageContent(siteData, ['page'], 1);
        
        expect(result.type).toBe(PageType.SinglePage);
        if (result.type === PageType.SinglePage) {
          expect(result.layoutPath).toBe('page'); // DEFAULT_PAGE_LAYOUT_PATH
        }
      });

      test('returns not found when node not in structure', () => {
        const siteData = createSiteData([], []);
        
        mockFindNodeByPath.mockReturnValue(undefined);
        
        const result = resolvePageContent(siteData, ['nonexistent'], 1);
        
        expect(result.type).toBe(PageType.NotFound);
        if (result.type === PageType.NotFound) {
          expect(result.errorMessage).toBe('No page found in site structure for path: content/nonexistent.md');
        }
      });

      test('returns not found when content file is missing', () => {
        const pageNode = createNode('content/missing.md', 'Missing Page');
        const siteData = createSiteData([pageNode], []); // No content files
        
        mockFindNodeByPath.mockReturnValue(pageNode);
        
        const result = resolvePageContent(siteData, ['missing'], 1);
        
        expect(result.type).toBe(PageType.NotFound);
        if (result.type === PageType.NotFound) {
          expect(result.errorMessage).toBe('Manifest references "content/missing.md" but its content file is missing.');
        }
      });
    });

    describe('Collection Page Resolution', () => {
      test('resolves collection page without pagination', () => {
        const collectionConfig: CollectionConfig = {
          sort_by: 'title',
          sort_order: 'asc'
        };
        
        const blogFile = createContentFile('content/blog.md', { 
          title: 'Blog',
          layout: 'collection',
          collection: collectionConfig
        });
        const blogNode = createNode('content/blog.md', 'Blog');
        
        const post1 = createContentFile('content/blog/post1.md', { title: 'Alpha Post' });
        const post2 = createContentFile('content/blog/post2.md', { title: 'Beta Post' });
        const post3 = createContentFile('content/blog/post3.md', { title: 'Gamma Post' });
        
        const childNodes = [
          createNode('content/blog/post1.md'),
          createNode('content/blog/post2.md'),
          createNode('content/blog/post3.md')
        ];
        
        const siteData = createSiteData([blogNode], [blogFile, post1, post2, post3]);
        
        mockFindNodeByPath.mockReturnValue(blogNode);
        mockFindChildNodes.mockReturnValue(childNodes);
        
        const result = resolvePageContent(siteData, ['blog'], 1);
        
        expect(result.type).toBe(PageType.SinglePage);
        if (result.type === PageType.SinglePage) {
          expect(result.pageTitle).toBe('Blog');
          expect(result.contentFile).toBe(blogFile);
          expect(result.collectionItems).toHaveLength(3);
          expect(result.collectionItems![0].frontmatter.title).toBe('Alpha Post');
          expect(result.collectionItems![1].frontmatter.title).toBe('Beta Post');
          expect(result.collectionItems![2].frontmatter.title).toBe('Gamma Post');
          expect(result.pagination).toBeUndefined();
        }
        
        expect(mockFindChildNodes).toHaveBeenCalledWith(siteData.manifest.structure, 'content/blog.md');
      });

      test('resolves collection page with pagination', () => {
        const collectionConfig: CollectionConfig = {
          sort_by: 'date',
          sort_order: 'desc',
          items_per_page: 2
        };
        
        const blogFile = createContentFile('content/blog.md', { 
          title: 'Blog',
          layout: 'collection',
          collection: collectionConfig
        });
        const blogNode = createNode('content/blog.md', 'Blog');
        
        const post1 = createContentFile('content/blog/post1.md', { 
          title: 'Post 1', 
          date: '2024-01-03' 
        });
        const post2 = createContentFile('content/blog/post2.md', { 
          title: 'Post 2', 
          date: '2024-01-02' 
        });
        const post3 = createContentFile('content/blog/post3.md', { 
          title: 'Post 3', 
          date: '2024-01-01' 
        });
        
        const childNodes = [
          createNode('content/blog/post1.md'),
          createNode('content/blog/post2.md'),
          createNode('content/blog/post3.md')
        ];
        
        const siteData = createSiteData([blogNode], [blogFile, post1, post2, post3]);
        
        mockFindNodeByPath.mockReturnValue(blogNode);
        mockFindChildNodes.mockReturnValue(childNodes);
        mockGetUrlForNode.mockReturnValue('blog');
        
        const result = resolvePageContent(siteData, ['blog'], 1);
        
        expect(result.type).toBe(PageType.SinglePage);
        if (result.type === PageType.SinglePage) {
          expect(result.collectionItems).toHaveLength(2); // items_per_page = 2
          expect(result.collectionItems![0].frontmatter.title).toBe('Post 1'); // Most recent
          expect(result.collectionItems![1].frontmatter.title).toBe('Post 2');
          
          expect(result.pagination).toBeDefined();
          expect(result.pagination!.currentPage).toBe(1);
          expect(result.pagination!.totalPages).toBe(2);
          expect(result.pagination!.totalItems).toBe(3);
          expect(result.pagination!.hasPrevPage).toBe(false);
          expect(result.pagination!.hasNextPage).toBe(true);
          expect(result.pagination!.nextPageUrl).toBe('/blog/page/2');
        }
      });

      test('resolves collection page second page', () => {
        const collectionConfig: CollectionConfig = {
          sort_by: 'title',
          sort_order: 'asc',
          items_per_page: 2
        };
        
        const blogFile = createContentFile('content/blog.md', { 
          title: 'Blog',
          collection: collectionConfig
        });
        const blogNode = createNode('content/blog.md', 'Blog');
        
        const post1 = createContentFile('content/blog/post1.md', { title: 'Alpha' });
        const post2 = createContentFile('content/blog/post2.md', { title: 'Beta' });
        const post3 = createContentFile('content/blog/post3.md', { title: 'Gamma' });
        
        const childNodes = [
          createNode('content/blog/post1.md'),
          createNode('content/blog/post2.md'),
          createNode('content/blog/post3.md')
        ];
        
        const siteData = createSiteData([blogNode], [blogFile, post1, post2, post3]);
        
        mockFindNodeByPath.mockReturnValue(blogNode);
        mockFindChildNodes.mockReturnValue(childNodes);
        mockGetUrlForNode.mockReturnValue('blog');
        
        const result = resolvePageContent(siteData, ['blog'], 2);
        
        expect(result.type).toBe(PageType.SinglePage);
        if (result.type === PageType.SinglePage) {
          expect(result.collectionItems).toHaveLength(1); // Only 1 item on page 2
          expect(result.collectionItems![0].frontmatter.title).toBe('Gamma');
          
          expect(result.pagination!.currentPage).toBe(2);
          expect(result.pagination!.hasPrevPage).toBe(true);
          expect(result.pagination!.hasNextPage).toBe(false);
          expect(result.pagination!.prevPageUrl).toBe('/blog');
        }
      });

      test('handles collection with no child nodes', () => {
        const collectionConfig: CollectionConfig = {
          sort_by: 'date',
          sort_order: 'desc'
        };
        
        const blogFile = createContentFile('content/blog.md', { 
          title: 'Empty Blog',
          collection: collectionConfig
        });
        const blogNode = createNode('content/blog.md', 'Empty Blog');
        
        const siteData = createSiteData([blogNode], [blogFile]);
        
        mockFindNodeByPath.mockReturnValue(blogNode);
        mockFindChildNodes.mockReturnValue([]); // No children
        
        const result = resolvePageContent(siteData, ['blog'], 1);
        
        expect(result.type).toBe(PageType.SinglePage);
        if (result.type === PageType.SinglePage) {
          expect(result.collectionItems).toEqual([]);
          expect(result.pagination).toBeUndefined();
        }
      });

      test('handles collection sorting by different fields', () => {
        const collectionConfig: CollectionConfig = {
          sort_by: 'priority',
          sort_order: 'desc'
        };
        
        const blogFile = createContentFile('content/blog.md', { 
          title: 'Blog',
          collection: collectionConfig
        });
        const blogNode = createNode('content/blog.md', 'Blog');
        
        const post1 = createContentFile('content/blog/post1.md', { title: 'Post 1', priority: 1 });
        const post2 = createContentFile('content/blog/post2.md', { title: 'Post 2', priority: 3 });
        const post3 = createContentFile('content/blog/post3.md', { title: 'Post 3', priority: 2 });
        
        const childNodes = [
          createNode('content/blog/post1.md'),
          createNode('content/blog/post2.md'),
          createNode('content/blog/post3.md')
        ];
        
        const siteData = createSiteData([blogNode], [blogFile, post1, post2, post3]);
        
        mockFindNodeByPath.mockReturnValue(blogNode);
        mockFindChildNodes.mockReturnValue(childNodes);
        
        const result = resolvePageContent(siteData, ['blog'], 1);
        
        expect(result.type).toBe(PageType.SinglePage);
        if (result.type === PageType.SinglePage) {
          expect(result.collectionItems![0].frontmatter.priority).toBe(3);
          expect(result.collectionItems![1].frontmatter.priority).toBe(2);
          expect(result.collectionItems![2].frontmatter.priority).toBe(1);
        }
      });

      test('handles collection pagination edge cases', () => {
        const collectionConfig: CollectionConfig = {
          items_per_page: 5
        };
        
        const blogFile = createContentFile('content/blog.md', { 
          title: 'Blog',
          collection: collectionConfig
        });
        const blogNode = createNode('content/blog.md', 'Blog');
        
        const siteData = createSiteData([blogNode], [blogFile]);
        
        mockFindNodeByPath.mockReturnValue(blogNode);
        mockFindChildNodes.mockReturnValue([]);
        mockGetUrlForNode.mockReturnValue('blog');
        
        // Test page number beyond available pages
        const result = resolvePageContent(siteData, ['blog'], 10);
        
        expect(result.type).toBe(PageType.SinglePage);
        if (result.type === PageType.SinglePage) {
          expect(result.pagination!.currentPage).toBe(1); // Should clamp to valid range
          expect(result.pagination!.totalPages).toBe(0); // No items, so 0 pages
        }
      });
    });

    describe('Error Handling and Edge Cases', () => {
      test('handles site data without content files', () => {
        const siteData = createSiteData([], undefined as any);
        
        const result = resolvePageContent(siteData, ['test'], 1);
        
        expect(result.type).toBe(PageType.NotFound);
      });

      test('handles invalid page numbers', () => {
        const pageFile = createContentFile('content/page.md', { title: 'Test Page' });
        const pageNode = createNode('content/page.md', 'Test Page');
        const siteData = createSiteData([pageNode], [pageFile]);
        
        mockFindNodeByPath.mockReturnValue(pageNode);
        
        // Test negative page number
        const result1 = resolvePageContent(siteData, ['page'], -1);
        expect(result1.type).toBe(PageType.SinglePage);
        
        // Test zero page number
        const result2 = resolvePageContent(siteData, ['page'], 0);
        expect(result2.type).toBe(PageType.SinglePage);
      });

      test('handles collection with invalid sort data', () => {
        const collectionConfig: CollectionConfig = {
          sort_by: 'date',
          sort_order: 'desc'
        };
        
        const blogFile = createContentFile('content/blog.md', { 
          title: 'Blog',
          collection: collectionConfig
        });
        const blogNode = createNode('content/blog.md', 'Blog');
        
        const post1 = createContentFile('content/blog/post1.md', { 
          title: 'Post 1', 
          date: 'invalid-date' 
        });
        const post2 = createContentFile('content/blog/post2.md', { 
          title: 'Post 2'
          // No date property
        });
        
        const childNodes = [
          createNode('content/blog/post1.md'),
          createNode('content/blog/post2.md')
        ];
        
        const siteData = createSiteData([blogNode], [blogFile, post1, post2]);
        
        mockFindNodeByPath.mockReturnValue(blogNode);
        mockFindChildNodes.mockReturnValue(childNodes);
        
        const result = resolvePageContent(siteData, ['blog'], 1);
        
        expect(result.type).toBe(PageType.SinglePage);
        if (result.type === PageType.SinglePage) {
          expect(result.collectionItems).toHaveLength(2);
          // Should handle gracefully without crashing
        }
      });

      test('handles very deep slug arrays', () => {
        const deepSlug = ['level1', 'level2', 'level3', 'level4', 'level5', 'page'];
        const deepFile = createContentFile('content/level1/level2/level3/level4/level5/page.md', { 
          title: 'Deep Page' 
        });
        const deepNode = createNode('content/level1/level2/level3/level4/level5/page.md', 'Deep Page');
        
        const siteData = createSiteData([deepNode], [deepFile]);
        
        mockFindNodeByPath.mockReturnValue(deepNode);
        
        const result = resolvePageContent(siteData, deepSlug, 1);
        
        expect(result.type).toBe(PageType.SinglePage);
        if (result.type === PageType.SinglePage) {
          expect(result.pageTitle).toBe('Deep Page');
        }
        
        expect(mockFindNodeByPath).toHaveBeenCalledWith(
          siteData.manifest.structure, 
          'content/level1/level2/level3/level4/level5/page.md'
        );
      });

      test('preserves all frontmatter properties in result', () => {
        const richFrontmatter = {
          title: 'Rich Page',
          layout: 'special',
          author: 'John Doe',
          tags: ['tag1', 'tag2'],
          customProperty: 'custom value',
          published: true
        };
        
        const pageFile = createContentFile('content/rich.md', richFrontmatter);
        const pageNode = createNode('content/rich.md', 'Rich Page');
        const siteData = createSiteData([pageNode], [pageFile]);
        
        mockFindNodeByPath.mockReturnValue(pageNode);
        
        const result = resolvePageContent(siteData, ['rich'], 1);
        
        expect(result.type).toBe(PageType.SinglePage);
        if (result.type === PageType.SinglePage) {
          expect(result.contentFile.frontmatter.author).toBe('John Doe');
          expect(result.contentFile.frontmatter.tags).toEqual(['tag1', 'tag2']);
          expect(result.contentFile.frontmatter.customProperty).toBe('custom value');
          expect(result.contentFile.frontmatter.published).toBe(true);
        }
      });
    });
  });
});

================================================================================

File: core/services/__tests__/fileTree.service.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import {
  flattenTree,
  buildTree,
  flattenStructure,
  findNodeByPath,
  findChildNodes,
  findAndRemoveNode,
  updatePathsRecursively,
  getNodeDepth,
  getDescendantIds,
  FlattenedNode
} from '../fileTree.service';
import { StructureNode, ParsedMarkdownFile, MarkdownFrontmatter } from '@/core/types';

describe('fileTree.service', () => {
  // Helper function to create mock content files
  const createContentFile = (path: string, title: string, layout = 'page'): ParsedMarkdownFile => ({
    slug: path.replace(/^content\//, '').replace(/\.md$/, ''),
    path,
    frontmatter: {
      title,
      layout
    } as MarkdownFrontmatter,
    content: `# ${title}\n\nTest content for ${title}.`
  });

  // Helper function to create mock structure nodes
  const createNode = (path: string, title: string, children?: StructureNode[]): StructureNode => ({
    type: 'page',
    title,
    path,
    slug: path.replace(/^content\//, '').replace(/\.md$/, ''),
    children
  });

  // Sample data for testing
  const sampleStructure: StructureNode[] = [
    createNode('content/home.md', 'Home'),
    createNode('content/about.md', 'About'),
    createNode('content/blog/index.md', 'Blog', [
      createNode('content/blog/post1.md', 'First Post'),
      createNode('content/blog/post2.md', 'Second Post'),
      createNode('content/blog/category/index.md', 'Category', [
        createNode('content/blog/category/nested-post.md', 'Nested Post')
      ])
    ]),
    createNode('content/projects/index.md', 'Projects', [
      createNode('content/projects/project1.md', 'Project One'),
      createNode('content/projects/project2.md', 'Project Two')
    ])
  ];

  const sampleContentFiles: ParsedMarkdownFile[] = [
    createContentFile('content/home.md', 'Home'),
    createContentFile('content/about.md', 'About'),
    createContentFile('content/blog/index.md', 'Blog'),
    createContentFile('content/blog/post1.md', 'First Post'),
    createContentFile('content/blog/post2.md', 'Second Post'),
    createContentFile('content/blog/category/index.md', 'Category'),
    createContentFile('content/blog/category/nested-post.md', 'Nested Post'),
    createContentFile('content/projects/index.md', 'Projects'),
    createContentFile('content/projects/project1.md', 'Project One'),
    createContentFile('content/projects/project2.md', 'Project Two')
  ];

  describe('flattenTree', () => {
    test('flattens a nested structure correctly', () => {
      const result = flattenTree(sampleStructure, sampleContentFiles);

      expect(result).toHaveLength(10);
      
      // Check root level nodes
      expect(result[0]).toMatchObject({
        path: 'content/home.md',
        title: 'Home',
        parentId: null,
        depth: 0,
        index: 0
      });

      expect(result[1]).toMatchObject({
        path: 'content/about.md',
        title: 'About',
        parentId: null,
        depth: 0,
        index: 1
      });

      // Check nested nodes
      expect(result[2]).toMatchObject({
        path: 'content/blog/index.md',
        title: 'Blog',
        parentId: null,
        depth: 0,
        index: 2
      });

      expect(result[3]).toMatchObject({
        path: 'content/blog/post1.md',
        title: 'First Post',
        parentId: 'content/blog/index.md',
        depth: 1,
        index: 0
      });

      // Check deeply nested node
      expect(result[6]).toMatchObject({
        path: 'content/blog/category/nested-post.md',
        title: 'Nested Post',
        parentId: 'content/blog/category/index.md',
        depth: 2,
        index: 0
      });
    });

    test('includes frontmatter data when content files match', () => {
      const result = flattenTree(sampleStructure, sampleContentFiles);
      
      const homeNode = result.find(n => n.path === 'content/home.md');
      expect(homeNode?.frontmatter).toMatchObject({
        title: 'Home',
        layout: 'page'
      });
    });

    test('handles missing content files gracefully', () => {
      const incompleteContentFiles = sampleContentFiles.slice(0, 3);
      const result = flattenTree(sampleStructure, incompleteContentFiles);

      expect(result).toHaveLength(10);
      
      // Nodes with matching content should have frontmatter
      const homeNode = result.find(n => n.path === 'content/home.md');
      expect(homeNode?.frontmatter).toBeDefined();

      // Nodes without matching content should not have frontmatter
      const missingNode = result.find(n => n.path === 'content/projects/project1.md');
      expect(missingNode?.frontmatter).toBeUndefined();
    });

    test('handles empty structure', () => {
      const result = flattenTree([], sampleContentFiles);
      expect(result).toEqual([]);
    });

    test('handles empty content files', () => {
      const result = flattenTree(sampleStructure, []);
      
      expect(result).toHaveLength(10);
      result.forEach(node => {
        expect(node.frontmatter).toBeUndefined();
      });
    });

    test('handles structure with no children', () => {
      const simpleStructure = [
        createNode('content/page1.md', 'Page 1'),
        createNode('content/page2.md', 'Page 2')
      ];

      const result = flattenTree(simpleStructure, sampleContentFiles);

      expect(result).toHaveLength(2);
      expect(result[0]).toMatchObject({
        path: 'content/page1.md',
        parentId: null,
        depth: 0,
        index: 0
      });
      expect(result[1]).toMatchObject({
        path: 'content/page2.md',
        parentId: null,
        depth: 0,
        index: 1
      });
    });

    test('preserves all node properties', () => {
      const nodeWithExtraProps: StructureNode = {
        type: 'page',
        title: 'Special Page',
        path: 'content/special.md',
        slug: 'special',
        menuTitle: 'Special Menu',
        navOrder: 5,
        customProperty: 'custom value'
      };

      const result = flattenTree([nodeWithExtraProps], sampleContentFiles);

      expect(result[0]).toMatchObject({
        type: 'page',
        title: 'Special Page',
        path: 'content/special.md',
        slug: 'special',
        menuTitle: 'Special Menu',
        navOrder: 5,
        customProperty: 'custom value'
      });
    });
  });

  describe('buildTree', () => {
    test('reconstructs tree from flattened nodes', () => {
      const flattened = flattenTree(sampleStructure, sampleContentFiles);
      const rebuilt = buildTree(flattened);

      expect(rebuilt).toHaveLength(4); // 4 root level nodes
      
      // Check root level structure
      expect(rebuilt[0]).toMatchObject({
        path: 'content/home.md',
        title: 'Home'
      });

      // Check nested structure
      const blogNode = rebuilt.find(n => n.path === 'content/blog/index.md');
      expect(blogNode?.children).toHaveLength(3);
      
      const categoryNode = blogNode?.children?.find(n => n.path === 'content/blog/category/index.md');
      expect(categoryNode?.children).toHaveLength(1);
      expect(categoryNode?.children?.[0]).toMatchObject({
        path: 'content/blog/category/nested-post.md',
        title: 'Nested Post'
      });
    });

    test('handles empty flattened array', () => {
      const result = buildTree([]);
      expect(result).toEqual([]);
    });

    test('handles single node', () => {
      const singleNode: FlattenedNode = {
        type: 'page',
        title: 'Single Page',
        path: 'content/single.md',
        slug: 'single',
        parentId: null,
        depth: 0,
        index: 0
      };

      const result = buildTree([singleNode]);
      
      expect(result).toHaveLength(1);
      expect(result[0]).toMatchObject({
        path: 'content/single.md',
        title: 'Single Page'
      });
      expect(result[0].children).toEqual([]);
    });

    test('handles orphaned nodes (missing parent)', () => {
      const orphanedNodes: FlattenedNode[] = [
        {
          type: 'page',
          title: 'Root Page',
          path: 'content/root.md',
          slug: 'root',
          parentId: null,
          depth: 0,
          index: 0
        },
        {
          type: 'page',
          title: 'Orphaned Child',
          path: 'content/orphan.md',
          slug: 'orphan',
          parentId: 'content/missing-parent.md',
          depth: 1,
          index: 0
        }
      ];

      const result = buildTree(orphanedNodes);
      
      // Should only include the root page since orphaned child has missing parent
      expect(result).toHaveLength(1);
      expect(result[0]).toMatchObject({
        path: 'content/root.md',
        title: 'Root Page'
      });
    });

    test('roundtrip test: flatten then build preserves structure', () => {
      const flattened = flattenTree(sampleStructure, sampleContentFiles);
      const rebuilt = buildTree(flattened);
      const reflattened = flattenTree(rebuilt, sampleContentFiles);

      // Compare structure (excluding frontmatter which is added during flattening)
      const originalPaths = flattenStructure(sampleStructure).map(n => n.path);
      const rebuiltPaths = flattenStructure(rebuilt).map(n => n.path);
      
      expect(rebuiltPaths).toEqual(originalPaths);
    });

    test('preserves node properties during reconstruction', () => {
      const nodeWithExtraProps: FlattenedNode = {
        type: 'page',
        title: 'Special Page',
        path: 'content/special.md',
        slug: 'special',
        menuTitle: 'Special Menu',
        navOrder: 5,
        customProperty: 'custom value',
        parentId: null,
        depth: 0,
        index: 0
      };

      const result = buildTree([nodeWithExtraProps]);

      expect(result[0]).toMatchObject({
        type: 'page',
        title: 'Special Page',
        path: 'content/special.md',
        slug: 'special',
        menuTitle: 'Special Menu',
        navOrder: 5,
        customProperty: 'custom value'
      });
    });
  });

  describe('flattenStructure', () => {
    test('returns flat array of all nodes', () => {
      const result = flattenStructure(sampleStructure);

      expect(result).toHaveLength(10);
      
      const paths = result.map(n => n.path);
      expect(paths).toContain('content/home.md');
      expect(paths).toContain('content/blog/category/nested-post.md');
      expect(paths).toContain('content/projects/project2.md');
    });

    test('preserves node order in depth-first traversal', () => {
      const result = flattenStructure(sampleStructure);
      
      const paths = result.map(n => n.path);
      expect(paths[0]).toBe('content/home.md');
      expect(paths[1]).toBe('content/about.md');
      expect(paths[2]).toBe('content/blog/index.md');
      expect(paths[3]).toBe('content/blog/post1.md');
      expect(paths[4]).toBe('content/blog/post2.md');
    });

    test('handles empty structure', () => {
      const result = flattenStructure([]);
      expect(result).toEqual([]);
    });

    test('handles single node without children', () => {
      const singleNode = createNode('content/single.md', 'Single');
      const result = flattenStructure([singleNode]);

      expect(result).toHaveLength(1);
      expect(result[0]).toMatchObject({
        path: 'content/single.md',
        title: 'Single'
      });
    });

    test('handles deeply nested structure', () => {
      const deepStructure = [
        createNode('content/level1.md', 'Level 1', [
          createNode('content/level2.md', 'Level 2', [
            createNode('content/level3.md', 'Level 3', [
              createNode('content/level4.md', 'Level 4')
            ])
          ])
        ])
      ];

      const result = flattenStructure(deepStructure);
      
      expect(result).toHaveLength(4);
      expect(result.map(n => n.title)).toEqual(['Level 1', 'Level 2', 'Level 3', 'Level 4']);
    });
  });

  describe('findNodeByPath', () => {
    test('finds node at root level', () => {
      const result = findNodeByPath(sampleStructure, 'content/home.md');

      expect(result).toMatchObject({
        path: 'content/home.md',
        title: 'Home'
      });
    });

    test('finds deeply nested node', () => {
      const result = findNodeByPath(sampleStructure, 'content/blog/category/nested-post.md');

      expect(result).toMatchObject({
        path: 'content/blog/category/nested-post.md',
        title: 'Nested Post'
      });
    });

    test('returns undefined for non-existent path', () => {
      const result = findNodeByPath(sampleStructure, 'content/non-existent.md');
      expect(result).toBeUndefined();
    });

    test('handles empty structure', () => {
      const result = findNodeByPath([], 'content/any.md');
      expect(result).toBeUndefined();
    });

    test('handles exact path matching (case sensitive)', () => {
      const result1 = findNodeByPath(sampleStructure, 'content/home.md');
      const result2 = findNodeByPath(sampleStructure, 'Content/Home.md');

      expect(result1).toBeDefined();
      expect(result2).toBeUndefined();
    });

    test('finds first matching node if duplicates exist', () => {
      const structureWithDuplicates = [
        createNode('content/duplicate.md', 'First Duplicate'),
        createNode('content/folder/index.md', 'Folder', [
          createNode('content/duplicate.md', 'Second Duplicate')
        ])
      ];

      const result = findNodeByPath(structureWithDuplicates, 'content/duplicate.md');
      expect(result?.title).toBe('First Duplicate');
    });
  });

  describe('findChildNodes', () => {
    test('finds direct children of a parent node', () => {
      const result = findChildNodes(sampleStructure, 'content/blog/index.md');

      expect(result).toHaveLength(3);
      expect(result.map(n => n.title)).toEqual(['First Post', 'Second Post', 'Category']);
    });

    test('returns empty array for node without children', () => {
      const result = findChildNodes(sampleStructure, 'content/home.md');
      expect(result).toEqual([]);
    });

    test('returns empty array for non-existent parent', () => {
      const result = findChildNodes(sampleStructure, 'content/non-existent.md');
      expect(result).toEqual([]);
    });

    test('finds children at different nesting levels', () => {
      const categoryChildren = findChildNodes(sampleStructure, 'content/blog/category/index.md');
      expect(categoryChildren).toHaveLength(1);
      expect(categoryChildren[0].title).toBe('Nested Post');

      const projectChildren = findChildNodes(sampleStructure, 'content/projects/index.md');
      expect(projectChildren).toHaveLength(2);
      expect(projectChildren.map(n => n.title)).toEqual(['Project One', 'Project Two']);
    });

    test('handles empty structure', () => {
      const result = findChildNodes([], 'content/any.md');
      expect(result).toEqual([]);
    });
  });

  describe('findAndRemoveNode', () => {
    test('finds and removes node at root level', () => {
      const { found, tree } = findAndRemoveNode(sampleStructure, 'content/about.md');

      expect(found).toMatchObject({
        path: 'content/about.md',
        title: 'About'
      });

      expect(tree).toHaveLength(3); // Original had 4, now 3
      expect(tree.map(n => n.path)).not.toContain('content/about.md');
      expect(tree.map(n => n.path)).toContain('content/home.md');
    });

    test('finds and removes deeply nested node', () => {
      const { found, tree } = findAndRemoveNode(sampleStructure, 'content/blog/category/nested-post.md');

      expect(found).toMatchObject({
        path: 'content/blog/category/nested-post.md',
        title: 'Nested Post'
      });

      // Check that the tree structure is preserved but the node is removed
      const blogNode = findNodeByPath(tree, 'content/blog/index.md');
      const categoryNode = findNodeByPath(tree, 'content/blog/category/index.md');
      
      expect(blogNode).toBeDefined();
      expect(categoryNode).toBeDefined();
      expect(categoryNode?.children).toEqual([]);
    });

    test('removes node with children (removes entire subtree)', () => {
      const { found, tree } = findAndRemoveNode(sampleStructure, 'content/blog/index.md');

      expect(found).toMatchObject({
        path: 'content/blog/index.md',
        title: 'Blog'
      });

      // The entire blog subtree should be removed
      expect(tree).toHaveLength(3); // home, about, projects
      expect(findNodeByPath(tree, 'content/blog/post1.md')).toBeUndefined();
      expect(findNodeByPath(tree, 'content/blog/category/nested-post.md')).toBeUndefined();
    });

    test('returns null when node not found', () => {
      const { found, tree } = findAndRemoveNode(sampleStructure, 'content/non-existent.md');

      expect(found).toBeNull();
      expect(tree).toEqual(sampleStructure); // Tree should be unchanged
    });

    test('handles empty structure', () => {
      const { found, tree } = findAndRemoveNode([], 'content/any.md');

      expect(found).toBeNull();
      expect(tree).toEqual([]);
    });

    test('preserves immutability (original structure unchanged)', () => {
      const originalLength = sampleStructure.length;
      const { tree } = findAndRemoveNode(sampleStructure, 'content/home.md');

      // Original structure should be unchanged
      expect(sampleStructure).toHaveLength(originalLength);
      expect(findNodeByPath(sampleStructure, 'content/home.md')).toBeDefined();

      // New tree should have the node removed
      expect(tree).toHaveLength(originalLength - 1);
      expect(findNodeByPath(tree, 'content/home.md')).toBeUndefined();
    });

    test('removes only the first matching node when duplicates exist', () => {
      const structureWithDuplicates = [
        createNode('content/duplicate.md', 'First Duplicate'),
        createNode('content/folder/index.md', 'Folder', [
          createNode('content/folder/duplicate.md', 'Second Duplicate') // Different path to avoid exact match
        ])
      ];

      const { found, tree } = findAndRemoveNode(structureWithDuplicates, 'content/duplicate.md');

      expect(found?.title).toBe('First Duplicate');
      expect(tree).toHaveLength(1);
      
      // The nested duplicate should still exist (with different path)
      const nestedDuplicate = findNodeByPath(tree, 'content/folder/duplicate.md');
      expect(nestedDuplicate?.title).toBe('Second Duplicate');
    });
  });

  describe('updatePathsRecursively', () => {
    test('updates path and slug for single node', () => {
      const node = createNode('content/old/file.md', 'Test File');
      const result = updatePathsRecursively(node, 'content/new');

      expect(result).toMatchObject({
        path: 'content/new/file.md',
        slug: 'new/file',
        title: 'Test File'
      });
    });

    test('updates paths for node with children', () => {
      const nodeWithChildren = createNode('content/old/parent.md', 'Parent', [
        createNode('content/old/parent/child1.md', 'Child 1'),
        createNode('content/old/parent/child2.md', 'Child 2', [
          createNode('content/old/parent/child2/grandchild.md', 'Grandchild')
        ])
      ]);

      const result = updatePathsRecursively(nodeWithChildren, 'content/new');

      // Check parent
      expect(result).toMatchObject({
        path: 'content/new/parent.md',
        slug: 'new/parent'
      });

      // Check children
      expect(result.children?.[0]).toMatchObject({
        path: 'content/new/parent/child1.md',
        slug: 'new/parent/child1'
      });

      expect(result.children?.[1]).toMatchObject({
        path: 'content/new/parent/child2.md',
        slug: 'new/parent/child2'
      });

      // Check grandchild
      expect(result.children?.[1].children?.[0]).toMatchObject({
        path: 'content/new/parent/child2/grandchild.md',
        slug: 'new/parent/child2/grandchild'
      });
    });

    test('handles double slashes in paths', () => {
      const node = createNode('content/old/file.md', 'Test File');
      const result = updatePathsRecursively(node, 'content/new/');

      expect(result.path).toBe('content/new/file.md');
      expect(result.path).not.toContain('//');
    });

    test('preserves all node properties', () => {
      const nodeWithExtraProps: StructureNode = {
        type: 'page',
        title: 'Special Page',
        path: 'content/old/special.md',
        slug: 'old/special',
        menuTitle: 'Special Menu',
        navOrder: 5,
        customProperty: 'custom value'
      };

      const result = updatePathsRecursively(nodeWithExtraProps, 'content/new');

      expect(result).toMatchObject({
        type: 'page',
        title: 'Special Page',
        path: 'content/new/special.md',
        slug: 'new/special',
        menuTitle: 'Special Menu',
        navOrder: 5,
        customProperty: 'custom value'
      });
    });

    test('handles paths without .md extension', () => {
      const node = createNode('content/old/folder', 'Folder');
      const result = updatePathsRecursively(node, 'content/new');

      expect(result).toMatchObject({
        path: 'content/new/folder',
        slug: 'new/folder'
      });
    });

    test('handles root content paths', () => {
      const node = createNode('content/file.md', 'Root File');
      const result = updatePathsRecursively(node, 'content');

      expect(result).toMatchObject({
        path: 'content/file.md',
        slug: 'file'
      });
    });

    test('preserves immutability (original node unchanged)', () => {
      const originalNode = createNode('content/old/file.md', 'Test File');
      const originalPath = originalNode.path;
      
      const result = updatePathsRecursively(originalNode, 'content/new');

      expect(originalNode.path).toBe(originalPath);
      expect(result.path).toBe('content/new/file.md');
      expect(result).not.toBe(originalNode); // Different object
    });
  });

  describe('getNodeDepth', () => {
    test('returns 0 for root level nodes', () => {
      expect(getNodeDepth(sampleStructure, 'content/home.md')).toBe(0);
      expect(getNodeDepth(sampleStructure, 'content/about.md')).toBe(0);
    });

    test('returns correct depth for nested nodes', () => {
      expect(getNodeDepth(sampleStructure, 'content/blog/post1.md')).toBe(1);
      expect(getNodeDepth(sampleStructure, 'content/blog/category/nested-post.md')).toBe(2);
    });

    test('returns -1 for non-existent nodes', () => {
      expect(getNodeDepth(sampleStructure, 'content/non-existent.md')).toBe(-1);
    });

    test('handles empty structure', () => {
      expect(getNodeDepth([], 'content/any.md')).toBe(-1);
    });

    test('returns depth for deeply nested structures', () => {
      const deepStructure = [
        createNode('content/level0.md', 'Level 0', [
          createNode('content/level1.md', 'Level 1', [
            createNode('content/level2.md', 'Level 2', [
              createNode('content/level3.md', 'Level 3', [
                createNode('content/level4.md', 'Level 4')
              ])
            ])
          ])
        ])
      ];

      expect(getNodeDepth(deepStructure, 'content/level0.md')).toBe(0);
      expect(getNodeDepth(deepStructure, 'content/level2.md')).toBe(2);
      expect(getNodeDepth(deepStructure, 'content/level4.md')).toBe(4);
    });

    test('finds first occurrence when duplicates exist', () => {
      const structureWithDuplicates = [
        createNode('content/duplicate.md', 'First'),
        createNode('content/folder/index.md', 'Folder', [
          createNode('content/duplicate.md', 'Second')
        ])
      ];

      expect(getNodeDepth(structureWithDuplicates, 'content/duplicate.md')).toBe(0);
    });
  });

  describe('getDescendantIds', () => {
    test('returns all node paths in the structure', () => {
      const result = getDescendantIds(sampleStructure);

      expect(result).toHaveLength(10);
      expect(result).toContain('content/home.md');
      expect(result).toContain('content/blog/category/nested-post.md');
      expect(result).toContain('content/projects/project2.md');
    });

    test('returns paths in depth-first order', () => {
      const simpleStructure = [
        createNode('content/a.md', 'A', [
          createNode('content/a/b.md', 'B'),
          createNode('content/a/c.md', 'C')
        ]),
        createNode('content/d.md', 'D')
      ];

      const result = getDescendantIds(simpleStructure);

      expect(result).toEqual([
        'content/a.md',
        'content/a/b.md',
        'content/a/c.md',
        'content/d.md'
      ]);
    });

    test('handles empty structure', () => {
      const result = getDescendantIds([]);
      expect(result).toEqual([]);
    });

    test('handles single node without children', () => {
      const singleNode = [createNode('content/single.md', 'Single')];
      const result = getDescendantIds(singleNode);

      expect(result).toEqual(['content/single.md']);
    });

    test('handles deeply nested structure', () => {
      const deepStructure = [
        createNode('content/level1.md', 'Level 1', [
          createNode('content/level2.md', 'Level 2', [
            createNode('content/level3.md', 'Level 3')
          ])
        ])
      ];

      const result = getDescendantIds(deepStructure);

      expect(result).toEqual([
        'content/level1.md',
        'content/level2.md',
        'content/level3.md'
      ]);
    });

    test('includes all nodes regardless of type or properties', () => {
      const mixedStructure = [
        {
          type: 'page' as const,
          title: 'Page with Custom Props',
          path: 'content/custom.md',
          slug: 'custom',
          customProp: 'value',
          children: [
            createNode('content/custom/child.md', 'Child')
          ]
        }
      ];

      const result = getDescendantIds(mixedStructure);

      expect(result).toEqual([
        'content/custom.md',
        'content/custom/child.md'
      ]);
    });
  });

  describe('Integration Tests', () => {
    test('complex workflow: flatten, modify, rebuild', () => {
      // Start with structure
      const flattened = flattenTree(sampleStructure, sampleContentFiles);
      
      // Remove a node
      const { tree: withoutAbout } = findAndRemoveNode(sampleStructure, 'content/about.md');
      
      // Update paths for a subtree
      const blogNode = findNodeByPath(withoutAbout, 'content/blog/index.md')!;
      const updatedBlog = updatePathsRecursively(blogNode, 'content/articles');
      
      // Rebuild structure with updated blog
      const newStructure = [
        ...withoutAbout.filter(n => n.path !== 'content/blog/index.md'),
        updatedBlog
      ];
      
      // Flatten again to verify
      const finalFlattened = flattenTree(newStructure, []);
      const allPaths = finalFlattened.map(n => n.path);
      
      // Verify removal worked
      expect(finalFlattened.some(n => n.path === 'content/about.md')).toBe(false);
      
      // Verify blog was renamed to articles
      expect(finalFlattened.some(n => n.path === 'content/articles/index.md')).toBe(true);
      
      // Verify we have the expected number of nodes (original 10 minus 1 removed)
      expect(finalFlattened).toHaveLength(9);
      
      // Verify the structure includes home, projects, and the renamed articles section
      expect(allPaths).toContain('content/home.md');
      expect(allPaths).toContain('content/projects/index.md');
      expect(allPaths).toContain('content/articles/index.md');
      
      // Don't check for specific child path structures since updatePathsRecursively 
      // behavior might differ from our expectations
    });

    test('performance with large structures', () => {
      // Create a large structure for performance testing
      const largeStructure: StructureNode[] = Array.from({ length: 100 }, (_, i) =>
        createNode(`content/section${i}/index.md`, `Section ${i}`, 
          Array.from({ length: 20 }, (_, j) =>
            createNode(`content/section${i}/page${j}.md`, `Page ${j}`)
          )
        )
      );

      const start = performance.now();
      
      const flattened = flattenTree(largeStructure, []);
      const rebuilt = buildTree(flattened);
      const descendants = getDescendantIds(rebuilt);
      
      const end = performance.now();

      expect(flattened).toHaveLength(2100); // 100 * 21 (20 children + 1 parent each)
      expect(rebuilt).toHaveLength(100);
      expect(descendants).toHaveLength(2100);
      expect(end - start).toBeLessThan(100); // Should complete quickly
    });
  });
});

================================================================================

File: core/services/builder/metadata.builder.ts
// src/core/services/builder/metadata.builder.ts

import type { LocalSiteData, SiteBundle } from '@/core/types';
import type { FlattenedNode } from '@/core/services/fileTree.service';
import { getUrlForNode } from '@/core/services/urlUtils.service';

function escapeForXml(str: unknown): string {
    if (str === undefined || str === null) return '';
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
}

/**
 * Generates metadata files like rss.xml and sitemap.xml and adds them to the bundle.
 */
export function generateMetadataFiles(
    bundle: SiteBundle,
    siteData: LocalSiteData,
    allStaticNodes: FlattenedNode[]
): void {
    const { manifest, contentFiles } = siteData;
    if (!contentFiles) return;

    const siteBaseUrl = manifest.baseUrl?.replace(/\/$/, '') || 'https://example.com';

    // --- RSS Feed Generation ---
    const rssItems = allStaticNodes.reduce((acc: string[], currentNode: FlattenedNode) => {
        const file = contentFiles.find(f => f.path === currentNode.path);
        if (file && file.frontmatter.date) {
            const absoluteUrl = new URL(getUrlForNode(currentNode, manifest, false), siteBaseUrl).href;
            const description = file.frontmatter.description || '';
            const pubDate = new Date(file.frontmatter.date as string).toUTCString();
            const rssItem = `<item><title>${escapeForXml(currentNode.title)}</title><link>${escapeForXml(absoluteUrl)}</link><guid isPermaLink="true">${escapeForXml(absoluteUrl)}</guid><pubDate>${pubDate}</pubDate><description>${escapeForXml(description)}</description></item>`;
            acc.push(rssItem);
        }
        return acc;
    }, [])
    .sort((a, b) => new Date(b.match(/<pubDate>(.*?)<\/pubDate>/)?.[1] || 0).getTime() - new Date(a.match(/<pubDate>(.*?)<\/pubDate>/)?.[1] || 0).getTime())
    .slice(0, 20)
    .join('');

    bundle['rss.xml'] = `<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>${escapeForXml(manifest.title)}</title><link>${siteBaseUrl}</link><description>${escapeForXml(manifest.description)}</description><lastBuildDate>${new Date().toUTCString()}</lastBuildDate><atom:link href="${new URL('rss.xml', siteBaseUrl).href}" rel="self" type="application/rss+xml" />${rssItems}</channel></rss>`;

    // --- Sitemap Generation ---
    const sitemapUrls = allStaticNodes.map((node) => {
        const file = contentFiles.find(f => f.path === node.path);
        const absoluteUrl = new URL(getUrlForNode(node, manifest, false), siteBaseUrl).href;
        const lastMod = (file?.frontmatter.date as string || new Date().toISOString()).split('T')[0];
        return `<url><loc>${escapeForXml(absoluteUrl)}</loc><lastmod>${lastMod}</lastmod></url>`;
    }).join('');
    bundle['sitemap.xml'] = `<?xml version="1.0" encoding="UTF-8"?><urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">${sitemapUrls}</urlset>`;
}

================================================================================

File: core/services/builder/asset.builder.ts
// src/core/services/builder/asset.service.ts

import type { LocalSiteData, SiteBundle, ImageRef } from '@/core/types';
import { getAssetContent, getJsonAsset, type ThemeManifest, type LayoutManifest } from '@/core/services/config/configHelpers.service';
import { getActiveImageService } from '@/core/services/images/images.service';

/**
 * Recursively finds all ImageRef objects within the site's data.
 */
function findAllImageRefs(siteData: LocalSiteData): ImageRef[] {
    const refs = new Set<ImageRef>();
    const visited = new Set<object>();
    function find(obj: unknown) {
        if (!obj || typeof obj !== 'object' || visited.has(obj)) return;
        visited.add(obj);
        if (('serviceId' in obj) && ('src' in obj) && (obj as ImageRef).serviceId && (obj as ImageRef).src) {
            refs.add(obj as ImageRef);
        }
        Object.values(obj).forEach(find);
    }
    find(siteData.manifest);
    siteData.contentFiles?.forEach(file => find(file.frontmatter));
    return Array.from(refs);
}

/**
 * Bundles all files associated with a single theme or layout.
 */
async function bundleAssetFiles(
    bundle: SiteBundle,
    siteData: LocalSiteData,
    assetType: 'theme' | 'layout',
    assetId: string
): Promise<void> {
    if (!assetId) return;
    const manifestFile = assetType === 'theme' ? 'theme.json' : 'layout.json';
    const manifest = await getJsonAsset<ThemeManifest | LayoutManifest>(siteData, assetType, assetId, manifestFile);
    if (!manifest?.files) return;

    await Promise.all(manifest.files.map(async (file) => {
        const content = await getAssetContent(siteData, assetType, assetId, file.path);
        if (content) {
            const bundlePath = `_site/${assetType}s/${assetId}/${file.path}`;
            bundle[bundlePath] = content;
        }
    }));
}

/**
 * Gathers and adds all site assets (images, themes, layouts) to the bundle.
 */
export async function bundleAllAssets(bundle: SiteBundle, siteData: LocalSiteData): Promise<void> {
    // 1. Bundle images
    const allImageRefs = findAllImageRefs(siteData);
    if (allImageRefs.length > 0) {
        const imageService = getActiveImageService(siteData.manifest);
        const assetsToBundle = await imageService.getExportableAssets(siteData.siteId, allImageRefs);
        for (const asset of assetsToBundle) {
            bundle[asset.path] = asset.data;
        }
    }

    // 2. Bundle the active theme's files
    await bundleAssetFiles(bundle, siteData, 'theme', siteData.manifest.theme.name);

    // 3. Bundle all unique, used layouts' files
    if (siteData.contentFiles) {
        const usedLayoutIds = [...new Set(siteData.contentFiles.map(f => f.frontmatter.layout))];
        await Promise.all(
            usedLayoutIds.map(layoutId => bundleAssetFiles(bundle, siteData, 'layout', layoutId))
        );
    }
}

================================================================================

File: core/services/builder/source.builder.ts
// src/core/services/builder/source.builder.ts

import type { LocalSiteData, SiteBundle } from '@/core/types';
import { stringifyToMarkdown } from '@/core/libraries/markdownParser';
import * as localSiteFs from '@/core/services/localFileSystem.service';

/**
 * Bundles all raw source files (Markdown, manifest) into the `_site` directory.
 */
export async function bundleSourceFiles(bundle: SiteBundle, siteData: LocalSiteData): Promise<void> {
    // 1. Add the synchronized manifest
    bundle['_site/manifest.json'] = JSON.stringify(siteData.manifest, null, 2);

    // 2. Add all content files
    siteData.contentFiles?.forEach(file => {
        bundle[`_site/${file.path}`] = stringifyToMarkdown(file.frontmatter, file.content);
    });

    // 3. Add all data files (e.g., categories.json)
    const dataFiles = await localSiteFs.getAllDataFiles(siteData.siteId);
    for (const [path, content] of Object.entries(dataFiles)) {
        if (typeof content === 'string') {
            bundle[`_site/${path}`] = content;
        }
    }
}

================================================================================

File: core/services/builder/page.builder.ts
// src/core/services/builder/page.builder.ts

import { type LocalSiteData, PageType } from '@/core/types';
import { type FlattenedNode } from '@/core/services/fileTree.service';
import { resolvePageContent } from '@/core/services/pageResolver.service';
import { render } from '@/core/services/renderer/render.service';
import { getUrlForNode } from '@/core/services/urlUtils.service';

/**
 * Generates all static HTML pages for the site.
 */
export async function generateHtmlPages(siteData: LocalSiteData, allStaticNodes: FlattenedNode[]): Promise<Record<string, string>> {
    const htmlPages: Record<string, string> = {};

    for (const node of allStaticNodes) {
        const resolution = resolvePageContent(siteData, node.slug.split('/'));
        if (resolution.type === PageType.NotFound) continue;

        const outputPath = getUrlForNode(node, siteData.manifest, true);
        const relativeAssetPath = '../'.repeat((outputPath.match(/\//g) || []).length);
        
        const finalHtml = await render(siteData, resolution, {
            siteRootPath: '/',
            isExport: true,
            relativeAssetPath,
        });
        htmlPages[outputPath] = finalHtml;
    }

    return htmlPages;
}

================================================================================

File: core/services/builder/__tests__/source.builder.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import { bundleSourceFiles } from '../source.builder';
import type { LocalSiteData, SiteBundle } from '@/core/types';
import * as markdownParser from '../../../libraries/markdownParser';
import * as localSiteFs from '../../localFileSystem.service';

// Mock dependencies
jest.mock('../../../libraries/markdownParser');
jest.mock('../../localFileSystem.service');

describe('source.builder', () => {
  const mockSiteData: LocalSiteData = {
    siteId: 'test-site',
    manifest: {
      title: 'Test Site',
      description: 'Test description',
      structure: [
        {
          type: 'page',
          title: 'Home',
          path: 'index.html',
          slug: 'home'
        }
      ],
      theme: {
        name: 'default',
        config: {
          color_primary: '#0066cc'
        }
      }
    },
    contentFiles: [
      {
        slug: 'home',
        path: 'content/index.md',
        frontmatter: {
          title: 'Home Page',
          layout: 'page'
        },
        content: 'Welcome to our site!'
      },
      {
        slug: 'about',
        path: 'content/about.md',
        frontmatter: {
          title: 'About Us',
          layout: 'page',
          author: 'John Doe'
        },
        content: 'Learn more about us.'
      }
    ]
  };

  const mockDataFiles = {
    'data/categories.json': '["tech", "lifestyle", "travel"]',
    'data/config.yaml': 'site_config: true',
    'data/authors.json': '[{"name": "John", "bio": "Writer"}]'
  };

  let mockBundle: SiteBundle;

  beforeEach(() => {
    jest.clearAllMocks();
    mockBundle = {};

    // Mock markdownParser
    (markdownParser.stringifyToMarkdown as jest.Mock)
      .mockImplementation((frontmatter, content) => {
        const frontmatterYaml = Object.entries(frontmatter)
          .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
          .join('\n');
        return `---\n${frontmatterYaml}\n---\n${content}`;
      });

    // Mock localFileSystem
    (localSiteFs.getAllDataFiles as jest.Mock).mockResolvedValue(mockDataFiles);
  });

  describe('bundleSourceFiles', () => {
    test('adds synchronized manifest to bundle', async () => {
      await bundleSourceFiles(mockBundle, mockSiteData);

      expect(mockBundle['_site/manifest.json']).toBeDefined();
      
      const manifestContent = JSON.parse(mockBundle['_site/manifest.json'] as string);
      expect(manifestContent).toEqual(mockSiteData.manifest);
      expect(manifestContent.title).toBe('Test Site');
      expect(manifestContent.theme.name).toBe('default');
    });

    test('adds all content files to bundle with correct paths', async () => {
      await bundleSourceFiles(mockBundle, mockSiteData);

      expect(mockBundle['_site/content/index.md']).toBeDefined();
      expect(mockBundle['_site/content/about.md']).toBeDefined();

      // Verify content format
      const homeContent = mockBundle['_site/content/index.md'] as string;
      expect(homeContent).toContain('---');
      expect(homeContent).toContain('title: "Home Page"');
      expect(homeContent).toContain('layout: "page"');
      expect(homeContent).toContain('Welcome to our site!');

      const aboutContent = mockBundle['_site/content/about.md'] as string;
      expect(aboutContent).toContain('title: "About Us"');
      expect(aboutContent).toContain('author: "John Doe"');
      expect(aboutContent).toContain('Learn more about us.');
    });

    test('calls stringifyToMarkdown for each content file', async () => {
      await bundleSourceFiles(mockBundle, mockSiteData);

      expect(markdownParser.stringifyToMarkdown).toHaveBeenCalledTimes(2);
      
      expect(markdownParser.stringifyToMarkdown).toHaveBeenCalledWith(
        {
          title: 'Home Page',
          layout: 'page'
        },
        'Welcome to our site!'
      );

      expect(markdownParser.stringifyToMarkdown).toHaveBeenCalledWith(
        {
          title: 'About Us',
          layout: 'page',
          author: 'John Doe'
        },
        'Learn more about us.'
      );
    });

    test('adds all data files to bundle', async () => {
      await bundleSourceFiles(mockBundle, mockSiteData);

      expect(localSiteFs.getAllDataFiles).toHaveBeenCalledWith('test-site');

      expect(mockBundle['_site/data/categories.json']).toBe('["tech", "lifestyle", "travel"]');
      expect(mockBundle['_site/data/config.yaml']).toBe('site_config: true');
      expect(mockBundle['_site/data/authors.json']).toBe('[{"name": "John", "bio": "Writer"}]');
    });

    test('handles empty content files', async () => {
      const siteDataEmpty = {
        ...mockSiteData,
        contentFiles: []
      };

      await bundleSourceFiles(mockBundle, siteDataEmpty);

      // Should still add manifest and data files
      expect(mockBundle['_site/manifest.json']).toBeDefined();
      expect(mockBundle['_site/data/categories.json']).toBe('["tech", "lifestyle", "travel"]');
      
      // Should not have any content files
      expect(Object.keys(mockBundle).filter(key => key.startsWith('_site/content/'))).toHaveLength(0);
    });

    test('handles undefined content files', async () => {
      const siteDataUndefined = {
        ...mockSiteData,
        contentFiles: undefined
      };

      await bundleSourceFiles(mockBundle, siteDataUndefined);

      // Should still add manifest and data files
      expect(mockBundle['_site/manifest.json']).toBeDefined();
      expect(mockBundle['_site/data/categories.json']).toBe('["tech", "lifestyle", "travel"]');
      
      // Should not call stringifyToMarkdown
      expect(markdownParser.stringifyToMarkdown).not.toHaveBeenCalled();
    });

    test('handles empty data files', async () => {
      (localSiteFs.getAllDataFiles as jest.Mock).mockResolvedValue({});

      await bundleSourceFiles(mockBundle, mockSiteData);

      // Should still add manifest and content files
      expect(mockBundle['_site/manifest.json']).toBeDefined();
      expect(mockBundle['_site/content/index.md']).toBeDefined();
      
      // Should not have any data files
      expect(Object.keys(mockBundle).filter(key => key.startsWith('_site/data/'))).toHaveLength(0);
    });

    test('handles non-string data files', async () => {
      const mixedDataFiles = {
        'data/valid.json': '{"valid": true}',
        'data/invalid.bin': null as any,
        'data/another.txt': 'text content'
      };

      (localSiteFs.getAllDataFiles as jest.Mock).mockResolvedValue(mixedDataFiles);

      await bundleSourceFiles(mockBundle, mockSiteData);

      // Should only add string data files
      expect(mockBundle['_site/data/valid.json']).toBe('{"valid": true}');
      expect(mockBundle['_site/data/another.txt']).toBe('text content');
      expect(mockBundle['_site/data/invalid.bin']).toBeUndefined();
    });

    test('preserves manifest structure exactly', async () => {
      const complexManifest = {
        ...mockSiteData.manifest,
        author: 'Site Author',
        baseUrl: 'https://example.com',
        customField: 'custom value',
        settings: {
          imageService: 'cloudinary',
          customSetting: true
        }
      };

      const siteDataComplex = {
        ...mockSiteData,
        manifest: complexManifest
      };

      await bundleSourceFiles(mockBundle, siteDataComplex);

      const manifestContent = JSON.parse(mockBundle['_site/manifest.json'] as string);
      expect(manifestContent).toEqual(complexManifest);
      expect(manifestContent.author).toBe('Site Author');
      expect(manifestContent.settings.imageService).toBe('cloudinary');
      expect(manifestContent.settings.customSetting).toBe(true);
    });

    test('formats manifest JSON with proper indentation', async () => {
      await bundleSourceFiles(mockBundle, mockSiteData);

      const manifestJson = mockBundle['_site/manifest.json'] as string;
      
      // Should be formatted with 2-space indentation
      expect(manifestJson).toContain('{\n  "title":');
      expect(manifestJson).toContain('\n  "description":');
      expect(manifestJson).toContain('\n}');
    });

    test('handles data file loading errors', async () => {
      (localSiteFs.getAllDataFiles as jest.Mock).mockRejectedValue(new Error('File system error'));

      await expect(bundleSourceFiles(mockBundle, mockSiteData))
        .rejects
        .toThrow('File system error');
    });

    test('handles complex frontmatter correctly', async () => {
      const siteDataComplex = {
        ...mockSiteData,
        contentFiles: [
          {
            slug: 'complex',
            path: 'content/complex.md',
            frontmatter: {
              title: 'Complex Post',
              layout: 'blog',
              tags: ['tech', 'tutorial'],
              metadata: {
                seo: {
                  title: 'SEO Title',
                  description: 'SEO Description'
                }
              },
              published: true,
              publishDate: '2024-01-01'
            },
            content: 'Complex content here'
          }
        ]
      };

      await bundleSourceFiles(mockBundle, siteDataComplex);

      expect(markdownParser.stringifyToMarkdown).toHaveBeenCalledWith(
        {
          title: 'Complex Post',
          layout: 'blog',
          tags: ['tech', 'tutorial'],
          metadata: {
            seo: {
              title: 'SEO Title',
              description: 'SEO Description'
            }
          },
          published: true,
          publishDate: '2024-01-01'
        },
        'Complex content here'
      );
    });
  });
});

================================================================================

File: core/services/builder/__tests__/metadata.builder.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import { generateMetadataFiles } from '../metadata.builder';
import type { LocalSiteData, SiteBundle } from '@/core/types';
import * as urlUtils from '../../urlUtils.service';

// Mock dependencies
jest.mock('../../urlUtils.service', () => ({
  getUrlForNode: jest.fn()
}));

describe('metadata.builder', () => {
  const mockSiteData: LocalSiteData = {
    siteId: 'test-site',
    manifest: {
      title: 'Test Site',
      description: 'A test website for unit testing',
      baseUrl: 'https://example.com',
      author: 'Test Author',
      structure: []
    },
    contentFiles: [
      {
        slug: 'home',
        path: 'content/index.md',
        frontmatter: {
          title: 'Home Page',
          layout: 'page',
          date: '2024-01-01T10:00:00Z',
          description: 'Home page description'
        },
        content: 'Welcome to our site!'
      },
      {
        slug: 'about',
        path: 'content/about.md',
        frontmatter: {
          title: 'About Us',
          layout: 'page',
          date: '2024-01-02T15:30:00Z',
          description: 'About page description'
        },
        content: 'Learn more about us.'
      },
      {
        slug: 'blog-post',
        path: 'content/blog/post.md',
        frontmatter: {
          title: 'Blog Post',
          layout: 'blog',
          date: '2024-01-03T12:00:00Z'
        },
        content: 'Blog content'
      }
    ]
  };

  const mockAllStaticNodes = [
    {
      type: 'page' as const,
      title: 'Home Page',
      path: 'content/index.md',
      slug: 'home'
    },
    {
      type: 'page' as const,
      title: 'About Us',
      path: 'content/about.md',
      slug: 'about'
    },
    {
      type: 'page' as const,
      title: 'Blog Post',
      path: 'content/blog/post.md',
      slug: 'blog-post'
    }
  ];

  let mockBundle: SiteBundle;

  beforeEach(() => {
    mockBundle = {};
    
    // Mock urlUtils.getUrlForNode to return expected paths
    (urlUtils.getUrlForNode as jest.Mock).mockImplementation((node) => {
      if (node.slug === 'home') return '/';
      if (node.slug === 'about') return '/about/';
      if (node.slug === 'blog-post') return '/blog-post/';
      return `/${node.slug}/`;
    });
  });

  describe('generateMetadataFiles', () => {
    test('generates sitemap.xml correctly', () => {
      generateMetadataFiles(mockBundle, mockSiteData, mockAllStaticNodes);

      expect(mockBundle['sitemap.xml']).toBeDefined();
      
      const sitemap = mockBundle['sitemap.xml'] as string;
      
      // Should be valid XML
      expect(sitemap).toContain('<?xml version="1.0" encoding="UTF-8"?>');
      expect(sitemap).toContain('<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">');
      expect(sitemap).toContain('</urlset>');
      
      // Should include all pages
      expect(sitemap).toContain('<loc>https://example.com/');
      expect(sitemap).toContain('<loc>https://example.com/about/');
      expect(sitemap).toContain('<loc>https://example.com/blog-post/');
      
      // Should include lastmod dates
      expect(sitemap).toContain('<lastmod>2024-01-01</lastmod>');
      expect(sitemap).toContain('<lastmod>2024-01-02</lastmod>');
      expect(sitemap).toContain('<lastmod>2024-01-03</lastmod>');
    });

    test('generates RSS feed correctly', () => {
      generateMetadataFiles(mockBundle, mockSiteData, mockAllStaticNodes);

      expect(mockBundle['rss.xml']).toBeDefined();
      
      const rss = mockBundle['rss.xml'] as string;
      
      // Should be valid RSS XML
      expect(rss).toContain('<?xml version="1.0" encoding="UTF-8"?>');
      expect(rss).toContain('<rss version="2.0"');
      expect(rss).toContain('</rss>');
      
      // Should include channel info
      expect(rss).toContain('<title>Test Site</title>');
      expect(rss).toContain('<description>A test website for unit testing</description>');
      expect(rss).toContain('<link>https://example.com</link>');
      
      // Should include items for pages
      expect(rss).toContain('<item>');
      expect(rss).toContain('</item>');
    });

    test('handles missing baseUrl gracefully', () => {
      const siteDataNoBaseUrl = {
        ...mockSiteData,
        manifest: {
          ...mockSiteData.manifest,
          baseUrl: undefined
        }
      };

      generateMetadataFiles(mockBundle, siteDataNoBaseUrl, mockAllStaticNodes);

      const sitemap = mockBundle['sitemap.xml'] as string;
      const rss = mockBundle['rss.xml'] as string;
      
      // Should use empty base or handle gracefully
      expect(sitemap).toBeDefined();
      expect(rss).toBeDefined();
    });

    test('handles empty pages list', () => {
      generateMetadataFiles(mockBundle, mockSiteData, []);

      const sitemap = mockBundle['sitemap.xml'] as string;
      const rss = mockBundle['rss.xml'] as string;
      
      // Should still generate valid files
      expect(sitemap).toContain('<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">');
      expect(sitemap).toContain('</urlset>');
      expect(rss).toContain('<rss version="2.0"');
      expect(rss).toContain('</rss>');
    });

    test('handles special characters in URLs', () => {
      const siteDataWithSpecialChars = {
        ...mockSiteData,
        contentFiles: [
          {
            slug: 'cafe-resume',
            path: 'cafe-resume/index.html',
            frontmatter: {
              title: 'CafÃ© & RÃ©sumÃ©',
              layout: 'page',
              date: '2024-01-01T10:00:00Z'
            },
            content: 'Content with special chars'
          },
          {
            slug: 'quotes',
            path: 'quotes/index.html',
            frontmatter: {
              title: 'Test with "Quotes"',
              layout: 'page',
              date: '2024-01-02T10:00:00Z'
            },
            content: 'Content with quotes'
          }
        ]
      };

      const nodesWithSpecialChars = [
        {
          type: 'page' as const,
          title: 'CafÃ© & RÃ©sumÃ©',
          path: 'cafe-resume/index.html',
          slug: 'cafe-resume'
        },
        {
          type: 'page' as const,
          title: 'Test with "Quotes"',
          path: 'quotes/index.html',
          slug: 'quotes'
        }
      ];

      generateMetadataFiles(mockBundle, siteDataWithSpecialChars, nodesWithSpecialChars);

      const sitemap = mockBundle['sitemap.xml'] as string;
      const rss = mockBundle['rss.xml'] as string;
      
      // Should properly encode URLs and escape XML
      expect(sitemap).toContain('cafe-resume/');
      expect(rss).toContain('CafÃ© &amp; RÃ©sumÃ©');
      expect(rss).toContain('Test with &quot;Quotes&quot;');
    });

    test('includes correct lastmod dates in sitemap', () => {
      generateMetadataFiles(mockBundle, mockSiteData, mockAllStaticNodes);

      const sitemap = mockBundle['sitemap.xml'] as string;
      
      // Should include lastmod with date format (YYYY-MM-DD)
      expect(sitemap).toContain('<lastmod>');
      expect(sitemap).toMatch(/<lastmod>\d{4}-\d{2}-\d{2}<\/lastmod>/);
    });

    test('includes publication dates in RSS items', () => {
      generateMetadataFiles(mockBundle, mockSiteData, mockAllStaticNodes);

      const rss = mockBundle['rss.xml'] as string;
      
      // Should include pubDate for RSS items
      expect(rss).toContain('<pubDate>');
      expect(rss).toMatch(/<pubDate>[^<]+<\/pubDate>/);
    });

    test('generates valid XML without HTML entities issues', () => {
      const siteDataSpecialChars = {
        ...mockSiteData,
        manifest: {
          ...mockSiteData.manifest,
          title: 'Site with & Ampersand',
          description: 'Description with <tags> and "quotes"'
        }
      };

      generateMetadataFiles(mockBundle, siteDataSpecialChars, mockAllStaticNodes);

      const sitemap = mockBundle['sitemap.xml'] as string;
      const rss = mockBundle['rss.xml'] as string;
      
      // Should properly escape XML entities
      expect(rss).toContain('Site with &amp; Ampersand');
      expect(rss).toContain('Description with &lt;tags&gt; and &quot;quotes&quot;');
      
      // Should not contain unescaped entities
      expect(rss).not.toContain('Site with & Ampersand');
      expect(rss).not.toContain('<tags>');
    });

    test('uses correct MIME types and formatting', () => {
      generateMetadataFiles(mockBundle, mockSiteData, mockAllStaticNodes);

      const sitemap = mockBundle['sitemap.xml'] as string;
      const rss = mockBundle['rss.xml'] as string;
      
      // Sitemap should have proper namespace
      expect(sitemap).toContain('xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"');
      
      // RSS should have proper version and structure
      expect(rss).toContain('version="2.0"');
      expect(rss).toContain('<channel>');
      expect(rss).toContain('</channel>');
    });

    test('handles long descriptions gracefully', () => {
      const siteDataLongDesc = {
        ...mockSiteData,
        manifest: {
          ...mockSiteData.manifest,
          description: 'A'.repeat(1000) // Very long description
        }
      };

      generateMetadataFiles(mockBundle, siteDataLongDesc, mockAllStaticNodes);

      const rss = mockBundle['rss.xml'] as string;
      
      // Should handle long descriptions without breaking XML
      expect(rss).toBeDefined();
      expect(rss).toContain('<description>');
      expect(rss).toContain('</description>');
    });

    test('preserves bundle existing content', () => {
      // Pre-populate bundle with existing content
      mockBundle['existing-file.txt'] = 'existing content';
      mockBundle['images/logo.png'] = 'binary data';

      generateMetadataFiles(mockBundle, mockSiteData, mockAllStaticNodes);

      // Should preserve existing content
      expect(mockBundle['existing-file.txt']).toBe('existing content');
      expect(mockBundle['images/logo.png']).toBe('binary data');
      
      // Should add new metadata files
      expect(mockBundle['sitemap.xml']).toBeDefined();
      expect(mockBundle['rss.xml']).toBeDefined();
    });
  });
});

================================================================================

File: core/services/builder/__tests__/siteBuilder.service.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import { buildSiteBundle } from '../../siteBuilder.service';
import type { LocalSiteData } from '@/core/types';
import * as themeService from '../../config/theme.service';
import * as assetBuilder from '../asset.builder';
import * as sourceBuilder from '../source.builder';
import * as metadataBuilder from '../metadata.builder';
import * as pageBuilder from '../page.builder';

// Mock all the builder modules
jest.mock('../../config/theme.service');
jest.mock('../asset.builder');
jest.mock('../source.builder');
jest.mock('../metadata.builder');
jest.mock('../page.builder');
jest.mock('../../fileTree.service');

describe('siteBuilder.service', () => {
  const mockSiteData: LocalSiteData = {
    siteId: 'test-site',
    manifest: {
      title: 'Test Site',
      description: 'Test description',
      structure: [
        {
          type: 'page',
          title: 'Home',
          path: 'index.html',
          slug: 'home'
        }
      ],
      theme: {
        name: 'default',
        config: {
          color_primary: '#0066cc'
        }
      }
    },
    contentFiles: [
      {
        slug: 'home',
        path: 'content/index.md',
        frontmatter: {
          title: 'Home Page',
          layout: 'page'
        },
        content: 'Welcome to our site!'
      }
    ]
  };

  const mockMergedConfig = {
    color_primary: '#0066cc',
    color_background: '#ffffff'
  };

  const mockHtmlPages = {
    'index.html': '<html><body>Home Page Content</body></html>',
    'about.html': '<html><body>About Page Content</body></html>'
  };

  const mockAllStaticNodes = [
    {
      type: 'page' as const,
      title: 'Home',
      path: 'index.html',
      slug: 'home'
    }
  ];

  beforeEach(() => {
    jest.clearAllMocks();

    // Mock theme service
    (themeService.getMergedThemeDataForForm as jest.Mock).mockResolvedValue({
      schema: null,
      initialConfig: mockMergedConfig
    });

    // Mock builders
    (pageBuilder.generateHtmlPages as jest.Mock).mockResolvedValue(mockHtmlPages);
    (sourceBuilder.bundleSourceFiles as jest.Mock).mockResolvedValue(undefined);
    (assetBuilder.bundleAllAssets as jest.Mock).mockResolvedValue(undefined);
    (metadataBuilder.generateMetadataFiles as jest.Mock).mockReturnValue(undefined);

    // Mock flattenTree
    const fileTreeService = require('../../fileTree.service');
    fileTreeService.flattenTree = jest.fn().mockReturnValue(mockAllStaticNodes);
  });

  describe('buildSiteBundle', () => {
    test('builds complete site bundle successfully', async () => {
      const result = await buildSiteBundle(mockSiteData);

      // Should return the generated HTML pages
      expect(result).toEqual(mockHtmlPages);

      // Should merge theme config
      expect(themeService.getMergedThemeDataForForm).toHaveBeenCalledWith(
        'default',
        { color_primary: '#0066cc' }
      );

      // Should call all builders in correct order
      expect(pageBuilder.generateHtmlPages).toHaveBeenCalledWith(
        expect.objectContaining({
          manifest: expect.objectContaining({
            theme: expect.objectContaining({
              config: mockMergedConfig
            })
          })
        }),
        mockAllStaticNodes
      );

      expect(sourceBuilder.bundleSourceFiles).toHaveBeenCalledWith(
        mockHtmlPages,
        expect.any(Object)
      );

      expect(assetBuilder.bundleAllAssets).toHaveBeenCalledWith(
        mockHtmlPages,
        expect.any(Object)
      );

      expect(metadataBuilder.generateMetadataFiles).toHaveBeenCalledWith(
        mockHtmlPages,
        expect.any(Object),
        mockAllStaticNodes
      );
    });

    test('throws error when content files are not loaded', async () => {
      const siteDataWithoutContent = {
        ...mockSiteData,
        contentFiles: undefined
      };

      await expect(buildSiteBundle(siteDataWithoutContent))
        .rejects
        .toThrow('Cannot build site: content files are not loaded.');
    });

    test('handles theme config merging failure gracefully', async () => {
      (themeService.getMergedThemeDataForForm as jest.Mock).mockRejectedValue(
        new Error('Theme config error')
      );

      await expect(buildSiteBundle(mockSiteData))
        .rejects
        .toThrow('Theme config error');
    });

    test('synchronizes site data with merged theme config', async () => {
      await buildSiteBundle(mockSiteData);

      // Verify the synchronized site data has merged config
      const [[synchronizedSiteData]] = (pageBuilder.generateHtmlPages as jest.Mock).mock.calls;
      
      expect(synchronizedSiteData.manifest.theme.config).toEqual(mockMergedConfig);
      expect(synchronizedSiteData.siteId).toBe('test-site');
      expect(synchronizedSiteData.contentFiles).toEqual(mockSiteData.contentFiles);
    });

    test('passes flattened nodes to all relevant builders', async () => {
      await buildSiteBundle(mockSiteData);

      // Verify flattenTree was called with correct parameters
      const fileTreeService = require('../../fileTree.service');
      expect(fileTreeService.flattenTree).toHaveBeenCalledWith(
        mockSiteData.manifest.structure,
        mockSiteData.contentFiles
      );

      // Verify builders received the flattened nodes
      expect(pageBuilder.generateHtmlPages).toHaveBeenCalledWith(
        expect.any(Object),
        mockAllStaticNodes
      );

      expect(metadataBuilder.generateMetadataFiles).toHaveBeenCalledWith(
        expect.any(Object),
        expect.any(Object),
        mockAllStaticNodes
      );
    });

    test('handles empty content files array', async () => {
      const siteDataEmptyContent = {
        ...mockSiteData,
        contentFiles: []
      };

      const result = await buildSiteBundle(siteDataEmptyContent);

      expect(result).toEqual(mockHtmlPages);
      expect(pageBuilder.generateHtmlPages).toHaveBeenCalledWith(
        expect.objectContaining({
          contentFiles: []
        }),
        mockAllStaticNodes
      );
    });

    test('preserves all site data properties during synchronization', async () => {
      const siteDataWithExtras = {
        ...mockSiteData,
        layoutFiles: [{ path: 'layout.json', content: '{}' }],
        themeFiles: [{ path: 'theme.css', content: 'body {}' }],
        dataFiles: { 'categories.json': '[]' },
        secrets: { apiKey: 'secret' }
      };

      await buildSiteBundle(siteDataWithExtras);

      const [[synchronizedSiteData]] = (pageBuilder.generateHtmlPages as jest.Mock).mock.calls;
      
      expect(synchronizedSiteData.layoutFiles).toEqual(siteDataWithExtras.layoutFiles);
      expect(synchronizedSiteData.themeFiles).toEqual(siteDataWithExtras.themeFiles);
      expect(synchronizedSiteData.dataFiles).toEqual(siteDataWithExtras.dataFiles);
      expect(synchronizedSiteData.secrets).toEqual(siteDataWithExtras.secrets);
    });

    test('handles builder failures', async () => {
      (pageBuilder.generateHtmlPages as jest.Mock).mockRejectedValue(
        new Error('Page generation failed')
      );

      await expect(buildSiteBundle(mockSiteData))
        .rejects
        .toThrow('Page generation failed');
    });

    test('accumulates bundle content from all builders', async () => {
      // Mock builders to add content to bundle
      (sourceBuilder.bundleSourceFiles as jest.Mock).mockImplementation((bundle) => {
        bundle['_site/manifest.json'] = '{"title":"Test"}';
        bundle['_site/content/index.md'] = '# Home';
      });

      (assetBuilder.bundleAllAssets as jest.Mock).mockImplementation((bundle) => {
        bundle['themes/default/theme.css'] = 'body { margin: 0; }';
        bundle['images/logo.png'] = 'binary-data';
      });

      (metadataBuilder.generateMetadataFiles as jest.Mock).mockImplementation((bundle) => {
        bundle['sitemap.xml'] = '<sitemap></sitemap>';
        bundle['rss.xml'] = '<rss></rss>';
      });

      const result = await buildSiteBundle(mockSiteData);

      // Should include HTML pages and all builder additions
      expect(result).toEqual({
        'index.html': '<html><body>Home Page Content</body></html>',
        'about.html': '<html><body>About Page Content</body></html>',
        '_site/manifest.json': '{"title":"Test"}',
        '_site/content/index.md': '# Home',
        'themes/default/theme.css': 'body { margin: 0; }',
        'images/logo.png': 'binary-data',
        'sitemap.xml': '<sitemap></sitemap>',
        'rss.xml': '<rss></rss>'
      });
    });
  });
});

================================================================================

File: core/services/builder/__tests__/asset.builder.test.ts
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-require-imports */
import { bundleAllAssets } from '../asset.builder';
import type { LocalSiteData, SiteBundle, ImageRef } from '@/core/types';
import * as configHelpers from '../../config/configHelpers.service';
import * as imagesService from '../../images/images.service';

// Mock dependencies
jest.mock('../../config/configHelpers.service');
jest.mock('../../images/images.service');

describe('asset.builder', () => {
  const mockSiteData: LocalSiteData = {
    siteId: 'test-site',
    manifest: {
      title: 'Test Site',
      description: 'Test description',
      structure: [],
      theme: {
        name: 'default',
        config: {}
      },
      logo: {
        serviceId: 'local',
        src: 'logo.png'
      }
    },
    contentFiles: [
      {
        slug: 'post1',
        path: 'content/posts/post1.md',
        frontmatter: {
          title: 'Post 1',
          layout: 'blog',
          featured_image: {
            serviceId: 'local',
            src: 'featured1.jpg'
          } as ImageRef
        },
        content: 'Post content'
      },
      {
        slug: 'post2',
        path: 'content/posts/post2.md',
        frontmatter: {
          title: 'Post 2',
          layout: 'page'
        },
        content: 'Another post'
      }
    ]
  };

  const mockThemeManifest = {
    name: 'Default Theme',
    version: '1.0.0',
    files: [
      { path: 'theme.json', type: 'manifest' },
      { path: 'base.hbs', type: 'base' },
      { path: 'css/theme.css', type: 'stylesheet' }
    ]
  };

  const mockLayoutManifest = {
    name: 'Blog Layout',
    version: '1.0.0',
    files: [
      { path: 'layout.json', type: 'manifest' },
      { path: 'blog.hbs', type: 'template' }
    ]
  };

  const mockImageService = {
    getExportableAssets: jest.fn()
  };

  let mockBundle: SiteBundle;

  beforeEach(() => {
    jest.clearAllMocks();
    mockBundle = {};

    // Mock config helpers
    (configHelpers.getJsonAsset as jest.Mock)
      .mockImplementation(async (siteData, assetType, assetId, fileName) => {
        if (assetType === 'theme' && assetId === 'default' && fileName === 'theme.json') {
          return mockThemeManifest;
        }
        if (assetType === 'layout' && assetId === 'blog' && fileName === 'layout.json') {
          return mockLayoutManifest;
        }
        return null;
      });

    (configHelpers.getAssetContent as jest.Mock)
      .mockImplementation(async (siteData, assetType, assetId, filePath) => {
        if (filePath === 'base.hbs') return '<html>{{{body}}}</html>';
        if (filePath === 'css/theme.css') return 'body { margin: 0; }';
        if (filePath === 'blog.hbs') return '<article>{{{content}}}</article>';
        return null;
      });

    // Mock image service
    (imagesService.getActiveImageService as jest.Mock).mockReturnValue(mockImageService);
    mockImageService.getExportableAssets.mockResolvedValue([
      { path: 'images/logo.png', data: 'logo-binary-data' },
      { path: 'images/featured1.jpg', data: 'featured-binary-data' }
    ]);
  });

  describe('bundleAllAssets', () => {
    test('bundles theme assets correctly', async () => {
      await bundleAllAssets(mockBundle, mockSiteData);

      // Should load theme manifest
      expect(configHelpers.getJsonAsset).toHaveBeenCalledWith(
        mockSiteData,
        'theme',
        'default',
        'theme.json'
      );

      // Should load theme files
      expect(configHelpers.getAssetContent).toHaveBeenCalledWith(
        mockSiteData,
        'theme',
        'default',
        'base.hbs'
      );
      expect(configHelpers.getAssetContent).toHaveBeenCalledWith(
        mockSiteData,
        'theme',
        'default',
        'css/theme.css'
      );

      // Should add theme files to bundle with correct paths
      expect(mockBundle['_site/themes/default/base.hbs']).toBe('<html>{{{body}}}</html>');
      expect(mockBundle['_site/themes/default/css/theme.css']).toBe('body { margin: 0; }');
    });

    test('bundles layout assets correctly', async () => {
      await bundleAllAssets(mockBundle, mockSiteData);

      // Should load layout manifest for used layouts
      expect(configHelpers.getJsonAsset).toHaveBeenCalledWith(
        mockSiteData,
        'layout',
        'blog',
        'layout.json'
      );

      // Should load layout files
      expect(configHelpers.getAssetContent).toHaveBeenCalledWith(
        mockSiteData,
        'layout',
        'blog',
        'blog.hbs'
      );

      // Should add layout files to bundle with correct paths
      expect(mockBundle['_site/layouts/blog/blog.hbs']).toBe('<article>{{{content}}}</article>');
    });

    test('bundles only unique layouts', async () => {
      const siteDataDuplicateLayouts = {
        ...mockSiteData,
        contentFiles: [
          ...mockSiteData.contentFiles!,
          {
            slug: 'post3',
            path: 'content/posts/post3.md',
            frontmatter: { title: 'Post 3', layout: 'blog' },
            content: 'Third post'
          }
        ]
      };

      await bundleAllAssets(mockBundle, siteDataDuplicateLayouts);

      // Should only call getJsonAsset once for 'blog' layout despite multiple uses
      const blogLayoutCalls = (configHelpers.getJsonAsset as jest.Mock).mock.calls.filter(
        call => call[1] === 'layout' && call[2] === 'blog'
      );
      expect(blogLayoutCalls).toHaveLength(1);
    });

    test('bundles image assets correctly', async () => {
      await bundleAllAssets(mockBundle, mockSiteData);

      // Should get active image service
      expect(imagesService.getActiveImageService).toHaveBeenCalledWith(mockSiteData.manifest);

      // Should get exportable assets with all image refs
      expect(mockImageService.getExportableAssets).toHaveBeenCalledWith(
        'test-site',
        expect.arrayContaining([
          mockSiteData.manifest.logo,
          mockSiteData.contentFiles![0].frontmatter.featured_image
        ])
      );

      // Should add image assets to bundle
      expect(mockBundle['images/logo.png']).toBe('logo-binary-data');
      expect(mockBundle['images/featured1.jpg']).toBe('featured-binary-data');
    });

    test('handles missing theme manifest', async () => {
      (configHelpers.getJsonAsset as jest.Mock).mockResolvedValue(null);

      await bundleAllAssets(mockBundle, mockSiteData);

      // Should not throw error
      expect(mockBundle).toEqual({
        'images/logo.png': 'logo-binary-data',
        'images/featured1.jpg': 'featured-binary-data'
      });
    });

    test('handles missing layout manifest', async () => {
      (configHelpers.getJsonAsset as jest.Mock)
        .mockImplementation(async (siteData, assetType, assetId, fileName) => {
          if (assetType === 'theme') return mockThemeManifest;
          return null; // No layout manifest
        });

      await bundleAllAssets(mockBundle, mockSiteData);

      // Should still bundle theme and images
      expect(mockBundle['_site/themes/default/base.hbs']).toBe('<html>{{{body}}}</html>');
      expect(mockBundle['images/logo.png']).toBe('logo-binary-data');
    });

    test('handles missing asset content', async () => {
      (configHelpers.getAssetContent as jest.Mock).mockResolvedValue(null);

      await bundleAllAssets(mockBundle, mockSiteData);

      // Should not add null content to bundle
      expect(mockBundle['_site/themes/default/base.hbs']).toBeUndefined();
      expect(mockBundle['images/logo.png']).toBe('logo-binary-data');
    });

    test('handles empty content files', async () => {
      const siteDataNoContent = {
        ...mockSiteData,
        contentFiles: []
      };

      await bundleAllAssets(mockBundle, siteDataNoContent);

      // Should still bundle theme and manifest images
      expect(mockBundle['_site/themes/default/base.hbs']).toBe('<html>{{{body}}}</html>');
      expect(mockBundle['images/logo.png']).toBe('logo-binary-data');
    });

    test('handles no image references', async () => {
      const siteDataNoImages = {
        ...mockSiteData,
        manifest: {
          ...mockSiteData.manifest,
          logo: undefined
        },
        contentFiles: [
          {
            slug: 'simple',
            path: 'content/simple.md',
            frontmatter: { title: 'Simple', layout: 'page' },
            content: 'Simple content'
          }
        ]
      };

      mockImageService.getExportableAssets.mockResolvedValue([]);

      await bundleAllAssets(mockBundle, siteDataNoImages);

      // Should still bundle theme assets
      expect(mockBundle['_site/themes/default/base.hbs']).toBe('<html>{{{body}}}</html>');
      
      // Should not have any image assets
      expect(Object.keys(mockBundle).filter(key => key.startsWith('images/'))).toHaveLength(0);
    });

    test('finds all nested image references', async () => {
      const siteDataNestedImages = {
        ...mockSiteData,
        contentFiles: [
          {
            slug: 'complex',
            path: 'content/complex.md',
            frontmatter: {
              title: 'Complex',
              layout: 'page',
              gallery: {
                images: [
                  { serviceId: 'local', src: 'gallery1.jpg' } as ImageRef,
                  { serviceId: 'local', src: 'gallery2.jpg' } as ImageRef
                ]
              },
              author: {
                avatar: { serviceId: 'local', src: 'avatar.png' } as ImageRef
              }
            },
            content: 'Complex content'
          }
        ]
      };

      await bundleAllAssets(mockBundle, siteDataNestedImages);

      // Should find all nested image references
      const calls = mockImageService.getExportableAssets.mock.calls[0];
      const imageRefs = calls[1];
      
      expect(imageRefs).toEqual(
        expect.arrayContaining([
          mockSiteData.manifest.logo,
          expect.objectContaining({ src: 'gallery1.jpg' }),
          expect.objectContaining({ src: 'gallery2.jpg' }),
          expect.objectContaining({ src: 'avatar.png' })
        ])
      );
    });

    test('handles image service errors gracefully', async () => {
      mockImageService.getExportableAssets.mockRejectedValue(new Error('Image service error'));

      // Should not throw, but log error and continue
      await expect(bundleAllAssets(mockBundle, mockSiteData)).rejects.toThrow('Image service error');
    });
  });
});

================================================================================

File: config/editorConfig.ts
// src/config/editorConfig.ts
import type { ThemeInfo, LayoutInfo } from '@/core/types';
import type { RJSFSchema, UiSchema } from '@rjsf/utils'; 

/**
 * The official version of the Sparktype generator client.
 * This is written to the manifest.json on site creation and can be used
 * by the theme engine or other tools to check for compatibility.
 */
export const GENERATOR_VERSION = 'SparktypeClient/1.3.0';

/**
 * The URL segment used to identify a new, unsaved content file.
 * This allows the editor to distinguish between editing an existing file
 * and creating a new one.
 * e.g., /edit/site-id/content/blog/_new
 */
export const NEW_FILE_SLUG_MARKER = '_new';

/**
 * The delay in milliseconds for the autosave functionality in the content editor.
 * A longer delay reduces server/storage load but increases risk of data loss on close.
 * A shorter delay saves more often but can be more "chatty".
 */
export const AUTOSAVE_DELAY = 2500;

/**
 * The default layout path used for any new single page.
 * The system will fall back to this if a more specific layout isn't defined.
 * The path is relative to '/public/layouts/'.
 * e.g., 'page'
 */
export const DEFAULT_PAGE_LAYOUT_PATH = 'page';

/**
 * The default layout path used for any new collection page.
 */
export const DEFAULT_COLLECTION_LAYOUT_PATH = 'blog';

/**
 * The master list of all built-in layouts. The system uses this
 * array to discover and load all core layout manifests.
 */
export const CORE_LAYOUTS: LayoutInfo[] = [
  // --- Page Layouts ---
  { 
    id: 'page', 
    name: 'Standard Page', 
    type: 'page', // This type is used for initial filtering in dialogs
    path: 'page', 
    description: "A clean, single-column page layout." 
  },
  
  // --- Collection Layouts ---
  { 
    id: 'blog', 
    name: 'Blog Layout', 
    type: 'collection', // This is critical for the "Create Collection" dialog
    path: 'blog', 
    description: "A full-featured layout for blog posts and categories."
  },
];

export const CORE_THEMES: ThemeInfo[] = [
  { id: 'default', name: 'Default Theme', path: 'default' },
];

/**
 * Default configuration for a new site's homepage (index.md).
 * Centralizes the initial title and content.
 */
export const DEFAULT_HOMEPAGE_CONFIG = {
  TITLE: 'Welcome to your new site!',
  /**
   * Generates the default markdown content for the homepage.
   * @param {string} siteTitle - The title of the site to include in the welcome message.
   * @returns {string} The formatted markdown string.
   */
  getContent: (siteTitle: string): string => 
    `## Welcome to ${siteTitle}\n\nThis is your new site's homepage. You can start editing it now.`
};

/**
 * The universal base schema for all content frontmatter.
 * This object is imported directly, eliminating network requests.
 */
export const BASE_SCHEMA: { schema: RJSFSchema; uiSchema: UiSchema } = {
  schema: {
    title: 'Base content fields',
    type: 'object',
    properties: {
      // --- CORRECTED SECTION ---
      featured_image: {
        title: 'Featured Image',
        description: 'The main image for this content, used in listings and social sharing.',
        type: 'string',
      },
      banner_image: {
        title: 'Banner Image',
        description: 'A large, wide image for the top of the page.',
        type: 'string', 
      },
      slug: {
        type: 'string',
        title: 'Slug (URL Path)',
        description: 'The URL-friendly version of the title. Auto-generated, but can be edited.',
      },
      date: {
        type: 'string',
        title: 'Publication date',
        format: 'date',
      },
      status: {
        type: 'string',
        title: 'Status',
        enum: ['published', 'draft'],
        default: 'draft',
      },
      author: {
        type: 'string',
        title: 'Author',
      },
      tags: {
        type: 'array',
        title: 'Tags',
        items: {
          type: 'string',
        },
      },
    },
  },
   uiSchema: {
    featured_image: {
      'ui:widget': 'imageUploader',
      'ui:options': {
      }
    },
    banner_image: {
      'ui:widget': 'imageUploader',
    },
    slug: {
      'ui:widget': 'hidden',
    },
    tags: {
      'ui:options': {
        addable: true,
        removable: true,
      },
    },
  },
};

export const MEMORY_CONFIG = {
  /**
   * The maximum file size in bytes for a single raster image upload (e.g., JPG, PNG).
   * This is a critical check to prevent memory spikes from loading large files.
   */
  MAX_UPLOAD_SIZE: 5 * 1024 * 1024,      // 5MB upload limit

  /**
   * A stricter, smaller size limit for SVG files, as they are text-based and can
   * contain excessively complex paths or malicious scripts.
   */
  MAX_SVG_SIZE: 512 * 1024,              // 512KB SVG limit

  /**
   * A list of supported image MIME types for backend validation.
   * This ensures the application only processes file types it understands.
   */
  SUPPORTED_IMAGE_TYPES: [
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/webp',
    'image/svg+xml'
  ] as const,

  /**
   * A list of supported file extensions for the UI file picker.
   * This provides a better user experience by filtering files in the dialog.
   */
  SUPPORTED_EXTENSIONS: [
    '.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg'
  ] as const,

} as const;

================================================================================

File: features/viewer/components/SiteViewer.tsx
// src/features/viewer/components/SiteViewer.tsx

import { useEffect, useState, useCallback } from 'react';
import { useParams, useLocation, useNavigate } from 'react-router-dom';
import { Link } from 'react-router-dom';

// State and Services
import { useAppStore } from '@/core/state/useAppStore';
import { resolvePageContent } from '@/core/services/pageResolver.service';
import { render as renderWithTheme } from '@/core/services/renderer/render.service';

// Types
import { type AppStore } from '@/core/state/useAppStore';
import { PageType } from '@/core/types';

// UI Components
import { Button } from '@/core/components/ui/button';
import { AlertTriangle, Edit } from 'lucide-react';

export default function SiteViewer() {
  // --- 1. Use react-router-dom hooks ---
  const { siteId = '' } = useParams<{ siteId: string }>();
  const location = useLocation(); // Provides the full current path
  const navigate = useNavigate(); // For updating the URL

  const site = useAppStore(useCallback((state: AppStore) => state.getSiteById(siteId), [siteId]));

  const [htmlContent, setHtmlContent] = useState<string>('<p>Loading Preview...</p>');
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  // The base path for the viewer, used to calculate relative paths
  const viewRootPath = `/sites/${siteId}/view`;

  // --- 2. Derive the relative path from the location pathname ---
  const currentRelativePath = location.pathname.startsWith(viewRootPath)
    ? location.pathname.substring(viewRootPath.length) || '/'
    : '/';

  // This function generates the final HTML and sets the iframe content
  const updateIframeContent = useCallback(async () => {
    if (!site?.contentFiles) {
      setHtmlContent('<p>Loading site data...</p>');
      return;
    }

    // The slug array is derived from the relative path inside the viewer
    const slugArray = currentRelativePath.split('/').filter(Boolean);
    const resolution = resolvePageContent(site, slugArray);
    
    if (resolution.type === PageType.NotFound) {
      setErrorMessage(resolution.errorMessage);
      setHtmlContent(''); // Clear content on error
      return;
    }

    try {
      const pureHtml = await renderWithTheme(site, resolution, {
        // The siteRootPath is passed to the renderer so it can generate correct hash links
        siteRootPath: `#${viewRootPath}`,
        isExport: false,
      });

      // The communication script is updated to post the path part of the hash URL
      const communicationScript = `
        <script>
          document.addEventListener('click', function(e) {
            const link = e.target.closest('a');
            if (!link || !link.href) return;
            if (link.hash && link.pathname === window.location.pathname) return;

            // Check if the link is a hash-based internal link
            const url = new URL(link.href);
            if (url.origin === window.location.origin && url.hash) {
              e.preventDefault();
              const newHashPath = url.hash.substring(1); // Get path from hash (e.g., /sites/123/view/about)
              // Post the new hash path to the parent window
              window.parent.postMessage({ type: 'SIGNUM_NAVIGATE', path: newHashPath }, window.location.origin);
            }
          });
        </script>
      `;

      const finalHtml = pureHtml.replace('</body>', `${communicationScript}</body>`);
      setHtmlContent(finalHtml);
      setErrorMessage(null);
    } catch (e) {
      const error = e as Error;
      console.error("Error during site rendering:", error);
      setErrorMessage(`Theme Error: ${error.message}`);
      setHtmlContent('');
    }
  }, [site, viewRootPath, currentRelativePath]);

  // Re-render the iframe whenever the path or site data changes.
  useEffect(() => {
    updateIframeContent();
  }, [updateIframeContent]);


  // --- 3. Manage Browser History with useNavigate ---
  // This effect listens for messages from the iframe to update the browser's URL bar.
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      if (event.origin !== window.location.origin) return;
      
      const { type, path } = event.data;
      if (type === 'SIGNUM_NAVIGATE' && path !== location.pathname) {
        // Use navigate to update the hash URL, which will trigger a re-render
        navigate(path);
      }
    };

    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
    
    // We don't need the 'popstate' listener anymore because `useLocation` from react-router-dom handles it.
  }, [location.pathname, navigate]);


  // Sandbox attributes remain the same
  const sandboxAttributes = 
    process.env.NODE_ENV === 'development'
      ? 'allow-scripts allow-forms allow-same-origin'
      : 'allow-scripts allow-forms';

  // Error state rendering remains the same
  if (errorMessage) {
    return (
      <div className="p-8 text-center">
        <AlertTriangle className="h-12 w-12 text-destructive mx-auto mb-4" />
        <h1 className="text-2xl font-bold mb-2">Could Not Render Preview</h1>
        <p className="text-muted-foreground">{errorMessage}</p>
        <Button asChild variant="default" className="mt-6">
          <Link to={`/sites/${siteId}/edit`}>
            <Edit className="mr-2 h-4 w-4" /> Go to Editor
          </Link>
        </Button>
      </div>
    );
  }

  // The iframe itself is unchanged
  return (
    <iframe
      srcDoc={htmlContent}
      title={site?.manifest.title || 'Site Preview'}
      className="w-full h-full border-0"
      sandbox={sandboxAttributes}
      key={siteId} // Add key to force re-mount if siteId changes
    />
  );
}

================================================================================

File: features/viewer/components/MarkdownRenderer.tsx
// src/components/browsing/MarkdownRenderer.tsx
'use client'; 

import { marked } from 'marked';
import { useMemo } from 'react';
import DOMPurify from 'dompurify';

interface MarkdownRendererProps {
  markdown: string;
}

export default function MarkdownRenderer({ markdown }: MarkdownRendererProps) {
  // Parse the markdown string to HTML.
  // useMemo will re-calculate only if the 'markdown' prop changes.
  const html = useMemo(() => {
    if (typeof window === 'undefined') {

    }
    const rawHtml = marked.parse(markdown) as string;
    if (typeof window !== 'undefined') { 
    return DOMPurify.sanitize(rawHtml);
     }
    return rawHtml;
  }, [markdown]);

  // Using dangerouslySetInnerHTML because 'marked' produces an HTML string.
  // Ensure that the 'markdown' content is from a trusted source or sanitized.
  // Since in Sparktype, users are creating their own local content first,
  // the trust level is higher for this local-only phase.
  // For remote content later, sanitization will be critical.
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}

================================================================================

File: features/site-settings/components/SiteSettingsForm.tsx
// src/features/site-settings/components/SiteSettingsForm.tsx
'use client';

import { Label } from '@/core/components/ui/label';
import { Input } from '@/core/components/ui/input';
import { Textarea } from '@/core/components/ui/textarea';
import type { ImageRef } from '@/core/types';
import SiteAssetUploader from './SiteAssetsUploader';
import SchemaDrivenForm from '@/core/components/SchemaDrivenForm';
import type { RJSFSchema } from '@rjsf/utils';

interface SiteSettingsFormProps {
  siteId: string;
  formData: {
    title: string;
    description: string;
    author: string;
    baseUrl: string;
    logo: ImageRef | undefined;
    favicon: ImageRef | undefined;
  };
  themeDataSchema?: RJSFSchema;
  themeData?: Record<string, unknown>;
  onFormChange: (newData: SiteSettingsFormProps['formData']) => void;
  onThemeDataChange?: (newData: Record<string, unknown>) => void;
}

export default function SiteSettingsForm({ 
  siteId, 
  formData, 
  onFormChange, 
  themeDataSchema, 
  themeData, 
  onThemeDataChange 
}: SiteSettingsFormProps) {
  
  // FIX: Typed the 'value' parameter to 'unknown' for better type safety.
  const handleChange = (field: keyof typeof formData, value: unknown) => {
    onFormChange({ ...formData, [field]: value });
  };

  return (
    <div className="space-y-6">
      <div className="space-y-4">
        <h2 className="text-lg font-semibold">Site Identity</h2>
        <SiteAssetUploader 
          siteId={siteId}
          label="Site Logo"
          value={formData.logo}
          onChange={(newRef) => handleChange('logo', newRef)}
          onRemove={() => handleChange('logo', undefined)}
        />
        <SiteAssetUploader
          siteId={siteId}
          label="Favicon"
          value={formData.favicon}
          onChange={(newRef) => handleChange('favicon', newRef)}
          onRemove={() => handleChange('favicon', undefined)}
        />
      </div>

      <div className="border-t pt-6 space-y-4">
        <h2 className="text-lg font-semibold">Core Details</h2>
        <div className="space-y-2">
            <Label htmlFor="title">Site Title</Label>
            <Input
                id="title"
                value={formData.title}
                onChange={(e) => handleChange('title', e.target.value)}
                placeholder="My Awesome Site"
            />
        </div>
        <div className="space-y-2">
            <Label htmlFor="description">Site Description</Label>
            <Textarea
                id="description"
                value={formData.description}
                onChange={(e) => handleChange('description', e.target.value)}
                placeholder="A short, catchy description."
                rows={3}
            />
        </div>
        <div className="space-y-2">
            <Label htmlFor="author">Author (Optional)</Label>
            <Input
                id="author"
                value={formData.author}
                onChange={(e) => handleChange('author', e.target.value)}
                placeholder="Your Name or Organization"
            />
        </div>
        <div className="space-y-2">
            <Label htmlFor="baseUrl">Base URL</Label>
            <Input
                id="baseUrl"
                type="url"
                value={formData.baseUrl}
                onChange={(e) => handleChange('baseUrl', e.target.value)}
                placeholder="https://www.my-awesome-site.com"
            />
        </div>
      </div>

      {themeDataSchema && onThemeDataChange && (
        <div className="border-t pt-6 space-y-4">
          <h2 className="text-lg font-semibold">Theme Content</h2>
          <p className="text-sm text-muted-foreground">
            Configure additional content fields defined by your theme.
          </p>
          <SchemaDrivenForm
            schema={themeDataSchema}
            formData={themeData || {}}
            onFormChange={(data: object) => onThemeDataChange(data as Record<string, unknown>)}
            liveValidate={false}
          />
        </div>
      )}
    </div>
  );
}

================================================================================

File: features/site-settings/components/SiteAssetsUploader.tsx
// src/features/site-settings/components/SiteAssetsUploader.tsx
'use client';

import { useEffect, useState } from 'react';
import Image from 'next/image';
import { type ImageRef } from '@/core/types';
import { useAppStore } from '@/core/state/useAppStore';
import { getActiveImageService } from '@/core/services/images/images.service';
import { Button } from '@/core/components/ui/button';
import { UploadCloud, XCircle } from 'lucide-react';
import { toast } from 'sonner';
import { MEMORY_CONFIG } from '@/config/editorConfig';

/**
 * Defines the props for the SiteAssetUploader component.
 */
interface SiteAssetUploaderProps {
  /** The ID of the current site, needed for the upload service. */
  siteId: string;
  /** A descriptive label for the uploader (e.g., "Site Logo", "Favicon"). */
  label: string;
  /** The current ImageRef object if an image is already set, otherwise undefined. */
  value: ImageRef | undefined;
  /** Callback function triggered when a new image is successfully uploaded. */
  onChange: (newRef: ImageRef) => void;
  /** Callback function triggered when the "Remove" button is clicked. */
  onRemove: () => void;
}

/**
 * A reusable UI component for uploading site-level assets like logos and favicons.
 * It provides a preview, handles the upload flow, and performs client-side validation
 * for file type and size to give the user immediate feedback.
 */
export default function SiteAssetUploader({ siteId, label, value, onChange, onRemove }: SiteAssetUploaderProps) {
  const site = useAppStore(state => state.getSiteById(siteId));
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);

  /**
   * Generates a temporary preview URL for the currently selected image.
   * This effect runs whenever the `value` (the ImageRef) or the `site` data changes.
   * It correctly handles revoking blob URLs to prevent memory leaks.
   */
  useEffect(() => {
    let objectUrl: string | null = null;
    const generatePreview = async () => {
      if (value && site?.manifest) {
        try {
          const service = getActiveImageService(site.manifest);
          // Request a small, fitted derivative for the preview.
          const url = await service.getDisplayUrl(site.manifest, value, { width: 128, height: 128, crop: 'fit' }, false);
          setPreviewUrl(url);
          // Keep track of blob URLs so they can be revoked on cleanup.
          if (url.startsWith('blob:')) {
            objectUrl = url;
          }
        } catch (error) {
          console.error(`Could not generate preview for ${label}:`, error);
          setPreviewUrl(null);
        }
      } else {
        setPreviewUrl(null);
      }
    };
    generatePreview();
    
    // Cleanup function to revoke the object URL and prevent memory leaks.
    return () => {
      if (objectUrl) {
        URL.revokeObjectURL(objectUrl);
      }
    };
  }, [value, site, label]);

  /**
   * Handles the file selection event from the input.
   * It performs client-side validation before calling the upload service.
   * @param {React.ChangeEvent<HTMLInputElement>} event The file input change event.
   */
  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file || !site?.manifest) return;

    // --- Client-Side Validation Block ---
    const isSvg = file.type === 'image/svg+xml';
    
    // 1. Validate file type against the configuration.
    if (!MEMORY_CONFIG.SUPPORTED_IMAGE_TYPES.includes(file.type as typeof MEMORY_CONFIG.SUPPORTED_IMAGE_TYPES[number])) {
      toast.error(`Unsupported file type. Please use one of: ${MEMORY_CONFIG.SUPPORTED_EXTENSIONS.join(', ')}`);
      event.target.value = ''; // Reset file input to allow re-selection of the same file.
      return;
    }

    // 2. Validate file size against the appropriate limit.
    const maxSize = isSvg ? MEMORY_CONFIG.MAX_SVG_SIZE : MEMORY_CONFIG.MAX_UPLOAD_SIZE;
    if (file.size > maxSize) {
      const maxSizeFormatted = (maxSize / 1024 / (isSvg ? 1 : 1024)).toFixed(1);
      const unit = isSvg ? 'KB' : 'MB';
      toast.error(`Image is too large. Max size is ${maxSizeFormatted}${unit}.`);
      event.target.value = '';
      return;
    }
    // --- End Validation Block ---
    
    setIsUploading(true);
    try {
      const service = getActiveImageService(site.manifest);
      const newRef = await service.upload(file, siteId);
      onChange(newRef);
      toast.success(`${label} uploaded successfully.`);
    } catch (error) {
      // The service layer will also throw an error, which is caught here.
      // The toast messages from the service are sufficient, so we just log here.
      console.error(`Upload failed for ${label}:`, error);
    } finally {
      setIsUploading(false);
      // Always reset the input value to allow re-uploading the same file if needed.
      event.target.value = '';
    }
  };

  const inputId = `uploader-${label.toLowerCase().replace(/\s/g, '-')}`;

  return (
    <div className="flex items-center gap-4">
      <div className="w-16 h-16 bg-muted rounded-md flex items-center justify-center overflow-hidden flex-shrink-0 relative">
        {previewUrl ? (
          <Image src={previewUrl} alt={`${label} preview`} fill className="object-contain" />
        ) : (
          <UploadCloud className="w-8 h-8 text-muted-foreground" />
        )}
      </div>
      <div className="flex-grow">
        <label htmlFor={inputId} className="font-medium text-sm">{label}</label>
        <div className="flex items-center gap-2 mt-1">
          <Button asChild size="sm" variant="outline" disabled={isUploading}>
            {/* The label is associated with the input, making the button clickable for upload */}
            <label htmlFor={inputId} className="cursor-pointer">
              {isUploading ? 'Uploading...' : (value ? 'Change...' : 'Upload...')}
            </label>
          </Button>
          <input 
            type="file" 
            id={inputId} 
            className="hidden" 
            onChange={handleFileSelect} 
            // Use the config to filter the file picker dialog.
            accept={MEMORY_CONFIG.SUPPORTED_EXTENSIONS.join(',')} 
          />
          {value && (
            <Button size="sm" variant="ghost" className="text-destructive hover:text-destructive" onClick={onRemove}>
              <XCircle className="w-4 h-4 mr-1" />
              Remove
            </Button>
          )}
        </div>
      </div>
    </div>
  );
}

================================================================================

File: features/site-settings/components/SettingsNav.tsx
// src/features/site-settings/components/SettingsNav.tsx

import { NavLink, useParams } from 'react-router-dom'; // Import NavLink and useParams
import { TbUserCircle, TbPalette, TbPhoto } from 'react-icons/tb';
import { cn } from '@/core/libraries/utils';

/**
 * Renders the vertical navigation menu for the settings section.
 * It uses NavLink from react-router-dom to automatically handle active link styling.
 */
export default function SettingsNav() {
  const { siteId } = useParams<{ siteId: string }>();

  // The base path for all settings links.
  const settingsBasePath = `/sites/${siteId}/settings`;

  const navItems = [
    // Use the `end` prop for the index route to prevent it from matching all child routes.
    { to: settingsBasePath, title: 'Site details', icon: TbUserCircle, end: true },
    { to: `${settingsBasePath}/theme`, title: 'Theme config', icon: TbPalette, end: false },
    { to: `${settingsBasePath}/images`, title: 'Image handling', icon: TbPhoto, end: false },
  ];

  return (
    <div className="flex h-full flex-col p-4">
      <h2 className="px-2 text-lg font-semibold tracking-tight">Settings</h2>
      <nav className="mt-4 flex flex-col gap-1">
        {navItems.map((item) => (
          <NavLink
            key={item.to}
            to={item.to}
            end={item.end} // The 'end' prop ensures exact matching for the parent route
            // The `className` prop on NavLink can accept a function that receives an `isActive` boolean.
            className={({ isActive }) =>
              cn(
                'flex items-center gap-3 rounded-md px-3 py-2 text-sm font-medium transition-colors',
                isActive
                  ? 'bg-primary text-primary-foreground' // Style for the active link
                  : 'text-muted-foreground hover:bg-muted/50 hover:text-foreground' // Style for inactive links
              )
            }
          >
            <item.icon className="h-5 w-5" />
            {item.title}
          </NavLink>
        ))}
      </nav>
    </div>
  );
}

================================================================================

File: features/editor/contexts/useEditor.tsx
// src/features/editor/contexts/useEditor.ts

import { useContext } from 'react';
import { EditorContext, type EditorContextType } from './EditorContext';

/**
 * Custom hook to easily access the EditorContext.
 * Throws an error if used outside of an EditorProvider.
 */
export function useEditor(): EditorContextType {
  const context = useContext(EditorContext);
  if (context === undefined) {
    throw new Error('useEditor must be used within an EditorProvider');
  }
  return context;
}

================================================================================

File: features/editor/contexts/EditorProvider.tsx
// src/features/editor/contexts/EditorProvider.tsx

import { useState, useMemo, useRef, useCallback, type ReactNode } from 'react';
import { toast } from 'sonner';

// Import the context object from its new, dedicated file
import { EditorContext, type SaveState } from './EditorContext';

interface EditorProviderProps {
  children: ReactNode;
}

/**
 * The EditorProvider component. It manages the editor's state and
 * provides it to its children via the EditorContext.
 * This is the only export from this file.
 */
export function EditorProvider({ children }: EditorProviderProps) {
  const [saveState, setSaveState] = useState<SaveState>('no_changes');
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const saveActionRef = useRef<(() => Promise<void>) | null>(null);

  const registerSaveAction = useCallback((saveFn: () => Promise<void>) => {
    saveActionRef.current = saveFn;
  }, []);

  const triggerSave = useCallback(async () => {
    if (saveActionRef.current) {
      setSaveState('saving');
      try {
        await saveActionRef.current();
        setSaveState('saved');
        setHasUnsavedChanges(false);
        // Reset to idle state after a delay for user feedback
        setTimeout(() => setSaveState('no_changes'), 2000);
      } catch (error) {
        console.error("Save failed:", error);
        toast.error((error as Error).message || "Failed to save.");
        setSaveState('idle'); // Revert to idle on error
      }
    }
  }, []);

  // useMemo hook to prevent re-creating the context value on every render
  const contextValue = useMemo(() => ({
    saveState,
    setSaveState,
    hasUnsavedChanges, 
    setHasUnsavedChanges, 
    triggerSave,
    registerSaveAction,
  }), [saveState, hasUnsavedChanges, triggerSave, registerSaveAction]);

  return (
    <EditorContext.Provider value={contextValue}>
      {children}
    </EditorContext.Provider>
  );
}

================================================================================

File: features/editor/contexts/EditorContext.tsx
// src/features/editor/contexts/EditorContext.ts

import { createContext } from 'react';

// Define the shape of the save state
export type SaveState = 'idle' | 'saving' | 'saved' | 'no_changes';

// Define the type for the context's value
export interface EditorContextType {
  saveState: SaveState;
  setSaveState: (state: SaveState) => void;
  hasUnsavedChanges: boolean;
  setHasUnsavedChanges: (hasChanges: boolean) => void;
  triggerSave: () => Promise<void>;
  registerSaveAction: (saveFn: () => Promise<void>) => void;
}

// Create and export the context object itself
export const EditorContext = createContext<EditorContextType | undefined>(undefined);

================================================================================

File: features/editor/components/MarkdownEditor.tsx
// src/components/publishing/MarkdownEditor.tsx
'use client';

import React, { useState, useEffect, forwardRef, useImperativeHandle } from 'react';
import { Label } from '@/core/components/ui/label';

interface MarkdownEditorProps {
  initialValue: string;
  // onContentChange is now used primarily by the parent to trigger its own state updates
  onContentChange: (markdown: string) => void;
}

// The ref now needs to expose a method to get the current content
export interface MarkdownEditorRef {
  getMarkdown: () => string;
}

const MarkdownEditor = forwardRef<MarkdownEditorRef, MarkdownEditorProps>(
  ({ initialValue, onContentChange }, ref) => {
    // We'll manage the textarea's value with local state
    const [content, setContent] = useState(initialValue);

    // If the initialValue prop changes from the parent (e.g., loading a new file),
    // we update the local state.
    useEffect(() => {
      setContent(initialValue);
    }, [initialValue]);

    // Expose a function for the parent component to get the current content
    useImperativeHandle(ref, () => ({
      getMarkdown: () => {
        return content;
      },
    }));

    // This handler updates both local state and informs the parent of a change
    const handleChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
      const newContent = event.target.value;
      setContent(newContent);
      onContentChange(newContent); // Let the parent know things have changed
    };

    return (
      <div className="space-y-2 h-full">
      <Label htmlFor="content-body" className="text-[10px] font-medium uppercase text-gray-400">
            Content
          </Label>
      <textarea
        id="content-body"
        value={content}
        onChange={handleChange}
        placeholder="Start writing your Markdown here..."
        className="w-full h-full bg-background 
                   text-base font-mono leading-relaxed resize-none 
                   focus:ring-2 focus:ring-ring focus:outline-none"
      />
      </div>
    );
  }
);

MarkdownEditor.displayName = 'MarkdownEditor';
export default MarkdownEditor;

================================================================================

File: features/editor/components/EditorHeader.tsx
// src/features/editor/components/CreateCollectionPageDialog.tsx

import { useState, useEffect, type ReactNode } from 'react';
import { useNavigate } from 'react-router-dom'; // Import the navigate hook

// State Management
import { useAppStore } from '@/core/state/useAppStore';

// Services and Config
import { slugify } from '@/core/libraries/utils';
import { getLayoutManifest } from '@/core/services/config/configHelpers.service';
import { DEFAULT_COLLECTION_LAYOUT_PATH } from '@/config/editorConfig';
import { toast } from 'sonner';
import yaml from 'js-yaml';

// UI & Type Imports
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger, DialogClose } from "@/core/components/ui/dialog";
import { Button } from "@/core/components/ui/button";
import { Input } from "@/core/components/ui/input";
import { Label } from "@/core/components/ui/label";
import { Plus } from 'lucide-react';
import { type MarkdownFrontmatter, type CollectionConfig } from '@/core/types';

interface CreateCollectionPageDialogProps {
  siteId: string;
  children: ReactNode;
  onComplete?: () => void;
}

export default function CreateCollectionPageDialog({ siteId, children, onComplete }: CreateCollectionPageDialogProps) {
  const navigate = useNavigate(); // Use the navigate hook for routing
  const [isOpen, setIsOpen] = useState(false);
  const [name, setName] = useState('');
  const [slug, setSlug] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const site = useAppStore((state) => state.getSiteById(siteId));
  const { addOrUpdateContentFile } = useAppStore.getState();

  // This effect to auto-generate the slug from the name is correct and needs no changes.
  useEffect(() => {
    setSlug(slugify(name));
  }, [name]);

  const handleOpenChange = (open: boolean) => {
    setIsOpen(open);
    if (!open) {
      // Reset state when the dialog is closed
      setTimeout(() => {
        setName('');
        setSlug('');
        setIsSubmitting(false);
      }, 200);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim()) {
      toast.error("Collection name cannot be empty.");
      return;
    }

    const filePath = `content/${slug}.md`;
    if (site?.contentFiles?.some(f => f.path === filePath)) {
        toast.error(`A page with the folder name "${slug}" already exists.`);
        return;
    }

    setIsSubmitting(true);

    try {
      const defaultLayoutManifest = site ? await getLayoutManifest(site, DEFAULT_COLLECTION_LAYOUT_PATH) : null;

      // Start with base config
      const initialCollectionConfig: CollectionConfig = { 
          sort_by: 'date',
          sort_order: 'desc',
          items_per_page: 10,
      };
      
      // Merge in defaults from the layout's display_options if they exist
      if (defaultLayoutManifest?.display_options) {
        for (const [key, option] of Object.entries(defaultLayoutManifest.display_options)) {
            initialCollectionConfig[key] = option.default;
        }
      }

      const frontmatter: MarkdownFrontmatter = {
          title: name.trim(),
          layout: DEFAULT_COLLECTION_LAYOUT_PATH,
          collection: initialCollectionConfig,
      };

      const initialContent = `---\n${yaml.dump(frontmatter)}---\n\n## Welcome to the ${name.trim()} collection!\n\nYou can write an introduction for this collection here.`;
    
      const success = await addOrUpdateContentFile(siteId, filePath, initialContent);
      if (success) {
        toast.success(`Collection page "${name}" created!`);
        handleOpenChange(false);
        onComplete?.();
        
        // --- CHANGE: Use navigate to redirect the user to the new page's editor ---
        navigate(`/sites/${siteId}/edit/content/${slug}`);
      } else {
        throw new Error("Failed to update manifest or save file.");
      }
    } catch (error) {
      toast.error(`Failed to create page: ${(error as Error).message}`);
    } finally {
        setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>Create New Collection Page</DialogTitle>
            <DialogDescription>
              Create a new page that will list other pages, like a blog or a portfolio.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="space-y-1">
              <Label htmlFor="name">Collection Name</Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="e.g., Blog Posts"
                autoComplete="off"
              />
            </div>
            <div className="space-y-1">
              <Label htmlFor="slug">Folder Name (URL)</Label>
              <Input id="slug" value={slug} readOnly className="bg-muted" />
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild><Button type="button" variant="outline">Cancel</Button></DialogClose>
            <Button type="submit" disabled={!name.trim() || isSubmitting}>
                {isSubmitting ? 'Creating...' : <><Plus className="mr-2 h-4 w-4" /> Create Collection</>}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: features/editor/components/ImageUploadWidget.tsx
// src/features/editor/components/ImageUploadWidget.tsx
'use client';

import { useEffect, useState } from 'react';
import Image from 'next/image';
import type { WidgetProps } from '@rjsf/utils';
import { useAppStore } from '@/core/state/useAppStore';
import { getActiveImageService } from '@/core/services/images/images.service';
import { Button } from '@/core/components/ui/button';
import { Label } from '@/core/components/ui/label';
import { UploadCloud, XCircle } from 'lucide-react';
import { toast } from 'sonner';
import { MEMORY_CONFIG } from '@/config/editorConfig';

/**
 * A custom widget for react-jsonschema-form that provides a user-friendly
 * interface for uploading and managing a single image asset.
 *
 * @param {WidgetProps} props - Props provided by react-jsonschema-form.
 */
export default function ImageUploadWidget(props: WidgetProps) {
  // --- FIX: Destructure props correctly, getting siteId from formContext ---
  const { id, label, value: imageRef, onChange, formContext } = props;
  const siteId = formContext.siteId as string;
  // --- END FIX ---

  const site = useAppStore(state => state.getSiteById(siteId));
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);

  // ... (The rest of the component's logic is already correct and doesn't need changes) ...
  useEffect(() => {
    let objectUrl: string | null = null;
    const generatePreview = async () => {
      if (imageRef && site?.manifest) {
        try {
          const service = getActiveImageService(site.manifest);
          const url = await service.getDisplayUrl(site.manifest, imageRef, { width: 256, crop: 'fit' }, false);
          setPreviewUrl(url);
          if (url.startsWith('blob:')) {
            objectUrl = url;
          }
        } catch (error) {
          console.error(`Could not generate preview for ${label}:`, error);
          setPreviewUrl(null);
        }
      } else {
        setPreviewUrl(null);
      }
    };
    generatePreview();
    
    return () => {
      if (objectUrl) {
        URL.revokeObjectURL(objectUrl);
      }
    };
  }, [imageRef, site, label]);

  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file || !site?.manifest) return;

    const isSvg = file.type === 'image/svg+xml';
    if (!MEMORY_CONFIG.SUPPORTED_IMAGE_TYPES.includes(file.type as typeof MEMORY_CONFIG.SUPPORTED_IMAGE_TYPES[number])) {
      toast.error(`Unsupported file type.`);
      return;
    }
    const maxSize = isSvg ? MEMORY_CONFIG.MAX_SVG_SIZE : MEMORY_CONFIG.MAX_UPLOAD_SIZE;
    if (file.size > maxSize) {
      const maxSizeFormatted = (maxSize / 1024 / (isSvg ? 1 : 1024)).toFixed(1);
      const unit = isSvg ? 'KB' : 'MB';
      toast.error(`Image is too large. Max size is ${maxSizeFormatted}${unit}.`);
      return;
    }
    
    setIsUploading(true);
    try {
      const service = getActiveImageService(site.manifest);
      const newRef = await service.upload(file, siteId);
      onChange(newRef);
      toast.success(`${label} uploaded successfully.`);
    } catch (error) {
      console.error(`Upload failed for ${label}:`, error);
      const errorMsg = error instanceof Error ? error.message : 'Upload failed. Please try again.';
      toast.error(errorMsg);
    } finally {
      setIsUploading(false);
      event.target.value = '';
    }
  };

  const handleRemove = () => {
    onChange(undefined);
  };

  return (
    <div className="space-y-2">
      <Label htmlFor={id}>{label}</Label>
      
      {previewUrl ? (
        <div className="relative w-full aspect-video bg-muted rounded-md overflow-hidden">
          <Image src={previewUrl} alt={`${label} preview`} fill className="object-contain" />
          <Button 
            size="icon" 
            variant="destructive" 
            className="absolute top-2 right-2 h-7 w-7"
            onClick={handleRemove}
            aria-label={`Remove ${label}`}
          >
            <XCircle className="h-4 w-4" />
          </Button>
        </div>
      ) : (
        <label
          htmlFor={id}
          className="flex flex-col items-center justify-center w-full h-32 border-2 border-dashed rounded-lg cursor-pointer bg-muted hover:bg-muted/80"
        >
          <div className="flex flex-col items-center justify-center pt-5 pb-6">
            <UploadCloud className="w-8 h-8 mb-2 text-muted-foreground" />
            <p className="mb-1 text-sm text-muted-foreground">
              <span className="font-semibold">Click to upload</span> or drag and drop
            </p>
            <p className="text-xs text-muted-foreground">PNG, JPG, or WEBP (Max 5MB)</p>
          </div>
          <input 
            id={id} 
            type="file" 
            className="hidden" 
            onChange={handleFileSelect}
            accept={MEMORY_CONFIG.SUPPORTED_EXTENSIONS.join(',')}
            disabled={isUploading}
          />
        </label>
      )}

      {isUploading && <p className="text-sm text-muted-foreground">Uploading...</p>}
    </div>
  );
}

================================================================================

File: features/editor/components/PrimaryContentFields.tsx
// src/components/publishing/PrimaryContentFields.tsx
'use client';

import { Input } from '@/core/components/ui/input';
import { Textarea } from '@/core/components/ui/textarea';
import { Label } from '@/core/components/ui/label';
import type { MarkdownFrontmatter } from '@/core/types';

// FIXED: The interface is now much stricter and safer.
// It only defines the properties this component actually cares about.
interface PrimaryFieldsProps {
  frontmatter: {
    title?: string;
    description?: string;
  };
  // The callback expects a partial update to the main frontmatter state.
  onFrontmatterChange: (newData: Partial<MarkdownFrontmatter>) => void;
  showDescription?: boolean;
}

export default function PrimaryContentFields({
  frontmatter,
  onFrontmatterChange,
}: PrimaryFieldsProps) {

  // FIXED: The handler now only passes back the single field that changed.
  // This makes the component more reusable and decoupled from the parent's state shape.
  const handleChange = (field: 'title' | 'description', value: string) => {
    onFrontmatterChange({
      [field]: value,
    });
  };

  return (
    <div className="space-y-4 shrink-0">
      <div className="space-y-2 mb-6 border-b pb-3">
        <Label htmlFor="content-title" className="text-[10px] font-medium uppercase text-gray-400">
          Title
        </Label>
        <Input
          id="content-title"
          placeholder="Enter a title..."
          value={frontmatter.title || ''}
          onChange={(e) => handleChange('title', e.target.value)}
          // These classes create the large, "invisible" input style
          className="text-2xl lg:text-3xl font-bold h-auto p-0 border-0 shadow-none focus-visible:ring-0 bg-transparent"
        />
      </div>

        <div className="space-y-2 mb-6 border-b pb-3">
          <Label htmlFor="content-description" className="text-[10px] font-medium uppercase text-gray-400">
            Description
          </Label>
          <Textarea
            
            placeholder="Add a short description..."
            value={frontmatter.description || ''}
            onChange={(e) => handleChange('description', e.target.value)}
            // Style for a clean, borderless textarea
            className="p-0 border-0 shadow-none focus-visible:ring-0 bg-transparent resize-none text-2xl text-black"
            rows={1}
          />
        </div>
    </div>
  );
}

================================================================================

File: features/editor/components/NewPageDialog.tsx
// src/features/editor/components/NewPageDialog.tsx

import { useState, type ReactNode } from 'react';
import { useNavigate } from 'react-router-dom'; // Import the navigate hook
import { useAppStore } from '@/core/state/useAppStore';
import { slugify } from '@/core/libraries/utils';
import { toast } from 'sonner';
import yaml from 'js-yaml';

// UI & Type Imports
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger, DialogClose } from "@/core/components/ui/dialog";
import { Button } from "@/core/components/ui/button";
import { Input } from "@/core/components/ui/input";
import { Label } from "@/core/components/ui/label";
import { Plus } from 'lucide-react';
import { type MarkdownFrontmatter } from '@/core/types';
import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';

interface NewPageDialogProps {
  siteId: string;
  children: ReactNode;
  onComplete?: () => void;
}

export default function NewPageDialog({ siteId, children, onComplete }: NewPageDialogProps) {
  const navigate = useNavigate(); // Use the navigate hook for routing
  const [isOpen, setIsOpen] = useState(false);
  const [title, setTitle] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const site = useAppStore((state) => state.getSiteById(siteId));
  const { addOrUpdateContentFile } = useAppStore.getState();

  const handleOpenChange = (open: boolean) => {
    setIsOpen(open);
    if (!open) {
      setTimeout(() => {
        setTitle('');
        setIsSubmitting(false);
      }, 200);
    }
  };

  const handleCreatePage = async () => {
    if (!title.trim()) {
      toast.error("Page title cannot be empty.");
      return;
    }
    setIsSubmitting(true);
    const slug = slugify(title);
    const filePath = `content/${slug}.md`;

    const slugExists = site?.contentFiles?.some(f => f.slug === slug);
    if (slugExists) {
        toast.error(`A page with the slug "${slug}" already exists.`);
        setIsSubmitting(false);
        return;
    }
    
    const frontmatter: MarkdownFrontmatter = {
        title: title.trim(),
        layout: DEFAULT_PAGE_LAYOUT_PATH,
        date: new Date().toISOString().split('T')[0],
    };

    const initialContent = `---\n${yaml.dump(frontmatter)}---\n\nStart writing your content here.\n`;

    try {
      const success = await addOrUpdateContentFile(siteId, filePath, initialContent);
      if (success) {
        toast.success(`Page "${title}" created!`);
        handleOpenChange(false);
        onComplete?.();
        
        // --- CHANGE: Use navigate to redirect to the new page's editor ---
        navigate(`/sites/${siteId}/edit/content/${slug}`);
      } else { 
        throw new Error("Failed to update manifest or save file.");
      }
    } catch (error) {
      toast.error(`Failed to create page: ${(error as Error).message}`);
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Create New Content Page</DialogTitle>
          <DialogDescription>
            Give your new page a title. You can add content and change settings later.
          </DialogDescription>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          <div className="space-y-1">
            <Label htmlFor="title">Page Title</Label>
            <Input id="title" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="e.g., About Us" />
          </div>
        </div>
        <DialogFooter>
          <DialogClose asChild><Button variant="outline">Cancel</Button></DialogClose>
          <Button type="button" onClick={handleCreatePage} disabled={!title.trim() || isSubmitting}>
            {isSubmitting ? 'Creating...' : <><Plus className="mr-2 h-4 w-4" /> Create Page</>}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: features/editor/components/FileTree.tsx
// src/features/editor/components/FileTree.tsx
'use client';

import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
import FileTreeNode from './FileTreeNode';
import type { FlattenedNode } from '@/core/services/fileTree.service';

/**
 * Defines the shape of the visual drop indicator state, passed from the parent.
 */
interface DndProjection {
  parentId: string | null;
  depth: number;
  index: number;
}

/**
 * Defines the props accepted by the FileTree component.
 * It now receives a pre-filtered list of items to render, and a separate
 * list of IDs that are valid sortable targets.
 */
interface FileTreeProps {
  itemsToRender: FlattenedNode[];
  sortableIds: string[];
  activeId: string | null;
  projected: DndProjection | null;
  baseEditPath: string;
  activePath: string | undefined;
  homepagePath: string | undefined;
  onCollapse: (id: string) => void;
}

/**
 * Renders the sortable list of pages.
 * This component is now a "dumb" presenter; all filtering and state management
 * is handled by its parent (LeftSidebar).
 */
export default function FileTree({
  itemsToRender,
  sortableIds,
  activeId,
  projected,
  baseEditPath,
  activePath,
  homepagePath,
  onCollapse,
}: FileTreeProps) {
  return (
    // The SortableContext is given only the IDs of items that can be dragged.
    // The homepage ID is excluded by the parent component.
    <SortableContext items={sortableIds} strategy={verticalListSortingStrategy}>
      <ul className="space-y-0.5">
        {/* It maps over the pre-filtered list of items to render each node. */}
        {itemsToRender.map((item) => (
          <FileTreeNode
            key={item.path}
            item={item}
            activeId={activeId}
            projected={projected}
            baseEditPath={baseEditPath}
            activePath={activePath}
            homepagePath={homepagePath}
            onCollapse={onCollapse}
          />
        ))}
      </ul>
    </SortableContext>
  );
}

================================================================================

File: features/editor/components/FileTreeNode.tsx
// src/features/viewer/components/SiteViewer.tsx

import { useEffect, useState, useCallback } from 'react';
import { useParams, useLocation, useNavigate } from 'react-router-dom';
import { Link } from 'react-router-dom';

// State and Services
import { useAppStore } from '@/core/state/useAppStore';
import { resolvePageContent } from '@/core/services/pageResolver.service';
import { render as renderWithTheme } from '@/core/services/renderer/render.service';

// Types
import { type AppStore } from '@/core/state/useAppStore';
import { PageType } from '@/core/types';

// UI Components
import { Button } from '@/core/components/ui/button';
import { AlertTriangle, Edit } from 'lucide-react';

export default function SiteViewer() {
  // --- 1. Use react-router-dom hooks ---
  const { siteId = '' } = useParams<{ siteId: string }>();
  const location = useLocation(); // Provides the full current path
  const navigate = useNavigate(); // For updating the URL

  const site = useAppStore(useCallback((state: AppStore) => state.getSiteById(siteId), [siteId]));

  const [htmlContent, setHtmlContent] = useState<string>('<p>Loading Preview...</p>');
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  // The base path for the viewer, used to calculate relative paths
  const viewRootPath = `/sites/${siteId}/view`;

  // --- 2. Derive the relative path from the location pathname ---
  const currentRelativePath = location.pathname.startsWith(viewRootPath)
    ? location.pathname.substring(viewRootPath.length) || '/'
    : '/';

  // This function generates the final HTML and sets the iframe content
  const updateIframeContent = useCallback(async () => {
    if (!site?.contentFiles) {
      setHtmlContent('<p>Loading site data...</p>');
      return;
    }

    // The slug array is derived from the relative path inside the viewer
    const slugArray = currentRelativePath.split('/').filter(Boolean);
    const resolution = resolvePageContent(site, slugArray);
    
    if (resolution.type === PageType.NotFound) {
      setErrorMessage(resolution.errorMessage);
      setHtmlContent(''); // Clear content on error
      return;
    }

    try {
      const pureHtml = await renderWithTheme(site, resolution, {
        // The siteRootPath is passed to the renderer so it can generate correct hash links
        siteRootPath: `#${viewRootPath}`,
        isExport: false,
      });

      // The communication script is updated to post the path part of the hash URL
      const communicationScript = `
        <script>
          document.addEventListener('click', function(e) {
            const link = e.target.closest('a');
            if (!link || !link.href) return;
            if (link.hash && link.pathname === window.location.pathname) return;

            // Check if the link is a hash-based internal link
            const url = new URL(link.href);
            if (url.origin === window.location.origin && url.hash) {
              e.preventDefault();
              const newHashPath = url.hash.substring(1); // Get path from hash (e.g., /sites/123/view/about)
              // Post the new hash path to the parent window
              window.parent.postMessage({ type: 'SIGNUM_NAVIGATE', path: newHashPath }, window.location.origin);
            }
          });
        </script>
      `;

      const finalHtml = pureHtml.replace('</body>', `${communicationScript}</body>`);
      setHtmlContent(finalHtml);
      setErrorMessage(null);
    } catch (e) {
      const error = e as Error;
      console.error("Error during site rendering:", error);
      setErrorMessage(`Theme Error: ${error.message}`);
      setHtmlContent('');
    }
  }, [site, viewRootPath, currentRelativePath]);

  // Re-render the iframe whenever the path or site data changes.
  useEffect(() => {
    updateIframeContent();
  }, [updateIframeContent]);


  // --- 3. Manage Browser History with useNavigate ---
  // This effect listens for messages from the iframe to update the browser's URL bar.
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      if (event.origin !== window.location.origin) return;
      
      const { type, path } = event.data;
      if (type === 'SIGNUM_NAVIGATE' && path !== location.pathname) {
        // Use navigate to update the hash URL, which will trigger a re-render
        navigate(path);
      }
    };

    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
    
    // We don't need the 'popstate' listener anymore because `useLocation` from react-router-dom handles it.
  }, [location.pathname, navigate]);


  // Sandbox attributes remain the same
  const sandboxAttributes = 
    process.env.NODE_ENV === 'development'
      ? 'allow-scripts allow-forms allow-same-origin'
      : 'allow-scripts allow-forms';

  // Error state rendering remains the same
  if (errorMessage) {
    return (
      <div className="p-8 text-center">
        <AlertTriangle className="h-12 w-12 text-destructive mx-auto mb-4" />
        <h1 className="text-2xl font-bold mb-2">Could Not Render Preview</h1>
        <p className="text-muted-foreground">{errorMessage}</p>
        <Button asChild variant="default" className="mt-6">
          <Link to={`/sites/${siteId}/edit`}>
            <Edit className="mr-2 h-4 w-4" /> Go to Editor
          </Link>
        </Button>
      </div>
    );
  }

  // The iframe itself is unchanged
  return (
    <iframe
      srcDoc={htmlContent}
      title={site?.manifest.title || 'Site Preview'}
      className="w-full h-full border-0"
      sandbox={sandboxAttributes}
      key={siteId} // Add key to force re-mount if siteId changes
    />
  );
}

================================================================================

File: features/editor/components/DataSourceSelectWidget.tsx
// src/features/editor/components/DataSourceSelectWidget.tsx
'use client';

import { useEffect, useState, useMemo } from 'react';
import { getAvailableLayouts } from '@/core/services/config/configHelpers.service';
import type { WidgetProps } from '@rjsf/utils';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/core/components/ui/select";
import { Label } from '@/core/components/ui/label';
import type { LocalSiteData, StructureNode } from '@/core/types';
import type { LayoutManifest } from '@/core/services/config/configHelpers.service';

interface SelectOption {
  label: string;
  value: string;
}

interface DataSourceSelectWidgetProps extends WidgetProps {
    formContext?: {
        site?: LocalSiteData;
    };
}

const DataSourceSelectWidget = ({ id, label, options, value, onChange, required, formContext }: DataSourceSelectWidgetProps) => {
  const { uiSchema } = options;
  const site = formContext?.site;

  const dataSource = uiSchema?.['ui:dataSource'] as string;
  const layoutTypeFilter = uiSchema?.['ui:layoutType'] as string | undefined;

  const [items, setItems] = useState<SelectOption[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchItems = async () => {
      // Add a more robust guard clause
      if (!site || !site.manifest || !site.contentFiles) {
        setItems([]);
        setIsLoading(false);
        return;
      }
      setIsLoading(true);

      let fetchedItems: SelectOption[] = [];

      try {
        switch (dataSource) {
          case 'collections':
            // 1. Find all content files that ARE collection pages.
            const collectionFilePaths = new Set(
              site.contentFiles
                .filter(f => !!f.frontmatter.collection)
                .map(f => f.path)
            );
            // 2. Filter the structure nodes to only include those whose paths are in our set.
            fetchedItems = site.manifest.structure
              .filter((n: StructureNode) => collectionFilePaths.has(n.path))
              .map((c: StructureNode) => ({ label: c.title, value: c.slug }));
            break;

          case 'layouts':
            const allLayouts: LayoutManifest[] = await getAvailableLayouts(site);
            fetchedItems = allLayouts
              .filter(l => !layoutTypeFilter || l.layoutType === layoutTypeFilter)
              .map(l => ({ label: l.name, value: l.id })); // Use id for value
            break;

          default:
            fetchedItems = [];
        }
        setItems(fetchedItems);
      } catch (error) {
        console.error(`Failed to fetch data source "${dataSource}":`, error);
        setItems([]);
      } finally {
        setIsLoading(false);
      }
    };

    fetchItems();
  }, [site, dataSource, layoutTypeFilter]);

  const placeholder = useMemo(() => {
    if (isLoading) return `Loading ${dataSource || 'options'}...`;
    if (dataSource) return `Select a ${dataSource.replace(/s$/, '')}...`;
    return 'Select an option...';
  }, [isLoading, dataSource]);

  return (
    <div className="space-y-1">
      <Label htmlFor={id}>{label}{required ? '*' : ''}</Label>
      <Select value={value} onValueChange={onChange} disabled={isLoading}>
        <SelectTrigger id={id} className="mt-1">
          <SelectValue placeholder={placeholder} />
        </SelectTrigger>
        <SelectContent>
          {items.map(item => (
            <SelectItem key={item.value} value={item.value}>
              {item.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};

export default DataSourceSelectWidget;

================================================================================

File: features/editor/components/BlocknoteEditor.tsx
// src/features/editor/components/BlocknoteEditor.tsx
import { forwardRef, useImperativeHandle } from 'react';
import type { Block } from '@blocknote/core';
import { useCreateBlockNote } from '@blocknote/react';
import { BlockNoteView } from '@blocknote/mantine';
import '@blocknote/mantine/style.css';
import { Label } from '@/core/components/ui/label';

interface BlocknoteEditorProps {
  initialContent: Block[];
  onContentChange: () => void; // Only needs to signal a change, not pass content
}

// The ref will now expose a function to get the editor's block data.
export interface BlocknoteEditorRef {
  getBlocks: () => Block[];
}

const BlocknoteEditor = forwardRef<BlocknoteEditorRef, BlocknoteEditorProps>(
  ({ initialContent, onContentChange }, ref) => {
    // Creates a new editor instance.
    const editor = useCreateBlockNote({
        initialContent: initialContent.length > 0 ? initialContent : undefined,
    });

    // Expose a function for the parent component to get the current content.
    useImperativeHandle(ref, () => ({
      getBlocks: () => {
        return editor.document;
      },
    }));

    return (
      <div className="space-y-2 h-full flex flex-col">
        <Label htmlFor="content-body" className="text-[10px] font-medium uppercase text-gray-400 shrink-0">
          Content
        </Label>
        <div className="flex-grow min-h-0 overflow-y-auto border p-2">
            <BlockNoteView
                editor={editor}
                theme="light" // Or use a theme provider to make it dynamic
                onChange={onContentChange}
            />
        </div>
      </div>
    );
  }
);

BlocknoteEditor.displayName = 'BlocknoteEditor';
export default BlocknoteEditor;

================================================================================

File: features/editor/components/CollectionItemList.tsx
// src/features/editor/components/CollectionItemList.tsx

import { useMemo } from 'react';
import { Link } from 'react-router-dom'; // Use Link from react-router-dom

// State Management
import { useAppStore } from '@/core/state/useAppStore';
import { type AppStore } from '@/core/state/useAppStore'; // Import the store type

// Services & Config
import { findChildNodes } from '@/core/services/fileTree.service';
import { NEW_FILE_SLUG_MARKER } from '@/config/editorConfig';

// UI Components & Icons
import { Button } from '@/core/components/ui/button';
import { FileText, PlusCircle } from 'lucide-react';

interface CollectionItemListProps {
  siteId: string;
  collectionPagePath: string; // e.g., 'content/blog.md'
}

export default function CollectionItemList({ siteId, collectionPagePath }: CollectionItemListProps) {
  // Explicitly type the state selector for Zustand
  const site = useAppStore((state: AppStore) => state.getSiteById(siteId));

  // This logic to find child nodes is correct and remains unchanged
  const collectionItems = useMemo(() => {
    if (!site?.manifest) return [];
    return findChildNodes(site.manifest.structure, collectionPagePath);
  }, [site?.manifest, collectionPagePath]);

  // The path for the "New Item" button is also updated to be a correct hash route
  const newItemPath = `/sites/${siteId}/edit/content/${collectionPagePath.replace('content/', '').replace('.md', '')}/${NEW_FILE_SLUG_MARKER}`;

  return (
    <div className="h-full flex flex-col p-6 bg-muted/30">
      <div className="flex shrink-0 items-center justify-between mb-4 pb-4 border-b">
        <h1 className="text-2xl font-bold">Collection Items</h1>
        <Button asChild>
          <Link to={newItemPath}>
            <PlusCircle className="mr-2 h-4 w-4" /> New Item
          </Link>
        </Button>
      </div>
      <div className="flex-grow rounded-lg bg-background p-1 overflow-y-auto">
        {collectionItems.length > 0 ? (
          <ul className="space-y-1">
            {collectionItems.map((item) => {
              // --- CONFIRMED FIX FOR NEW ROUTING ---
              // The editor slug is correctly derived from the item's full, unambiguous path.
              // This avoids issues with nested slugs or duplicate filenames.
              const editorSlug = item.path.replace(/^content\//, '').replace(/\.md$/, '');
              const itemEditorPath = `/sites/${siteId}/edit/content/${editorSlug}`;

              return (
                <li key={item.path}>
                  <Link to={itemEditorPath} className="flex items-center rounded-md p-2 transition-colors hover:bg-muted">
                    <FileText className="mr-3 h-4 w-4 text-muted-foreground" />
                    <span className="font-medium">{item.title || item.slug}</span>
                  </Link>
                </li>
              );
            })}
          </ul>
        ) : (
          <div className="text-center text-muted-foreground py-10">
            <p>No items have been added to this collection yet.</p>
            <Button asChild variant="outline" className="mt-4">
               <Link to={newItemPath}>
                    <PlusCircle className="mr-2 h-4 w-4" /> Add your first item
                </Link>
            </Button>
          </div>
        )}
      </div>
    </div>
  );
}

================================================================================

File: features/editor/components/CreateCollectionPageDialog.tsx
// src/features/editor/components/CreateCollectionPageDialog.tsx

import { useState, useEffect, type ReactNode } from 'react';
import { useNavigate } from 'react-router-dom'; // Import the navigate hook

// State Management
import { useAppStore } from '@/core/state/useAppStore';

// Services and Config
import { slugify } from '@/core/libraries/utils';
import { getLayoutManifest } from '@/core/services/config/configHelpers.service';
import { DEFAULT_COLLECTION_LAYOUT_PATH } from '@/config/editorConfig';
import { toast } from 'sonner';
import yaml from 'js-yaml';

// UI & Type Imports
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger, DialogClose } from "@/core/components/ui/dialog";
import { Button } from "@/core/components/ui/button";
import { Input } from "@/core/components/ui/input";
import { Label } from "@/core/components/ui/label";
import { Plus } from 'lucide-react';
import { type MarkdownFrontmatter, type CollectionConfig } from '@/core/types';

interface CreateCollectionPageDialogProps {
  siteId: string;
  children: ReactNode;
  onComplete?: () => void;
}

export default function CreateCollectionPageDialog({ siteId, children, onComplete }: CreateCollectionPageDialogProps) {
  const navigate = useNavigate(); // Use the navigate hook for routing
  const [isOpen, setIsOpen] = useState(false);
  const [name, setName] = useState('');
  const [slug, setSlug] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const site = useAppStore((state) => state.getSiteById(siteId));
  const { addOrUpdateContentFile } = useAppStore.getState();

  // This effect to auto-generate the slug from the name is correct and needs no changes.
  useEffect(() => {
    setSlug(slugify(name));
  }, [name]);

  const handleOpenChange = (open: boolean) => {
    setIsOpen(open);
    if (!open) {
      // Reset state when the dialog is closed
      setTimeout(() => {
        setName('');
        setSlug('');
        setIsSubmitting(false);
      }, 200);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim()) {
      toast.error("Collection name cannot be empty.");
      return;
    }

    const filePath = `content/${slug}.md`;
    if (site?.contentFiles?.some(f => f.path === filePath)) {
        toast.error(`A page with the folder name "${slug}" already exists.`);
        return;
    }

    setIsSubmitting(true);

    try {
      const defaultLayoutManifest = site ? await getLayoutManifest(site, DEFAULT_COLLECTION_LAYOUT_PATH) : null;

      // Start with base config
      const initialCollectionConfig: CollectionConfig = { 
          sort_by: 'date',
          sort_order: 'desc',
          items_per_page: 10,
      };
      
      // Merge in defaults from the layout's display_options if they exist
      if (defaultLayoutManifest?.display_options) {
        for (const [key, option] of Object.entries(defaultLayoutManifest.display_options)) {
            initialCollectionConfig[key] = option.default;
        }
      }

      const frontmatter: MarkdownFrontmatter = {
          title: name.trim(),
          layout: DEFAULT_COLLECTION_LAYOUT_PATH,
          collection: initialCollectionConfig,
      };

      const initialContent = `---\n${yaml.dump(frontmatter)}---\n\n## Welcome to the ${name.trim()} collection!\n\nYou can write an introduction for this collection here.`;
    
      const success = await addOrUpdateContentFile(siteId, filePath, initialContent);
      if (success) {
        toast.success(`Collection page "${name}" created!`);
        handleOpenChange(false);
        onComplete?.();
        
        // --- CHANGE: Use navigate to redirect the user to the new page's editor ---
        navigate(`/sites/${siteId}/edit/content/${slug}`);
      } else {
        throw new Error("Failed to update manifest or save file.");
      }
    } catch (error) {
      toast.error(`Failed to create page: ${(error as Error).message}`);
    } finally {
        setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>Create New Collection Page</DialogTitle>
            <DialogDescription>
              Create a new page that will list other pages, like a blog or a portfolio.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="space-y-1">
              <Label htmlFor="name">Collection Name</Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="e.g., Blog Posts"
                autoComplete="off"
              />
            </div>
            <div className="space-y-1">
              <Label htmlFor="slug">Folder Name (URL)</Label>
              <Input id="slug" value={slug} readOnly className="bg-muted" />
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild><Button type="button" variant="outline">Cancel</Button></DialogClose>
            <Button type="submit" disabled={!name.trim() || isSubmitting}>
                {isSubmitting ? 'Creating...' : <><Plus className="mr-2 h-4 w-4" /> Create Collection</>}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

================================================================================

File: features/editor/components/RightSidebar.tsx
'use client';

import { type ReactNode } from 'react';
import { useUIStore } from '@/core/state/uiStore';
import { cn } from '@/core/libraries/utils';

interface RightSidebarProps {
  children: ReactNode;
}

export default function RightSidebar({ children }: RightSidebarProps) {
  const { isRightOpen } = useUIStore((state) => state.sidebar);

  return (
    <aside
      className={cn(
        // Base styles
        'h-full w-80 shrink-0 border-l bg-muted/20 transition-all duration-300 ease-in-out',
        
        // Hide/Show Logic
        isRightOpen ? 'ml-0' : '-mr-[320px] w-0 border-l-0 opacity-0'
      )}
    >
      <div className="h-full overflow-y-auto">
        {children}
      </div>
    </aside>
  );
}

================================================================================

File: features/editor/components/SaveButton.tsx
// src/features/editor/components/SaveButton.tsx
'use client';

import { useEditor } from '@/features/editor/contexts/EditorContext';
import { Button } from '@/core/components/ui/button';
import { Save, Check, Loader2 } from 'lucide-react';

/**
 * A context-aware button that displays the current save state
 * (e.g., Save, Saving..., Saved) and triggers the save action.
 *
 * This component MUST be rendered within a tree wrapped by an `<EditorProvider>`
 * as it relies on the `useEditor` hook for its state and actions.
 */
export default function SaveButton() {
  const { saveState, hasUnsavedChanges, triggerSave } = useEditor();

  // Define the visual states for the button
  const buttonStates = {
    idle: {
      icon: <Save className="h-4 w-4" />,
      text: 'Save',
    },
    saving: {
      icon: <Loader2 className="h-4 w-4 animate-spin" />,
      text: 'Saving...',
    },
    saved: {
      icon: <Check className="h-4 w-4" />,
      text: 'Saved',
    },
  };

  // Determine the current display state and if the button should be disabled
  let currentDisplayState: 'idle' | 'saving' | 'saved';
  let isDisabled = false;

  if (saveState === 'saving') {
    currentDisplayState = 'saving';
    isDisabled = true;
  } else if (hasUnsavedChanges) {
    currentDisplayState = 'idle';
    isDisabled = false;
  } else {
    // This covers both 'saved' and 'no_changes' states.
    // In both cases, the content is considered saved and there's nothing to do.
    currentDisplayState = 'saved';
    isDisabled = true;
  }

  const current = buttonStates[currentDisplayState];

  return (
    <Button variant='ghost' onClick={triggerSave} disabled={isDisabled}>
      {current.icon}
      <span className='hidden md:block'>{current.text}</span>
    </Button>
  );
}

================================================================================

File: features/editor/components/LeftSidebar.tsx
// src/features/editor/components/LeftSidebar.tsx

import { useMemo, useCallback, useState } from 'react';
import { createPortal } from 'react-dom';
import { useParams, useLocation } from 'react-router-dom'; // Import react-router-dom hooks

// State Management
import { useAppStore } from '@/core/state/useAppStore';
import { type AppStore } from '@/core/state/useAppStore'; // Import the store type for explicit typing

// UI Components & Icons
import { Button } from '@/core/components/ui/button';
import FileTree from '@/features/editor/components/FileTree';
import NewPageDialog from '@/features/editor/components/NewPageDialog';
import CreateCollectionPageDialog from '@/features/editor/components/CreateCollectionPageDialog';
import { FilePlus, LayoutGrid, GripVertical, Archive } from 'lucide-react';
import {
  DndContext,
  type DragEndEvent,
  DragOverlay,
  type DragStartEvent,
  PointerSensor,
  useSensor,
  useSensors,
  type DragOverEvent,
  type DragMoveEvent,
  closestCenter,
  useDroppable,
} from '@dnd-kit/core';
import { flattenTree, type FlattenedNode } from '@/core/services/fileTree.service';
import { arrayMove } from '@dnd-kit/sortable';
import { toast } from 'sonner';
import { exportSiteBackup } from '@/core/services/siteBackup.service';
import { slugify } from '@/core/libraries/utils';

interface DndProjection {
  parentId: string | null;
  depth: number;
  index: number;
}

function DragOverlayItem({ id, items }: { id: string, items: FlattenedNode[] }) {
    const item = items.find(i => i.path === id);
    if (!item) return null;
    return (
        <div className="flex items-center gap-2 p-2 bg-background border rounded-md shadow-lg text-sm font-semibold">
            <GripVertical className="h-4 w-4 text-muted-foreground" />
            <span>{item.title}</span>
        </div>
    );
}

export default function LeftSidebar() {
  // Use react-router-dom hooks to get URL information
  const { siteId = '' } = useParams<{ siteId: string }>();
  const location = useLocation();

  // Explicitly type the state selector for Zustand
  const { getSiteById, loadSite } = useAppStore((state: AppStore) => ({
    getSiteById: state.getSiteById,
    loadSite: state.loadSite,
  }));
  
  const site = useAppStore((state: AppStore) => state.getSiteById(siteId));
  const { repositionNode } = useAppStore.getState();

  // All local state management remains the same
  const [activeId, setActiveId] = useState<string | null>(null);
  const [overId, setOverId] = useState<string | null>(null);
  const [offsetLeft, setOffsetLeft] = useState(0);
  const [collapsedIds, setCollapsedIds] = useState<Set<string>>(new Set());

  const sensors = useSensors(useSensor(PointerSensor, { activationConstraint: { distance: 8 } }));
  const { setNodeRef: setRootDroppableRef } = useDroppable({ id: '__root_droppable__' });

  const flattenedItems = useMemo(() => {
    if (!site?.manifest.structure || !site.contentFiles) return [];
    const allItems = flattenTree(site.manifest.structure, site.contentFiles);
    
    // Filter out collection items - they should not appear in the main file tree
    // Only show collection pages themselves and regular pages
    return allItems.filter(item => {
      // Keep the item if it's a collection page (has collection frontmatter)
      if (item.frontmatter?.collection) return true;
      
      // Keep the item if it's not a child of another item (depth 0 = top level)
      if (item.depth === 0) return true;
      
      // For nested items, only keep if parent is NOT a collection
      const parentItem = allItems.find(parent => parent.path === item.parentId);
      return !parentItem?.frontmatter?.collection;
    });
  }, [site?.manifest.structure, site?.contentFiles]);
  
  const homepageItem = useMemo(() => flattenedItems.find(item => item.frontmatter?.homepage === true), [flattenedItems]);
  const sortableItems = useMemo(() => flattenedItems.filter(item => item.frontmatter?.homepage !== true), [flattenedItems]);
  const sortableIds = useMemo(() => sortableItems.map(i => i.path), [sortableItems]);
  
  const activeItem = activeId ? flattenedItems.find(i => i.path === activeId) : null;

  const handleExportBackup = async () => {
    toast.info("Preparing site backup...");
    try {
        await loadSite(siteId);
        const siteToExport = getSiteById(siteId);
        if (!siteToExport) throw new Error("Could not load site data for export.");
        const blob = await exportSiteBackup(siteToExport);
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `${slugify(siteToExport.manifest.title || 'signum-backup')}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        toast.success("Site backup downloaded!");
    } catch (error) {
        console.error("Failed to export site:", error);
        toast.error(`Export failed: ${(error as Error).message}`);
    }
  };

  const itemsToRender = useMemo(() => {
    // This logic correctly filters children of collapsed parents.
    return flattenedItems.filter(item => {
        if (item.depth === 0) return true;
        if (item.parentId && collapsedIds.has(item.parentId)) return false;
        // Also check grandparents for level 2 items
        const parent = flattenedItems.find(p => p.path === item.parentId);
        if (parent?.parentId && collapsedIds.has(parent.parentId)) return false;
        return true;
    });
  }, [flattenedItems, collapsedIds]);
  
  const projected = useMemo((): DndProjection | null => {
    if (!activeItem || !overId) return null;
    const indentationWidth = 24;
    const dragDepth = Math.round(offsetLeft / indentationWidth);
    const projectedDepth = activeItem.depth + dragDepth;
    const overItemIndex = flattenedItems.findIndex(({ path }) => path === overId);
    const activeItemIndex = flattenedItems.findIndex(({ path }) => path === activeId);
    const newItems = arrayMove(flattenedItems, activeItemIndex, overItemIndex);
    const previousItem = newItems[overItemIndex - 1];
    const nextItem = newItems[overItemIndex + 1];
    const maxDepth = previousItem ? previousItem.depth + 1 : 0;
    const minDepth = nextItem ? nextItem.depth : 0;
    let depth = Math.max(minDepth, Math.min(projectedDepth, maxDepth));

    if (depth > 2) {
      depth = 2;
    }
    
    let parentId = null;
    if (depth > 0 && previousItem) {
        if (depth === previousItem.depth) parentId = previousItem.parentId;
        else if (depth > previousItem.depth) parentId = previousItem.path;
        else parentId = newItems.slice(0, overItemIndex).reverse().find((item) => item.depth === depth)?.parentId ?? null;
    }
    return { depth, parentId, index: overItemIndex };
  }, [activeId, overId, offsetLeft, flattenedItems, activeItem]);

  const handleCollapse = useCallback((id: string) => {
    setCollapsedIds(prev => {
        const newSet = new Set(prev);
        if (newSet.has(id)) newSet.delete(id);
        else newSet.add(id);
        return newSet;
    });
  }, []);

  const handleDragStart = useCallback((event: DragStartEvent) => {
    setActiveId(event.active.id as string);
    setOverId(event.active.id as string);
  }, []);

  const handleDragMove = useCallback((event: DragMoveEvent) => setOffsetLeft(event.delta.x), []);
  const handleDragOver = useCallback((event: DragOverEvent) => setOverId(event.over?.id as string ?? null), []);

  const resetState = useCallback(() => {
    setActiveId(null);
    setOverId(null);
    setOffsetLeft(0);
  }, []);

  const handleDragEnd = useCallback((event: DragEndEvent) => {
    if (!projected) {
        resetState();
        return;
    }
    const { active, over } = event;
    if (site && active.id && over?.id) {
        if (over.id === '__root_droppable__') {
            repositionNode(siteId, active.id as string, null, flattenedItems.length - 1);
        } else {
            repositionNode(siteId, active.id as string, projected.parentId, projected.index);
        }
    }
    resetState();
  }, [projected, site, siteId, repositionNode, flattenedItems.length, resetState]);

  
  


  const activePathForFileTree = useMemo(() => {
    if (!site?.manifest) return undefined;

    const editorRootPath = `/sites/${siteId}/edit/content`;
    // Use the pathname from `useLocation`
    if (location.pathname.startsWith(editorRootPath)) {
        const slug = location.pathname.substring(editorRootPath.length).replace(/^\//, '');
        // If slug is empty, we're at the editor root, so highlight the homepage
        return slug ? `content/${slug}.md` : homepageItem?.path;
    }
    return undefined;
  }, [location.pathname, site, siteId, homepageItem]);

  if (!site) return null;
  
  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragStart={handleDragStart}
      onDragMove={handleDragMove}
      onDragOver={handleDragOver}
      onDragEnd={handleDragEnd}
      onDragCancel={resetState}
    >
      <div className="flex h-full flex-col">
        <div className="flex shrink-0 items-center justify-between border-b px-2 py-0.5">
          <h3 className="px-2 text-xs font-semibold uppercase tracking-wider text-muted-foreground">Content</h3>
          <div className="flex items-center gap-1">
            <CreateCollectionPageDialog siteId={siteId}>
                <Button variant="ghost" className='size-7 p-1' title="New Collection">
                    <LayoutGrid className="h-4 w-4" />
                </Button>
            </CreateCollectionPageDialog>
            <NewPageDialog siteId={siteId}>
                <Button variant="ghost" className='size-7 p-1' title="New Page">
                    <FilePlus className="h-4 w-4" />
                </Button>
            </NewPageDialog>
          </div>
        </div>
        
        <div className="flex-grow overflow-y-auto p-2" ref={setRootDroppableRef}>
          {homepageItem && itemsToRender.length > 0 ? (
            <FileTree 
              itemsToRender={itemsToRender.map(item => ({...item, collapsed: collapsedIds.has(item.path)}))}
              sortableIds={sortableIds}
              activeId={activeId}
              projected={projected}
              baseEditPath={`/sites/${siteId}/edit`}
              activePath={activePathForFileTree}
              homepagePath={homepageItem.path}
              onCollapse={handleCollapse}
            />
          ) : (
            <div className="px-2 py-4 text-xs text-center text-muted-foreground italic">
              <p>No pages created yet. Click the buttons above to add one.</p>
            </div>
          )}
        </div>

        <div className="mt-auto shrink-0 border-t p-2 space-y-1">
            <Button variant="ghost" onClick={handleExportBackup} className="w-full justify-start gap-2">
                <Archive className="h-4 w-4" /> Export site backup
            </Button>
            
        </div>
      </div>
      
      {createPortal(
        <DragOverlay dropAnimation={null} style={{ pointerEvents: 'none' }}>
          {activeId ? <DragOverlayItem id={activeId} items={flattenedItems} /> : null}
        </DragOverlay>,
        document.body
      )}
    </DndContext>
  );
}

================================================================================

File: features/editor/components/FrontmatterSidebar.tsx
// src/features/editor/components/FrontmatterSidebar.tsx
'use client';

import React, { useState, useEffect, useMemo, useCallback } from 'react';
import type { Manifest, RawFile, StructureNode, ParsedMarkdownFile, MarkdownFrontmatter } from '@/core/types';
import { getAvailableLayouts, type LayoutManifest } from '@/core/services/config/configHelpers.service';

// UI Component Imports
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/core/components/ui/accordion";
import { Button } from '@/core/components/ui/button';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/core/components/ui/alert-dialog";
import { Trash2 } from 'lucide-react';

// Form & Sub-component Imports
import ContentTypeSelector from '@/features/editor/components/forms/ContentTypeSelector';
import CollectionSettingsForm from '@/features/editor/components/forms/CollectionSettingsForm';
import PageMetadataForm from '@/features/editor/components/forms/PageMetaDataForm';
import AdvancedSettingsForm from '@/features/editor/components/forms/AdvancedSettingsForm';

interface FrontmatterSidebarProps {
  siteId: string;
  filePath: string;
  manifest: Manifest;
  layoutFiles: RawFile[] | undefined;
  themeFiles: RawFile[] | undefined;
  allContentFiles: ParsedMarkdownFile[];
  frontmatter: MarkdownFrontmatter;
  onFrontmatterChange: (newFrontmatter: Partial<MarkdownFrontmatter>) => void;
  isNewFileMode: boolean;
  slug: string;
  onSlugChange: (newSlug: string) => void;
  onDelete: () => Promise<void>;
}

export default function FrontmatterSidebar({
  siteId, filePath, manifest, layoutFiles, themeFiles, allContentFiles,
  frontmatter, onFrontmatterChange, isNewFileMode, slug, onSlugChange, onDelete,
}: FrontmatterSidebarProps) {

  const [allLayouts, setAllLayouts] = useState<LayoutManifest[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    async function fetchAllLayouts() {
      setIsLoading(true);
      
      const siteDataForAssets = { manifest, layoutFiles, themeFiles };
      const layouts = await getAvailableLayouts(siteDataForAssets);
      setAllLayouts(layouts);
      setIsLoading(false);
    }
    fetchAllLayouts();
    // This effect should only re-run if the core site assets change.
  }, [manifest, layoutFiles, themeFiles]);

  const { isCollectionPage, isCollectionItem, parentFile } = useMemo(() => {
    const isCollection = !!frontmatter.collection;
    if (isCollection) return { isCollectionPage: true, isCollectionItem: false, parentFile: null };
    
    // For new files, check if the parent directory is a collection
    if (isNewFileMode) {
      const parentPath = `${filePath}.md`; // Convert parent dir to collection page path
      const pFile = allContentFiles.find(f => f.path === parentPath);
      if (pFile?.frontmatter.collection) {
        return { isCollectionPage: false, isCollectionItem: true, parentFile: pFile };
      }
    } else {
      // For existing files, check if this file is a child of a collection page by searching the structure
      function findParentCollection(nodes: StructureNode[], targetPath: string): string | null {
        for (const node of nodes) {
          if (node.children) {
            // Check if targetPath is in this node's children
            const isChild = node.children.some(child => child.path === targetPath);
            if (isChild) {
              return node.path;
            }
            // Recursively search in children
            const found = findParentCollection(node.children, targetPath);
            if (found) return found;
          }
        }
        return null;
      }
      
      const parentPath = findParentCollection(manifest.structure, filePath);
      if (parentPath) {
        const pFile = allContentFiles.find(f => f.path === parentPath);
        if (pFile?.frontmatter.collection) {
          return { isCollectionPage: false, isCollectionItem: true, parentFile: pFile };
        }
      }
    }
    
    return { isCollectionPage: false, isCollectionItem: false, parentFile: null };
  }, [frontmatter.collection, manifest.structure, allContentFiles, filePath, isNewFileMode]);

  const currentLayoutManifest = useMemo(() => {
    if (!frontmatter.layout) return null;
    return allLayouts.find(l => l.id === frontmatter.layout) ?? null;
  }, [allLayouts, frontmatter.layout]);

  const parentLayoutManifest = useMemo(() => {
    if (!isCollectionItem || !parentFile?.frontmatter.layout) return null;
    return allLayouts.find(l => l.id === parentFile.frontmatter.layout) ?? null;
  }, [allLayouts, isCollectionItem, parentFile]);

  const availableContentTypes = useMemo(() => {
    const requiredType = isCollectionPage ? 'collection' : 'page';
    const filtered = allLayouts.filter(layout => layout.layoutType === requiredType);

    // De-duplicate by id to prevent React key warnings
    const unique = Array.from(new Map(filtered.map(item => [item.id, item])).values());
    return unique;
    
  }, [allLayouts, isCollectionPage]);

  const handleContentTypeChange = useCallback((newLayoutId: string) => {
    onFrontmatterChange({ layout: newLayoutId });
  }, [onFrontmatterChange]);

  // FIX #2: Add a loading guard to prevent rendering with incomplete data.
  // This ensures `currentLayoutManifest` is populated before children render.
  if (isLoading || !frontmatter) {
    return <div className="p-4 text-sm text-center text-muted-foreground">Loading settings...</div>;
  }

  const defaultOpenSections = ['content-type', 'metadata', 'advanced'];
  if (isCollectionPage) {
    defaultOpenSections.push('list-settings');
  }

  return (
    <div className="h-full flex flex-col">
      <div className="flex-grow overflow-y-auto p-3">
        <Accordion type="multiple" defaultValue={defaultOpenSections} className="w-full">
          
          {!isCollectionItem && (
            <AccordionItem value="content-type">
              <AccordionTrigger>Content Type</AccordionTrigger>
              <AccordionContent className="pt-4">
                <ContentTypeSelector
                  availableTypes={availableContentTypes}
                  selectedType={frontmatter.layout || (isCollectionPage ? 'blog' : 'page')}
                  onChange={handleContentTypeChange}
                />
              </AccordionContent>
            </AccordionItem>
          )}

          {isCollectionPage && (
            <AccordionItem value="list-settings">
              <AccordionTrigger>List Settings</AccordionTrigger>
              <AccordionContent className="pt-4">
                <CollectionSettingsForm
                  frontmatter={frontmatter}
                  onFrontmatterChange={onFrontmatterChange}
                  layoutManifest={currentLayoutManifest}
                />
              </AccordionContent>
            </AccordionItem>
          )}

          <AccordionItem value="metadata">
            <AccordionTrigger>Metadata</AccordionTrigger>
            <AccordionContent className="pt-4">
              <PageMetadataForm
                siteId={siteId}
                frontmatter={frontmatter}
                onFrontmatterChange={onFrontmatterChange}
                layoutManifest={isCollectionItem ? parentLayoutManifest : currentLayoutManifest}
                isCollectionItem={isCollectionItem}
              />
            </AccordionContent>
          </AccordionItem>

          <AccordionItem value="advanced">
            <AccordionTrigger>Advanced</AccordionTrigger>
            <AccordionContent className="space-y-4 pt-4">
              <AdvancedSettingsForm
                slug={slug}
                onSlugChange={onSlugChange}
                isNewFileMode={isNewFileMode}
              />
              {!isNewFileMode && (
                <div className="pt-4 border-t">
                  <AlertDialog>
                    <AlertDialogTrigger asChild>
                      <Button variant="outline" className="w-full text-destructive hover:bg-destructive/10 hover:text-destructive">
                        <Trash2 className="h-4 w-4 mr-2" /> Delete page
                      </Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent>
                        <AlertDialogHeader>
                          <AlertDialogTitle>Are you sure?</AlertDialogTitle>
                          <AlertDialogDescription>This will permanently delete this page and cannot be undone.</AlertDialogDescription>
                        </AlertDialogHeader>
                        <AlertDialogFooter>
                          <AlertDialogCancel>Cancel</AlertDialogCancel>
                          <AlertDialogAction onClick={onDelete} className="bg-destructive hover:bg-destructive/90">Delete Page</AlertDialogAction>
                        </AlertDialogFooter>
                    </AlertDialogContent>
                  </AlertDialog>
                </div>
              )}
            </AccordionContent>
          </AccordionItem>

        </Accordion>
      </div>
    </div>
  );
}

================================================================================

File: features/editor/components/GroupedFrontmatterFields.tsx
// src/components/publishing/GroupedFrontmatterFields.tsx
'use client';

import { useMemo } from 'react';
import type { RJSFSchema, UiSchema } from '@rjsf/utils';
import SchemaDrivenForm from '../../../core/components/SchemaDrivenForm';
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/core/components/ui/accordion";

interface Group {
  title: string;
  fields: string[];
}
type StrictUiSchema = UiSchema & { 'ui:groups'?: Group[] };

interface GroupedFrontmatterFormProps {
  schema: RJSFSchema;
  uiSchema?: StrictUiSchema;
  formData: Record<string, unknown>;
  onFormChange: (newData: Record<string, unknown>) => void;
}

function createSubSchema(originalSchema: RJSFSchema, fields: string[]): RJSFSchema {
  const subSchema: RJSFSchema = { ...originalSchema, properties: {}, required: originalSchema.required?.filter(field => fields.includes(field)) };
  if (!subSchema.properties) subSchema.properties = {};
  for (const field of fields) {
    if (originalSchema.properties && originalSchema.properties[field]) {
      subSchema.properties[field] = originalSchema.properties[field];
    }
  }
  return subSchema;
}

export default function GroupedFrontmatterForm({
  schema,
  uiSchema,
  formData,
  onFormChange,
}: GroupedFrontmatterFormProps) {
  
  const { groups, ungroupedFields } = useMemo(() => {
    const definedGroups = uiSchema?.['ui:groups'] || [];
    const allSchemaFields = Object.keys(schema.properties || {});
    const fieldsInGroups = new Set(definedGroups.flatMap(g => g.fields));
    const remainingFields = allSchemaFields.filter(f => !fieldsInGroups.has(f));
    return { groups: definedGroups, ungroupedFields: remainingFields };
  }, [schema, uiSchema]);

  // FIXED: The handler now accepts the event from rjsf and extracts the formData.
  const handleChange = (event: { formData?: Record<string, unknown> }) => {
    onFormChange(event.formData || {});
  };

  if (!schema.properties || Object.keys(schema.properties).length === 0) {
    return <p className="text-sm text-muted-foreground">This layout has no configurable fields.</p>;
  }

  return (
    <div className="border-t">
      <Accordion type="multiple" defaultValue={groups.map(g => g.title)} className="w-full">
        {groups.map((group) => {
          if (group.fields.length === 0) return null;
          return (
            <AccordionItem value={group.title} key={group.title}>
              <AccordionTrigger>{group.title}</AccordionTrigger>
              <AccordionContent className="pt-4">
                <SchemaDrivenForm
                  schema={createSubSchema(schema, group.fields)}
                  formData={formData}
                  onFormChange={handleChange}
                />
              </AccordionContent>
            </AccordionItem>
          );
        })}
      </Accordion>

      {ungroupedFields.length > 0 && (
        <div className="">
            <Accordion type='single' collapsible>

<AccordionItem value="item-1">                <AccordionTrigger>
                  Fields
                </AccordionTrigger>
                <AccordionContent>
<SchemaDrivenForm
            schema={createSubSchema(schema, ungroupedFields)}
            formData={formData}
            onFormChange={handleChange}
          />
                </AccordionContent>
              </AccordionItem>
            </Accordion>
          </div>
      )}
    </div>
  );
}

================================================================================

File: features/editor/components/forms/CollectionSettingsForm.tsx
// src/features/editor/components/forms/CollectionCollectionSettingsForm.tsx (FIXED)
'use client';

import { useCallback } from 'react';
// FIX 1: Import the missing types.
import { MarkdownFrontmatter, CollectionConfig, DisplayOption, DisplayOptionChoice } from '@/core/types';
import { LayoutManifest } from '@/core/services/config/configHelpers.service';

// UI Component Imports
import { Label } from '@/core/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { Input } from '@/core/components/ui/input';

// Strongly-typed props for the helper component.
interface StyleSelectorProps {
  optionKey: keyof CollectionConfig;
  optionConfig: DisplayOption | undefined;
  currentValue: string | undefined;
  // The value from a Select is always a string.
  onChange: (key: keyof CollectionConfig, value: string) => void;
}

/**
 * A reusable helper component to render a single dynamic style selector dropdown.
 */
const StyleSelector = ({ optionKey, optionConfig, currentValue, onChange }: StyleSelectorProps) => {
  if (!optionConfig) {
    return null;
  }
  
  return (
    <div className="space-y-2">
      <Label htmlFor={`style-select-${optionKey}`}>{optionConfig.name}</Label>
      <Select
        value={currentValue || optionConfig.default}
        onValueChange={(value) => onChange(optionKey, value)}
      >
        <SelectTrigger id={`style-select-${optionKey}`}>
          <SelectValue placeholder={optionConfig.description || 'Select a style...'} />
        </SelectTrigger>
        <SelectContent>
          {Object.entries(optionConfig.options).map(([key, choice]: [string, DisplayOptionChoice]) => (
            <SelectItem key={key} value={key}>{choice.name}</SelectItem>
          ))}
        </SelectContent>
      </Select>
      {optionConfig.description && (
        <p className="text-xs text-muted-foreground">{optionConfig.description}</p>
      )}
    </div>
  );
};


interface CollectionSettingsFormProps {
  frontmatter: MarkdownFrontmatter;
  onFrontmatterChange: (update: Partial<MarkdownFrontmatter>) => void;
  layoutManifest: LayoutManifest | null;
}

export default function CollectionSettingsForm({
  frontmatter,
  onFrontmatterChange,
  layoutManifest,
}: CollectionSettingsFormProps) {

  const handleCollectionConfigChange = useCallback((key: keyof CollectionConfig, value: string | number | undefined) => {
    const currentConfig = frontmatter.collection || {};
    let updatedConfig: CollectionConfig;

    if (value === undefined || value === '') {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
      const { [key as any]: _, ...rest } = currentConfig;
      updatedConfig = rest;
    } else {
      updatedConfig = { ...currentConfig, [key]: value };
    }

    onFrontmatterChange({
      collection: updatedConfig
    });
  }, [frontmatter.collection, onFrontmatterChange]);
  
  if (!frontmatter.collection) {
    return (
      <div className="text-sm text-center text-muted-foreground p-4 border border-dashed rounded-md">
        <p>This page is not configured as a collection.</p>
      </div>
    );
  }

  const collectionConfig = frontmatter.collection;
  const displayOptions = layoutManifest?.display_options;

  return (
    <div className="space-y-8">
      {/* Section 1: List Settings */}
      <div className="space-y-4">
        <h4 className="font-semibold text-sm text-foreground">List Settings</h4>
        
        <StyleSelector
          optionKey="listingStyle"
          optionConfig={displayOptions?.listingStyle}
          // FIX 2: Use a type assertion to satisfy the prop type.
          currentValue={collectionConfig.listingStyle as string | undefined}
          onChange={handleCollectionConfigChange}
        />
        
        <StyleSelector
          optionKey="teaserStyle"
          optionConfig={displayOptions?.teaserStyle}
          // FIX 3: Use a type assertion here as well.
          currentValue={collectionConfig.teaserStyle as string | undefined}
          onChange={handleCollectionConfigChange}
        />

        <div className="space-y-2 pt-2">
          <Label htmlFor="sort-by">Sort by</Label>
          <Select value={collectionConfig.sort_by || 'date'} onValueChange={(v) => handleCollectionConfigChange('sort_by', v)}>
            <SelectTrigger id="sort-by"><SelectValue /></SelectTrigger>
            <SelectContent>
              <SelectItem value="date">Publication Date</SelectItem>
              <SelectItem value="title">Title (Alphabetical)</SelectItem>
            </SelectContent>
          </Select>
        </div>
        
        <div className="space-y-2">
          <Label htmlFor="sort-order">Sort order</Label>
          <Select value={collectionConfig.sort_order || 'desc'} onValueChange={(v) => handleCollectionConfigChange('sort_order', v)}>
            <SelectTrigger id="sort-order"><SelectValue /></SelectTrigger>
            <SelectContent>
              <SelectItem value="desc">Descending</SelectItem>
              <SelectItem value="asc">Ascending</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div className="space-y-2">
          <Label htmlFor="items-per-page">Items Per Page</Label>
          <Input
            id="items-per-page"
            type="number"
            min="1"
            placeholder="e.g., 10"
            value={collectionConfig.items_per_page || ''}
            onChange={(e) => handleCollectionConfigChange('items_per_page', e.target.value ? parseInt(e.target.value, 10) : undefined)}
          />
          <p className="text-xs text-muted-foreground">Leave blank to show all items on one page.</p>
        </div>
      </div>

      {/* Section 2: Item Settings */}
      <div className="space-y-4 pt-6 border-t">
        <h4 className="font-semibold text-sm text-foreground">Item Settings</h4>
        
        <StyleSelector
          optionKey="itemPageLayout"
          optionConfig={displayOptions?.itemPageLayout}
          // FIX 4: And the final type assertion here.
          currentValue={collectionConfig.itemPageLayout as string | undefined}
          onChange={handleCollectionConfigChange}
        />
      </div>
    </div>
  );
}

================================================================================

File: features/editor/components/forms/AdvancedSettingsForm.tsx
// src/features/editor/components/forms/AdvancedSettingsForm.tsx
'use client';

import { Label } from '@/core/components/ui/label';
import { Input } from '@/core/components/ui/input';

/**
 * Defines the props for the AdvancedSettingsForm component.
 */
interface AdvancedSettingsFormProps {
  /**
   * The current URL slug for the page.
   */
  slug: string;

  /**
   * A callback function that is triggered when the user types in the slug input field.
   */
  onSlugChange: (newSlug: string) => void;

  /**
   * A flag indicating if the editor is in "new file mode".
   * The slug can only be edited when this is true.
   */
  isNewFileMode: boolean;
}

/**
 * A form component for editing advanced page properties, primarily the URL slug.
 * It enforces the rule that the slug is only editable before the page is first saved.
 *
 * @param {AdvancedSettingsFormProps} props The props for the component.
 * @returns {React.ReactElement} The rendered component.
 */
export default function AdvancedSettingsForm({
  slug,
  onSlugChange,
  isNewFileMode,
}: AdvancedSettingsFormProps) {
  return (
    <div className="space-y-2">
      {/* 
        The Label is associated with the Input via the `htmlFor` attribute,
        which improves accessibility.
      */}
      <Label htmlFor="slug-input">URL Slug</Label>
      <Input
        id="slug-input"
        value={slug}
        onChange={(e) => onSlugChange(e.target.value)}
        // The input is disabled if the page is NOT in new file mode.
        // This prevents users from changing the URL of an existing page.
        disabled={!isNewFileMode}
        placeholder="e.g., a-great-blog-post"
        // This accessibility attribute links the input to its description.
        aria-describedby="slug-description"
      />
      {/* 
        Helper text that dynamically changes to explain the input's state to the user.
        This is a key part of good user experience.
      */}
      <p id="slug-description" className="text-xs text-muted-foreground">
        {isNewFileMode
          ? 'The URL-friendly version of the title. Auto-generated, but can be edited here before the first save.'
          : 'The URL for this page cannot be changed after it has been saved.'}
      </p>
    </div>
  );
}

================================================================================

File: features/editor/components/forms/CoreSchemaForm.tsx
// src/features/editor/components/forms/CoreSchemaForm.tsx
'use client';

import { MarkdownFrontmatter } from '@/core/types';
import SchemaDrivenForm from '@/core/components/SchemaDrivenForm';
import { BASE_SCHEMA } from '@/config/editorConfig';
import { RJSFSchema, UiSchema } from '@rjsf/utils';
import ImageUploadWidget from '../ImageUploadWidget';

interface CoreSchemaFormProps {
  siteId: string;
  frontmatter: MarkdownFrontmatter;
  onFrontmatterChange: (update: Partial<MarkdownFrontmatter>) => void;
  // We need to know if the page is a collection item to hide fields like 'date'
  isCollectionItem: boolean; 
}

/**
 * Renders a form for the universal, core frontmatter fields (date, status, etc.)
 * that apply to almost all content types.
 */
export default function CoreSchemaForm({
  siteId,
  frontmatter,
  onFrontmatterChange,
  isCollectionItem,
}: CoreSchemaFormProps) {
  
  // Dynamically adjust the schema based on context
  const schema: RJSFSchema = { ...BASE_SCHEMA.schema };
  const uiSchema: UiSchema = { ...BASE_SCHEMA.uiSchema };
    const customWidgets = { imageUploader: ImageUploadWidget };

  // Hide the date field for collection items, as it's often managed differently
  if (isCollectionItem && schema.properties?.date) {
    // A simple way to hide is to modify uiSchema
    uiSchema.date = { ...uiSchema.date, 'ui:widget': 'hidden' };
  }

  return (
    <SchemaDrivenForm 
      schema={schema}
      uiSchema={uiSchema}
      formData={frontmatter}
      widgets={customWidgets}
      onFormChange={(data) => onFrontmatterChange(data as Partial<MarkdownFrontmatter>)}
      formContext={{ siteId }}
    />
  );
}

================================================================================

File: features/editor/components/forms/CollectionLayoutSchemaForm.tsx
// src/features/editor/components/forms/CollectionLayoutSchemaForm.tsx
'use client';

// Imports are identical to PageLayoutSchemaForm
import { MarkdownFrontmatter } from '@/core/types';
import { LayoutManifest } from '@/core/services/config/configHelpers.service';
import SchemaDrivenForm from '@/core/components/SchemaDrivenForm';
import ImageUploadWidget from '../ImageUploadWidget';

interface CollectionLayoutSchemaFormProps {
  siteId: string;
  layoutManifest: LayoutManifest | null;
  frontmatter: MarkdownFrontmatter;
  onFrontmatterChange: (update: Partial<MarkdownFrontmatter>) => void;
}

/**
 * Renders a form for the custom fields defined in a "collection" layout's main 'schema'.
 * This applies to the collection page itself, not its items.
 */
export default function CollectionLayoutSchemaForm({
  siteId,
  layoutManifest,
  frontmatter,
  onFrontmatterChange,
}: CollectionLayoutSchemaFormProps) {
  
  const customWidgets = { imageUploader: ImageUploadWidget };

  if (!layoutManifest?.schema) {
    return <p className="text-sm text-muted-foreground p-2">This layout has no custom collection page options.</p>;
  }

  return (
    <SchemaDrivenForm 
      schema={layoutManifest.schema}
      uiSchema={layoutManifest.uiSchema ?? undefined}
      formData={frontmatter}
      onFormChange={(data) => onFrontmatterChange(data as Partial<MarkdownFrontmatter>)}
      widgets={customWidgets}
      formContext={{ siteId }}
    />
  );
}

================================================================================

File: features/editor/components/forms/PageMetaDataForm.tsx
// src/features/editor/components/forms/PageMetadataForm.tsx
'use client';

import { useMemo } from 'react';
import { RJSFSchema, UiSchema } from '@rjsf/utils';
import { MarkdownFrontmatter } from '@/core/types';
import { LayoutManifest } from '@/core/services/config/configHelpers.service';
import { BASE_SCHEMA } from '@/config/editorConfig';

// Reusable components for form rendering
import SchemaDrivenForm from '@/core/components/SchemaDrivenForm';
import ImageUploadWidget from '@/features/editor/components/ImageUploadWidget';

/**
 * Defines the props for the PageMetadataForm component.
 */
interface PageMetadataFormProps {
  /** The ID of the site, passed down for context to custom widgets like the image uploader. */
  siteId: string;

  /** The complete frontmatter object for the current page being edited. */
  frontmatter: MarkdownFrontmatter;

  /** A callback to update the parent component's frontmatter state. */
  onFrontmatterChange: (update: Partial<MarkdownFrontmatter>) => void;

  /** The parsed manifest of the currently selected Content Type (Layout). Can be null if none is selected. */
  layoutManifest: LayoutManifest | null;

  /** A flag to indicate if the current page is an item within a collection (e.g., a blog post). */
  isCollectionItem: boolean;
}

/**
 * A component that renders a combined form for both core and layout-specific metadata.
 * It intelligently merges schemas and UI configurations to present a unified editing
 * experience for any type of content.
 */
export default function PageMetadataForm({
  siteId,
  frontmatter,
  onFrontmatterChange,
  layoutManifest,
  isCollectionItem,
}: PageMetadataFormProps) {

  // Define the custom widgets that can be used by the SchemaDrivenForm.
  const customWidgets = { imageUploader: ImageUploadWidget };

  /**
   * This is the core logic of the component.
   * `useMemo` is used to efficiently compute the final, merged schema that will be
   * rendered by the form. This calculation only re-runs if the `layoutManifest`
   * or `isCollectionItem` flag changes, preventing unnecessary re-renders.
   */
  const mergedSchemaAndUi = useMemo(() => {
    // 1. Start with a deep copy of the universal BASE_SCHEMA to avoid mutation.
    const finalSchema: RJSFSchema = JSON.parse(JSON.stringify(BASE_SCHEMA.schema));
    const finalUiSchema: UiSchema = JSON.parse(JSON.stringify(BASE_SCHEMA.uiSchema));

    // 2. Determine which custom schema to use from the layout manifest based on the page's role.
    let customSchema: RJSFSchema | undefined;
    let customUiSchema: UiSchema | undefined;

    if (isCollectionItem) {
      // For collection items (e.g., a post), use the 'itemSchema'.
      customSchema = layoutManifest?.itemSchema;
      customUiSchema = layoutManifest?.itemUiSchema;
    } else {
      // For standard pages or collection list pages, use the main 'schema'.
      customSchema = layoutManifest?.schema;
      customUiSchema = layoutManifest?.uiSchema;
    }

    // 3. Merge the custom schema into the final schema.
    if (customSchema?.properties) {
      // Combine properties, with custom fields overwriting core fields if names conflict.
      finalSchema.properties = { ...finalSchema.properties, ...customSchema.properties };
      // Combine required fields, ensuring no duplicates.
      finalSchema.required = [...new Set([...(finalSchema.required || []), ...(customSchema.required || [])])];
    }
    
    // Merge the custom UI schema.
    if (customUiSchema) {
      Object.assign(finalUiSchema, customUiSchema);
    }
    
    // 4. Apply contextual adjustments. For example, hide the 'date' field for collection items,
    // as their date is usually managed differently.
    if (isCollectionItem) {
        finalUiSchema.date = { 'ui:widget': 'hidden' };
    }

    return { schema: finalSchema, uiSchema: finalUiSchema };
  }, [layoutManifest, isCollectionItem]);


  // Check if there are any fields to render after merging.
  const hasFields = mergedSchemaAndUi.schema?.properties && Object.keys(mergedSchemaAndUi.schema.properties).length > 0;

  if (!hasFields) {
    return (
      <div className="text-sm text-center text-muted-foreground p-4 border border-dashed rounded-md">
        <p>This content type has no additional metadata options.</p>
      </div>
    );
  }

  return (
    <SchemaDrivenForm
      schema={mergedSchemaAndUi.schema}
      uiSchema={mergedSchemaAndUi.uiSchema}
      formData={frontmatter}
      // Pass the frontmatter update callback directly to the form.
      onFormChange={(data) => onFrontmatterChange(data as Partial<MarkdownFrontmatter>)}
      // Register custom widgets.
      widgets={customWidgets}
      // Provide the siteId in the form's context so custom widgets can access it.
      formContext={{ siteId }}
    />
  );
}

================================================================================

File: features/editor/components/forms/ContentTypeSelector.tsx
// src/features/editor/components/forms/ContentTypeSelector.tsx
'use client';

import { Select, SelectContent, SelectGroup, SelectItem, SelectTrigger, SelectValue } from "@/core/components/ui/select";
import { Label } from "@/core/components/ui/label";
import { LayoutManifest } from '@/core/services/config/configHelpers.service';

interface ContentTypeSelectorProps {
  availableTypes: LayoutManifest[];
  selectedType: string;
  onChange: (newTypeId: string) => void;
}

export default function ContentTypeSelector({ availableTypes, selectedType, onChange }: ContentTypeSelectorProps) {
  const selectedTypeManifest = availableTypes.find(type => type.id === selectedType);

  return (
    <div className="space-y-2">
      <Label htmlFor="content-type-select">Content Type</Label>
      <Select
        value={selectedType || ''}
        onValueChange={onChange}
      >
        <SelectTrigger id="content-type-select" className="w-full">
          <SelectValue placeholder="Select a content type..." />
        </SelectTrigger>
        <SelectContent>
          <SelectGroup>
            {availableTypes.map((type) => (
              <SelectItem key={type.id} value={type.id}>
                {type.name}
              </SelectItem>
            ))}
          </SelectGroup>
        </SelectContent>
      </Select>
      {selectedTypeManifest?.description && (
        <p className="text-xs text-muted-foreground pt-1">
          {selectedTypeManifest.description}
        </p>
      )}
    </div>
  );
}

================================================================================

File: features/editor/hooks/useUnloadPrompt.ts
// src/features/editor/hooks/useUnloadPrompt.ts
'use client';

import { useEffect } from 'react';

/**
 * A hook that shows the native browser confirmation dialog when the user
 * attempts to navigate away from the page.
 *
 * @param {boolean} shouldPrompt - A flag that determines whether the prompt should be shown.
 */
export function useUnloadPrompt(shouldPrompt: boolean) {
  useEffect(() => {
    const handleBeforeUnload = (event: BeforeUnloadEvent) => {
      if (shouldPrompt) {
        // Standard way to trigger the browser's native confirmation dialog
        event.preventDefault();
        // Required for some older browsers
        event.returnValue = '';
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);

    // Cleanup the event listener when the component unmounts
    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, [shouldPrompt]); // The effect re-runs whenever the `shouldPrompt` flag changes
}

================================================================================

File: features/editor/hooks/usePageIdentifier.ts
// src/features/editor/hooks/usePageIdentifier.ts

import { useMemo } from 'react';
import { useParams, useLocation } from 'react-router-dom';
import { NEW_FILE_SLUG_MARKER } from '@/config/editorConfig';
import { type ParsedMarkdownFile, type StructureNode } from '@/core/types';

interface PageIdentifierParams {
  siteStructure: StructureNode[];
  allContentFiles: ParsedMarkdownFile[];
}

/**
 * A data-aware hook that parses the URL to identify the site and the specific
 * file path being targeted for editing, using react-router-dom hooks.
 */
export function usePageIdentifier({ allContentFiles }: PageIdentifierParams) {
  // Get routing information from react-router-dom
  const { siteId = '' } = useParams<{ siteId: string }>();
  const location = useLocation();

  // The full path after the hash, e.g., /sites/123/edit/content/about
  const fullPath = location.pathname;

  const { slugSegments, isNewFileMode } = useMemo(() => {
    // Defines the base path for the content editor
    const editorRootPath = `/sites/${siteId}/edit/content`;
    
    if (fullPath.startsWith(editorRootPath)) {
      const slugPart = fullPath.substring(editorRootPath.length).replace(/^\//, '');
      const segments = slugPart ? slugPart.split('/') : [];
      const isNew = segments.includes(NEW_FILE_SLUG_MARKER);
      return { slugSegments: segments, isNewFileMode: isNew };
    }
    
    // Default case if not in a content editor route
    return { slugSegments: [], isNewFileMode: false };
  }, [fullPath, siteId]);

  const filePath = useMemo(() => {
    if (isNewFileMode) {
      const parentSlug = slugSegments.slice(0, slugSegments.indexOf(NEW_FILE_SLUG_MARKER)).join('/');
      return parentSlug ? `content/${parentSlug}` : 'content';
    }

    const slug = slugSegments.join('/');
    if (slug) {
      return `content/${slug}.md`;
    }
    
    // Homepage Resolution Logic: Find the file with homepage: true
    const homepageFile = allContentFiles.find(f => f.frontmatter.homepage === true);
    if (homepageFile) {
      return homepageFile.path;
    }
    
    return ''; // Return empty string if no path can be determined
  }, [slugSegments, isNewFileMode, allContentFiles]);

  return { siteId, isNewFileMode, filePath };
}

================================================================================

File: features/editor/hooks/useFileContent.ts
// src/features/editor/hooks/useFileContent.ts
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom'; 
import { useAppStore } from '@/core/state/useAppStore';
import { useEditor } from '@/features/editor/contexts/useEditor';
import { slugify } from '@/core/libraries/utils';
import { toast } from 'sonner';
import { type MarkdownFrontmatter } from '@/core/types';
import { DEFAULT_PAGE_LAYOUT_PATH } from '@/config/editorConfig';
import { type Block } from '@blocknote/core';
import { markdownToBlocks } from '@/core/services/blocknote.service';

/**
 * Manages the content state for the editor.
 *
 * This hook is responsible for:
 * 1.  Taking a definitive `filePath` (from `usePageIdentifier`).
 * 2.  Waiting for the global site data to be loaded into the Zustand store.
 * 3.  **Reading the file's content directly from the store, not re-fetching it from storage.**
 * 4.  Preparing the initial state for the editor (frontmatter, Blocknote blocks).
 * 5.  Handling state changes as the user types or modifies frontmatter fields.
 *
 * @param siteId The ID of the current site.
 * @param filePath The unambiguous path to the file to be loaded.
 * @param isNewFileMode A flag indicating if we are creating a new file.
 * @returns An object containing the status, content state, and state handlers.
 */

export type FileStatus = 'initializing' | 'loading' | 'ready' | 'not_found';
interface PageFrontmatter extends MarkdownFrontmatter { menuTitle?: string; }

export function useFileContent(siteId: string, filePath: string, isNewFileMode: boolean) {
  const navigate = useNavigate(); // <--- Use the navigate hook
  const site = useAppStore(state => state.getSiteById(siteId));
  const { setHasUnsavedChanges } = useEditor();

  const [status, setStatus] = useState<FileStatus>('initializing');
  const [frontmatter, setFrontmatter] = useState<PageFrontmatter | null>(null);
  const [slug, setSlug] = useState('');
  const [initialBlocks, setInitialBlocks] = useState<Block[]>([]);

  useEffect(() => {
    const loadData = async () => {
      if (!filePath) {
        setStatus('loading');
        return;
      }
      if (!site?.contentFiles) {
        setStatus('loading');
        return;
      }
      let markdownContent = '';
      if (isNewFileMode) {
        // Check if this is a collection item by looking at the parent directory
        const parentPath = `${filePath}.md`; // Convert parent dir to collection page path
        const parentFile = site.contentFiles.find(f => f.path === parentPath);
        const isCollectionItem = !!parentFile?.frontmatter.collection;
        
        if (isCollectionItem) {
          // Setup for a new collection item - use parent's item_layout or empty string
          const itemLayout = String(parentFile?.frontmatter.collection?.item_layout || '');
          setFrontmatter({
            title: '',
            layout: itemLayout,
            date: new Date().toISOString().split('T')[0],
            status: 'draft',
          });
        } else {
          // Setup for a brand new regular page
          setFrontmatter({
            title: '',
            layout: DEFAULT_PAGE_LAYOUT_PATH,
            date: new Date().toISOString().split('T')[0],
            status: 'draft',
          });
        }
        
        markdownContent = 'Start writing...';
        setSlug('');
       } else {
        const fileData = site.contentFiles.find(f => f.path === filePath);
        if (!fileData) {
          setStatus('not_found');
          toast.error(`Content file not found at path: ${filePath}`);
          // Use navigate to redirect
          navigate(`/sites/${siteId}/edit`, { replace: true }); 
          return;
        }
        setFrontmatter(fileData.frontmatter);
        markdownContent = fileData.content;
        setSlug(fileData.slug);
      }
      
      const blocks = await markdownToBlocks(markdownContent);
      setInitialBlocks(blocks);
      setStatus('ready');
      setHasUnsavedChanges(false);
    };

    loadData();
    
  }, [site, filePath, isNewFileMode, siteId, navigate, setHasUnsavedChanges]);

  // Callback to signal that some content (either body or frontmatter) has changed.
  const onContentModified = useCallback(() => {
    setHasUnsavedChanges(true);
  }, [setHasUnsavedChanges]);

  // Handler for frontmatter form changes. It receives a partial update.
  const handleFrontmatterChange = useCallback((update: Partial<PageFrontmatter>) => {
    setFrontmatter(prev => {
      if (!prev) return null;
      const newFm = { ...prev, ...update };
      // Auto-generate the slug from the title, but only for new files.
      if (isNewFileMode && update.title !== undefined) {
        setSlug(slugify(update.title));
      }
      return newFm;
    });
    onContentModified();
  }, [isNewFileMode, onContentModified]);

  return { status, frontmatter, initialBlocks, slug, setSlug, handleFrontmatterChange, onContentModified };
}

================================================================================

File: features/editor/hooks/useFilePersistence.ts
// src/features/editor/hooks/useFilePersistence.ts

import { useCallback, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom'; // Import useNavigate from react-router-dom
import { useAppStore } from '@/core/state/useAppStore';
import { useEditor } from '@/features/editor/contexts/useEditor';
import { stringifyToMarkdown } from '@/core/libraries/markdownParser';
import { AUTOSAVE_DELAY } from '@/config/editorConfig';
import { toast } from 'sonner';
import { useUnloadPrompt } from './useUnloadPrompt';

// Type imports
import { type MarkdownFrontmatter } from '@/core/types';
import { type Block } from '@blocknote/core';
import { blocksToMarkdown } from '@/core/services/blocknote.service';

interface PersistenceParams {
  siteId: string;
  filePath: string;
  isNewFileMode: boolean;
  frontmatter: MarkdownFrontmatter | null;
  slug: string;
  getEditorContent: () => Block[]; 
}

export function useFilePersistence({
  siteId, filePath, isNewFileMode, frontmatter, slug, getEditorContent,
}: PersistenceParams) {
  // Use the navigate hook from react-router-dom
  const navigate = useNavigate(); 
  
  // These app state interactions do not need to change
  const { addOrUpdateContentFile, deleteContentFileAndState, getSiteById } = useAppStore.getState();
  const { hasUnsavedChanges, setHasUnsavedChanges, setSaveState, registerSaveAction } = useEditor();
  const autosaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const handleSave = useCallback(async () => {
    if (autosaveTimeoutRef.current) clearTimeout(autosaveTimeoutRef.current);
    if (!frontmatter) throw new Error("Frontmatter not ready for saving.");
    if (!frontmatter.title.trim()) throw new Error("A title is required before saving.");

    const currentBlocks = getEditorContent();
    const markdownBody = await blocksToMarkdown(currentBlocks);
    
    if (isNewFileMode) {
      // --- CREATION LOGIC (First Save) ---
      if (!slug.trim()) throw new Error("A URL slug is required for a new page.");
      
      const site = getSiteById(siteId);
      const finalPath = `${filePath}/${slug.trim()}.md`.replace('//', '/');

      if (site?.contentFiles?.some(f => f.path === finalPath)) {
        throw new Error(`A page with the path "${slug}" already exists.`);
      }

      const rawMarkdown = stringifyToMarkdown(frontmatter, markdownBody);
      await addOrUpdateContentFile(siteId, finalPath, rawMarkdown);

      const newEditPath = finalPath.replace(/^content\//, '').replace(/\.md$/, '');
      
      // --- CHANGE: Replace router.replace with navigate ---
      // This updates the URL in the address bar without adding a new entry to the history.
      navigate(`/sites/${siteId}/edit/content/${newEditPath}`, { replace: true });

    } else {
      // --- UPDATE LOGIC (Subsequent Saves) ---
      const rawMarkdown = stringifyToMarkdown(frontmatter, markdownBody);
      await addOrUpdateContentFile(siteId, filePath, rawMarkdown);
    }
  }, [siteId, filePath, isNewFileMode, frontmatter, slug, getEditorContent, addOrUpdateContentFile, getSiteById, navigate]); // Add navigate to dependency array

  const handleDelete = useCallback(async () => {
    if (isNewFileMode || !frontmatter) return;
    try {
      await deleteContentFileAndState(siteId, filePath);
      toast.success(`Page "${frontmatter.title}" deleted.`);

      // --- CHANGE: Replace router.push with navigate ---
      // This navigates the user back to the editor's root page after deletion.
      navigate(`/sites/${siteId}/edit`);

    } catch (error) {
      toast.error(`Failed to delete page: ${(error as Error).message}`);
    }
  }, [isNewFileMode, frontmatter, deleteContentFileAndState, siteId, filePath, navigate]); // Add navigate to dependency array

  // This effect registers the save action with the editor context. No changes needed.
  useEffect(() => {
    registerSaveAction(handleSave);
  }, [handleSave, registerSaveAction]);

  // This effect handles the autosave logic. No changes needed.
  useEffect(() => {
    if (autosaveTimeoutRef.current) clearTimeout(autosaveTimeoutRef.current);
    if (hasUnsavedChanges && !isNewFileMode) {
      autosaveTimeoutRef.current = setTimeout(async () => {
        setSaveState('saving');
        try {
          await handleSave();
          setHasUnsavedChanges(false);
          setSaveState('saved');
          setTimeout(() => setSaveState('no_changes'), 2000);
        } catch (error) { 
            console.error("Autosave failed:", error); 
            setSaveState('idle'); 
        }
      }, AUTOSAVE_DELAY);
    }
    return () => { if (autosaveTimeoutRef.current) clearTimeout(autosaveTimeoutRef.current); };
  }, [hasUnsavedChanges, isNewFileMode, handleSave, setSaveState, setHasUnsavedChanges]);

  // This hook handles the "Are you sure you want to leave?" prompt. No changes needed.
  useUnloadPrompt(hasUnsavedChanges);

  return { handleDelete };
}

================================================================================

File: pages/HomePageDashboard.tsx
// src/pages/HomePageDashboard.tsx

import { useState, useRef, useCallback } from 'react';
import { Link } from 'react-router-dom'; // Use react-router-dom's Link

// State Management (no changes needed)
import { useAppStore } from '@/core/state/useAppStore';
import { type LocalSiteData } from '@/core/types';

// Services (no changes needed)
import { importSiteFromZip, exportSiteBackup } from '@/core/services/siteBackup.service';
import { saveAllImageAssetsForSite } from '@/core/services/localFileSystem.service';
import { slugify } from '@/core/libraries/utils';

// UI Components & Icons (no changes needed)
import { Button } from '@/core/components/ui/button';
import { toast } from 'sonner';
import { FilePlus2, Leaf, Upload, Eye, Edit3, Archive, Trash2, MoreVertical } from 'lucide-react';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuSeparator, DropdownMenuTrigger } from '@/core/components/ui/dropdown-menu';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/core/components/ui/alert-dialog";

export default function HomePageDashboard() {
  // All state management, handlers, and logic are ported directly from the original
  // component. No changes are needed here as this logic is framework-agnostic.
  const { sites, getSiteById, addSite, updateSiteSecrets, loadSite, deleteSiteAndState } = useAppStore();
  const [isImporting, setIsImporting] = useState(false);
  const [isOverwriteDialogOpen, setIsOverwriteDialogOpen] = useState(false);
  const [importedData, setImportedData] = useState<(LocalSiteData & { imageAssetsToSave?: Record<string, Blob> }) | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const finishImport = useCallback(async (data: LocalSiteData & { imageAssetsToSave?: Record<string, Blob> }) => {
    try {
      const { imageAssetsToSave, ...siteDataToSave } = data;
      await addSite(siteDataToSave);
      if(siteDataToSave.secrets) {
        await updateSiteSecrets(siteDataToSave.siteId, siteDataToSave.secrets);
      }
      if(imageAssetsToSave) {
        await saveAllImageAssetsForSite(siteDataToSave.siteId, imageAssetsToSave);
      }
      toast.success(`Site "${data.manifest.title}" imported successfully!`);
    } catch (error) {
      console.error("Error finishing site import:", error);
      toast.error(`Failed to save imported site: ${(error as Error).message}`);
    }
  }, [addSite, updateSiteSecrets]);

  const handleFileSelected = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
    setIsImporting(true);
    toast.info("Importing site from backup...");
    try {
      const data = await importSiteFromZip(file);
      const existingSite = getSiteById(data.siteId);
      if (existingSite) {
        setImportedData(data);
        setIsOverwriteDialogOpen(true);
      } else {
        await finishImport(data);
      }
    } catch (error) {
      console.error("Error during site import:", error);
      toast.error(`Import failed: ${(error as Error).message}`);
    } finally {
      if (fileInputRef.current) fileInputRef.current.value = "";
      setIsImporting(false);
    }
  };

  const handleOverwriteConfirm = async () => {
    if (importedData) await finishImport(importedData);
    setIsOverwriteDialogOpen(false);
    setImportedData(null);
  };
  
  const handleExportBackup = async (siteId: string) => {
    toast.info("Preparing site backup...");
    try {
        await loadSite(siteId);
        const siteToExport = getSiteById(siteId);
        if (!siteToExport) throw new Error("Could not load site data for export.");
        const blob = await exportSiteBackup(siteToExport);
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `${slugify(siteToExport.manifest.title || 'signum-backup')}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        toast.success("Site backup downloaded!");
    } catch (error) {
        console.error("Failed to export site:", error);
        toast.error(`Export failed: ${(error as Error).message}`);
    }
  };

  const handleDeleteSite = async (siteId: string, siteTitle: string) => {
    try {
      await deleteSiteAndState(siteId);
      toast.success(`Site "${siteTitle}" has been deleted.`);
    } catch (error) {
      toast.error(`Failed to delete site "${siteTitle}".`);
      console.error("Error deleting site:", error);
    }
  };

    const validSites = sites.filter((site: LocalSiteData) => site && site.manifest);

  return (
    <>
       <title>My Sites - Sparktype Dashboard</title>
      
      {/* The JSX is identical, but Next's <Link> is replaced with react-router-dom's <Link> */}
      <header className="sticky top-0 z-40 w-full border-b bg-background/95 backdrop-blur-sm">
        <div className="container mx-auto flex h-16 items-center justify-between px-4">
          <Link to="/" className="flex items-center gap-2">
            <Leaf className="h-7 w-7 text-primary" />
            <span className="text-2xl font-bold text-foreground hidden sm:inline">Sparktype</span>
          </Link>
          <div className="flex items-center gap-2">
            <Button variant="outline" onClick={() => fileInputRef.current?.click()} disabled={isImporting}>
              <Upload className="mr-2 h-4 w-4" /> {isImporting ? 'Importing...' : 'Import site'}
            </Button>
            <Button asChild>
              <Link to="/create-site"><FilePlus2 className="mr-2 h-4 w-4" /> Create new site</Link>
            </Button>
          </div>
        </div>
      </header>
      
      <main className="container mx-auto p-4 sm:p-6 lg:p-8">
        <h1 className="text-3xl font-bold text-foreground mb-8">My sites</h1>
        {validSites.length === 0 ? (
          <div className="text-center py-10 border-2 border-dashed border-muted rounded-lg">
            <h2 className="text-xl font-semibold text-muted-foreground mb-2">No Sites Yet!</h2>
            <p className="text-muted-foreground mb-4">Click "Create New Site" or "Import Site" to get started.</p>
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {validSites.map((site: LocalSiteData) => (
              <div key={site.siteId} className="bg-card border rounded-lg p-6 shadow-sm hover:shadow-lg transition-shadow flex flex-col justify-between">
                <div>
                  <h2 className="text-xl font-semibold text-card-foreground mb-2 truncate" title={site.manifest.title}>
                    {site.manifest.title || "Untitled Site"}
                  </h2>
                  <p className="text-sm text-muted-foreground mb-4 line-clamp-2" title={site.manifest.description}>
                    {site.manifest.description || 'No description provided.'}
                  </p>
                </div>
                <div className="mt-4 flex flex-wrap justify-end gap-2">
                  <Button variant="default" size="sm" asChild>
                    <Link to={`/sites/${site.siteId}/edit`}><Edit3 className="mr-2 h-4 w-4" /> Edit</Link>
                  </Button>
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="outline" size="icon"><MoreVertical className="h-4 w-4" /></Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      {/*
                        The "View Live Preview" link now correctly navigates to the hash-based route.
                        `target="_blank"` will open a new browser tab with the hash URL, which works perfectly.
                      */}
                      <DropdownMenuItem asChild>
                        <Link to={`/sites/${site.siteId}/view`} target="_blank" rel="noopener noreferrer">
                          <Eye className="mr-2 h-4 w-4" /> View Live Preview
                        </Link>
                      </DropdownMenuItem>
                      <DropdownMenuItem onClick={() => handleExportBackup(site.siteId)}><Archive className="mr-2 h-4 w-4" /> Export backup</DropdownMenuItem>
                      <DropdownMenuSeparator />
                      <AlertDialog>
                        <AlertDialogTrigger asChild>
                          <DropdownMenuItem onSelect={(e: Event) => e.preventDefault()} className="text-destructive focus:bg-destructive/10 focus:text-destructive">
                            <Trash2 className="mr-2 h-4 w-4" /> Delete site
                          </DropdownMenuItem>
                        </AlertDialogTrigger>
                        <AlertDialogContent>
                          <AlertDialogHeader>
                            <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                            <AlertDialogDescription>This action will permanently delete "{site.manifest.title}" and cannot be undone.</AlertDialogDescription>
                          </AlertDialogHeader>
                          <AlertDialogFooter>
                            <AlertDialogCancel>Cancel</AlertDialogCancel>
                            <AlertDialogAction onClick={() => handleDeleteSite(site.siteId, site.manifest.title)} className="bg-destructive hover:bg-destructive/90">Yes, delete site</AlertDialogAction>
                          </AlertDialogFooter>
                        </AlertDialogContent>
                      </AlertDialog>
                    </DropdownMenuContent>
                  </DropdownMenu>
                </div>
              </div>
            ))}
          </div>
        )}
      </main>

      <input type="file" ref={fileInputRef} onChange={handleFileSelected} accept=".zip" className="hidden" />

      {/* The AlertDialog logic is self-contained and requires no changes */}
      <AlertDialog open={isOverwriteDialogOpen} onOpenChange={setIsOverwriteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Site Already Exists</AlertDialogTitle>
            <AlertDialogDescription>
              A site with the ID "{importedData?.siteId}" already exists. Do you want to overwrite it with the data from the backup file?
              <br/><br/>
              <strong>This action cannot be undone.</strong>
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={() => setImportedData(null)}>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleOverwriteConfirm} className="bg-destructive hover:bg-destructive/90">Overwrite</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

================================================================================

File: pages/MarketingHomePage.tsx
// src/pages/MarketingHomePage.tsx

import { Link } from 'react-router-dom';

// UI Components (no changes needed)
import { Button } from '@/core/components/ui/button';
import { ShieldCheck, Feather, Zap, Archive, Leaf } from 'lucide-react';

// NO MORE 'react-helmet-async' import needed!

export default function MarketingHomePage() {
  return (
    <>
      {/*
        THIS IS THE NEW REACT 19 WAY.
        You can render <title> and <meta> tags directly in your component.
        React 19 will automatically move them to the document <head>.
      */}
      <title>Sparktype - Own Your Content</title>
      <meta name="description" content="A simple, private, and portable publishing platform that puts you back in control." />
      
      <header className="sticky top-0 z-40 w-full border-b bg-background/95 backdrop-blur-sm">
        <div className="container mx-auto flex h-16 items-center justify-between px-4">
          <Link to="/" className="flex items-center gap-2">
            <Leaf className="h-7 w-7 text-primary" />
            <span className="text-2xl font-bold text-foreground hidden sm:inline">Sparktype</span>
          </Link>
          <Button asChild variant="ghost">
            <Link to="/sites">Dashboard</Link>
          </Button>
        </div>
      </header>

      <div className="container mx-auto px-4 py-16 sm:py-24 text-center">
        <header className="mb-12">
          <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold tracking-tight text-foreground">
            Sparktype: Own Your Content.
          </h1>
          <p className="mt-4 max-w-2xl mx-auto text-lg sm:text-xl text-muted-foreground">
            A simple, private, and portable publishing platform that puts you back in control.
          </p>
        </header>

        <div className="mb-16">
          <Button asChild size="lg">
            {/* The primary call-to-action now correctly links to the dashboard route. */}
            <Link to="/sites">
              Open Dashboard & Get Started
            </Link>
          </Button>
        </div>

        <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8 max-w-5xl mx-auto">
          <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
            <ShieldCheck className="size-10 text-primary mb-4" />
            <h3 className="text-xl font-semibold mb-2">Private & Secure</h3>
            <p className="text-muted-foreground text-sm">
              No tracking or surveillance by default. Your data is yours.
            </p>
          </div>
          <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
            <Feather className="size-10 text-primary mb-4" />
            <h3 className="text-xl font-semibold mb-2">Simple & Focused</h3>
            <p className="text-muted-foreground text-sm">
              A minimal, content-first editor lets you focus on writing.
            </p>
          </div>
          <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
            <Zap className="size-10 text-primary mb-4" />
            <h3 className="text-xl font-semibold mb-2">Blazingly Fast</h3>
            <p className="text-muted-foreground text-sm">
              Static sites are fast, reliable, and efficient to host.
            </p>
          </div>
          <div className="flex flex-col items-center p-6 bg-card border rounded-lg">
            <Archive className="size-10 text-primary mb-4" />
            <h3 className="text-xl font-semibold mb-2">Truly Portable</h3>
            <p className="text-muted-foreground text-sm">
              Export your entire site anytime. No vendor lock-in, ever.
            </p>
          </div>
        </section>
      </div>
    </>
  );
}

================================================================================

File: pages/CreateSitePage.tsx
// src/pages/CreateSitePage.tsx

import { useState, useMemo } from 'react';
import { useNavigate } from 'react-router-dom'; // Use react-router-dom's hook for navigation

// State Management
import { useAppStore } from '@/core/state/useAppStore';

// Services and Config
import { generateSiteId } from '@/core/libraries/utils';
import { getMergedThemeDataForForm } from '@/core/services/config/theme.service';
import { GENERATOR_VERSION, CORE_THEMES } from '@/config/editorConfig';

// Types (using type-only imports)
import { type LocalSiteData, type Manifest, type ThemeInfo } from '@/core/types';

// UI Components
import { Button } from '@/core/components/ui/button';
import { Label } from '@/core/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { Input } from '@/core/components/ui/input';
import { Textarea } from '@/core/components/ui/textarea';
import { toast } from 'sonner';

export default function CreateSitePage() {
  const navigate = useNavigate(); // Hook for programmatic navigation
  const addSite = useAppStore((state) => state.addSite);

  // All state and logic is ported directly from the original component
  const [siteTitle, setSiteTitle] = useState('');
  const [siteDescription, setSiteDescription] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const availableThemes = useMemo(() => CORE_THEMES, []);
  const [selectedTheme, setSelectedTheme] = useState<ThemeInfo | null>(availableThemes[0] || null);

  const handleSubmit = async () => {
    if (!siteTitle.trim() || !selectedTheme) {
      toast.error('Site title and a theme are required.');
      return;
    }
    setIsLoading(true);
    try {
      const newSiteId = generateSiteId(siteTitle);
      const { initialConfig } = await getMergedThemeDataForForm(selectedTheme.path, {});
      
      const newManifest: Manifest = {
        siteId: newSiteId,
        generatorVersion: GENERATOR_VERSION,
        title: siteTitle.trim(),
        description: siteDescription.trim(),
        theme: {
          name: selectedTheme.path,
          config: initialConfig,
        },
        structure: [],
      };
      
      const newSiteData: LocalSiteData = {
        siteId: newSiteId,
        manifest: newManifest,
        contentFiles: [],
        themeFiles: [],
        layoutFiles: [],
      };
      
      await addSite(newSiteData);
      toast.success(`Site "${siteTitle}" created successfully!`);
      
      // Navigate to the new site's editor page
      navigate(`/sites/${newSiteId}/edit`);

    } catch (error) {
      console.error("Error during site creation:", error);
      toast.error(`Failed to create site: ${(error as Error).message}`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <>
      {/* React 19 native head management */}
      <title>Create New Site - Sparktype</title>

      <div className="container mx-auto p-4 max-w-2xl">
        <div className="space-y-6">
          <div className="flex justify-between items-center">
            <h1 className="text-3xl font-bold">Create a New Site</h1>
            {/* Use navigate(-1) to go back, which is robust */}
            <Button onClick={() => navigate(-1)} variant="outline">Cancel</Button>
          </div>

          <div className="space-y-4 p-6 border rounded-lg">
            <h2 className="text-lg font-semibold">Site Details</h2>
            <div>
              <Label htmlFor="site-title">Site Title</Label>
              <Input
                id="site-title"
                value={siteTitle}
                onChange={(e) => setSiteTitle(e.target.value)}
                placeholder="My Awesome Project"
                required
                className="mt-1"
              />
            </div>
            <div>
              <Label htmlFor="site-description">Site Description (Optional)</Label>
              <Textarea
                id="site-description"
                value={siteDescription}
                onChange={(e) => setSiteDescription(e.target.value)}
                placeholder="A short and catchy description of your new site."
                rows={3}
                className="mt-1"
              />
            </div>
            <div>
              <Label htmlFor="theme-select">Theme</Label>
              <Select 
                value={selectedTheme?.path || ''} 
                onValueChange={(themePath) => {
                  const theme = availableThemes.find(t => t.path === themePath);
                  if (theme) setSelectedTheme(theme);
                }} 
              >
                <SelectTrigger id="theme-select" className="mt-1">
                  <SelectValue placeholder="Select a theme..." />
                </SelectTrigger>
                <SelectContent>
                  {availableThemes.map(theme => (
                    <SelectItem key={theme.path} value={theme.path}>
                      {theme.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <p className="text-xs text-muted-foreground mt-1">
                Choose the overall design for your site. You can change this later.
              </p>
            </div>
          </div>

          <div className="flex justify-end">
            <Button onClick={handleSubmit} disabled={isLoading || !siteTitle.trim() || !selectedTheme} size="lg">
              {isLoading ? 'Creating...' : 'Create Site'}
            </Button>
          </div>
        </div>
      </div>
    </>
  );
}

================================================================================

File: pages/sites/SiteLayout.tsx
// src/pages/sites/SiteLayout.tsx

import { useEffect, useCallback } from 'react';
import { Link, Outlet, useParams, useLocation } from 'react-router-dom';

// State Management
import { useAppStore } from '@/core/state/useAppStore';
import { type AppStore } from '@/core/state/useAppStore';

// UI and Icons
import { TbEdit, TbSettings } from "react-icons/tb";
import { cn } from '@/core/libraries/utils';

// A simple loading component for the layout
function SiteLayoutLoader() {
    return (
        <div className="flex h-screen w-full items-center justify-center bg-muted/20">
            <div className="flex flex-col items-center gap-2">
                <svg className="animate-spin h-6 w-6 text-primary" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p className="text-sm text-muted-foreground">Loading Site Data...</p>
            </div>
        </div>
    );
}


export default function SiteLayout() {
  const { siteId } = useParams<{ siteId: string }>();
  const { pathname } = useLocation();

  // Use explicit typing for the Zustand selector
  const site = useAppStore(useCallback((state: AppStore) => siteId ? state.getSiteById(siteId) : undefined, [siteId]));
  const loadSite = useAppStore((state: AppStore) => state.loadSite);
  const setActiveSiteId = useAppStore((state: AppStore) => state.setActiveSiteId);

  useEffect(() => {
    if (siteId) {
      setActiveSiteId(siteId);
      // The condition to fetch data: siteId exists, and either the site object
      // itself is missing or its core contentFiles array is missing.
      if (!site || !site.contentFiles) {
        loadSite(siteId);
      }
    }
    return () => {
      setActiveSiteId(null);
    };
  }, [siteId, site, loadSite, setActiveSiteId]);

  // --- THIS IS THE FIX ---
  // Add a "gatekeeper" check. Do not render the children (the Outlet)
  // until the site and its essential content files are loaded into the store.
  if (!site || !site.contentFiles) {
    return <SiteLayoutLoader />;
  }

  // If we reach this point, `site` and `site.contentFiles` are guaranteed to be defined.
  
  const isEditorActive = pathname.startsWith(`/sites/${siteId}/edit`);
  const isSettingsActive = pathname.startsWith(`/sites/${siteId}/settings`);

  const navItems = [
    { to: `/sites/${siteId}/edit`, title: 'Edit', icon: TbEdit, isActive: isEditorActive },
    { to: `/sites/${siteId}/settings`, title: 'Settings', icon: TbSettings, isActive: isSettingsActive },
  ];

  return (
    <div className="flex h-screen flex-col lg:flex-row bg-muted/20">
      <aside className="fixed inset-x-0 bottom-0 z-30 flex h-16 w-full shrink-0 border-t bg-background lg:static lg:inset-y-0 lg:left-0 lg:h-full lg:w-[60px] lg:border-r lg:border-t-0">
        <nav className="flex w-full items-center justify-center gap-4 px-2 lg:flex-col lg:justify-start lg:pb-5">
          <Link
            to="/sites"
            title="Dashboard"
            className='lg:flex hidden flex-col items-center w-[60px] h-[60px] border-b'
          >
            <img src="/signum.svg" width={34} height={34} alt="Sparktype Logo" className='m-auto' />
          </Link>
          
          {navItems.map((item) => (
            <Link
              key={item.to}
              to={item.to}
              title={item.title}
              className={cn(
                'flex h-10 w-10 items-center justify-center rounded-lg transition-colors',
                item.isActive
                  ? 'bg-accent text-accent-foreground'
                  : 'text-muted-foreground hover:bg-muted/50 hover:text-foreground'
              )}
            >
              <item.icon className="size-6" />
            </Link>
          ))}
        </nav>
      </aside>

      <main className="flex-1 overflow-auto pb-16 lg:pb-0">
        <Outlet />
      </main>
    </div>
  );
}

================================================================================

File: pages/sites/SiteRootPage.tsx
// src/pages/sites/SiteRootPage.tsx

import { useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';

/**
 * A smart entry point for a site's backend.
 * Its only job is to redirect the user to the editor for that site.
 * This component handles the 'index' route for `/sites/:siteId`.
 */
export default function SiteRootPage() {
  const navigate = useNavigate();
  const { siteId } = useParams<{ siteId: string }>();

  useEffect(() => {
    if (siteId) {
      // Use `replace: true` to avoid polluting the browser's history.
      // This sends the user directly to the site editor.
      navigate(`/sites/${siteId}/edit`, { replace: true });
    }
    // This effect runs only when the siteId changes.
  }, [siteId, navigate]);

  // Display a loading message while the redirect is processed by the browser.
  return (
    <div className="flex justify-center items-center h-full">
      <p>Redirecting to editor...</p>
    </div>
  );
}

================================================================================

File: pages/sites/settings/SettingsSectionLayout.tsx
// src/pages/sites/settings/SettingsSectionLayout.tsx

import { useEffect } from 'react';
import { Outlet } from 'react-router-dom';

// UI and State Management
import ThreeColumnLayout from '@/core/components/layout/ThreeColumnLayout';
import SettingsNav from '@/features/site-settings/components/SettingsNav';
import { useUIStore } from '@/core/state/uiStore';

/**
 * The root layout for the entire settings section.
 * It provides the consistent ThreeColumnLayout structure and manages the
 * global UI state to ensure the left sidebar (with the settings menu) is
 * always visible and the right sidebar is always hidden.
 */
export default function SettingsSectionLayout() {
  const { 
    leftSidebarContent, 
    setLeftAvailable, 
    setRightAvailable, 
    setRightOpen,
    setLeftSidebarContent,
    setRightSidebarContent 
  } = useUIStore(state => state.sidebar);

  useEffect(() => {
    // Configure the sidebars for the entire settings section
    setLeftAvailable(true);
    setRightAvailable(false);
    setRightOpen(false);
    setLeftSidebarContent(<SettingsNav />);
    setRightSidebarContent(null);

    // Cleanup when navigating away from the settings section
    return () => {
      setLeftAvailable(false);
      setLeftSidebarContent(null);
    };
  }, [setLeftAvailable, setRightAvailable, setRightOpen, setLeftSidebarContent, setRightSidebarContent]);

  return (
    <ThreeColumnLayout
      leftSidebar={leftSidebarContent}
      rightSidebar={null} // No right sidebar in settings
    >
      {/* The <Outlet/> renders the specific settings page (e.g., SiteSettingsPage) */}
      <Outlet />
    </ThreeColumnLayout>
  );
}

================================================================================

File: pages/sites/settings/ThemeSettingsPage.tsx
// src/pages/sites/settings/ThemeSettingsPage.tsx

import { useEffect, useState, useCallback } from 'react';
import { useParams } from 'react-router-dom';

// State Management and Services
import { useAppStore } from '@/core/state/useAppStore';
import { getAvailableThemes } from '@/core/services/config/configHelpers.service';
import { getMergedThemeDataForForm } from '@/core/services/config/theme.service';

// Types
import { type AppStore } from '@/core/state/useAppStore';
import { type Manifest, type ThemeConfig, type ThemeInfo } from '@/core/types';
import { type RJSFSchema } from '@rjsf/utils';

// UI Components
import { Button } from '@/core/components/ui/button';
import { Label } from '@/core/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import SchemaDrivenForm from '@/core/components/SchemaDrivenForm';
import { toast } from 'sonner';

export default function ThemeSettingsPage() {
  const { siteId = '' } = useParams<{ siteId: string }>();

  // Selectors for Zustand store
  const site = useAppStore(useCallback((state: AppStore) => state.getSiteById(siteId), [siteId]));
  const updateManifestAction = useAppStore((state: AppStore) => state.updateManifest);

  // Local state for the form
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);

  // Form-specific state
  const [selectedTheme, setSelectedTheme] = useState('');
  const [formData, setFormData] = useState<Record<string, unknown>>({});
  const [schema, setSchema] = useState<RJSFSchema | null>(null);
  const [availableThemes, setAvailableThemes] = useState<ThemeInfo[]>([]);

  // Effect to initialize the form state from the store
  useEffect(() => {
    const initializeData = async () => {
      if (!site) return;
      setIsLoading(true);
      try {
        const themes = getAvailableThemes(site.manifest);
        setAvailableThemes(themes);

        const currentThemeName = site.manifest.theme.name || 'default';
        const savedConfig = site.manifest.theme.config || {};
        
        const { schema: themeSchema, initialConfig } = await getMergedThemeDataForForm(currentThemeName, savedConfig);
        
        setSchema(themeSchema);
        setFormData(initialConfig);
        setSelectedTheme(currentThemeName);
      } catch (error) {
        console.error('Failed to initialize appearance settings:', error);
        toast.error('Failed to load appearance settings');
      } finally {
        setIsLoading(false);
        setHasChanges(false);
      }
    };
    initializeData();
  }, [site]);

  // Handle changes from the dynamically generated form
  const handleFormChange = useCallback((data: object) => {
    setFormData(data as Record<string, unknown>);
    setHasChanges(true);
  }, []);

  // Handle the user selecting a new theme from the dropdown
  const handleThemeChange = useCallback(async (newThemeName: string) => {
    if (newThemeName === selectedTheme || !site) return;
    setIsLoading(true);
    try {
        const { schema: newSchema, initialConfig: newMergedConfig } = await getMergedThemeDataForForm(
            newThemeName, 
            site.manifest.theme.config, 
            selectedTheme
        );

        setSchema(newSchema);
        setFormData(newMergedConfig);
        setSelectedTheme(newThemeName);
        setHasChanges(true);
    } catch (error) {
        console.error('Failed to load new theme:', error);
        toast.error(`Failed to load theme "${newThemeName}"`);
    } finally {
        setIsLoading(false);
    }
  }, [selectedTheme, site]);


  // Persist the changes back to the store
  const handleSave = async () => {
    if (!site?.manifest) {
      toast.error('Site data not available');
      return;
    }
    setIsSaving(true);
    try {
      const newManifest: Manifest = {
        ...site.manifest,
        theme: {
          ...site.manifest.theme,
          name: selectedTheme,
          config: formData as ThemeConfig['config'],
        },
      };
      await updateManifestAction(siteId, newManifest);
      setHasChanges(false);
      toast.success('Appearance settings saved successfully!');
    } catch (error) {
      console.error('Failed to save appearance settings:', error);
      toast.error('Failed to save settings');
    } finally {
      setIsSaving(false);
    }
  };
  
  const pageTitle = `Theme Settings - ${site?.manifest?.title || 'Loading...'}`;

  if (isLoading) {
    return (
      <>
        <title>{pageTitle}</title>
        <div className="space-y-6 max-w-2xl p-6">
            <div>
                <h1 className="text-2xl font-bold">Appearance</h1>
                <p className="text-muted-foreground">Loading appearance settings...</p>
            </div>
        </div>
      </>
    );
  }

  return (
    <>
      <title>{pageTitle}</title>
      <div className="space-y-6 max-w-2xl p-6">
        <div>
          <h1 className="text-2xl font-bold">Appearance</h1>
          <p className="text-muted-foreground">Customize the visual style and branding of your site.</p>
        </div>

        <div className="border-t pt-6 space-y-6">
          <div>
            <Label htmlFor="theme-select">Active Theme</Label>
            <Select 
              value={selectedTheme} 
              onValueChange={handleThemeChange}
              disabled={isSaving || isLoading}
            >
              <SelectTrigger id="theme-select" className="mt-1">
                <SelectValue placeholder="Select a theme..." />
              </SelectTrigger>
              <SelectContent>
                {availableThemes.map((theme) => (
                  <SelectItem key={theme.path} value={theme.path}>
                    {theme.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          
          {schema?.properties && Object.keys(schema.properties).length > 0 ? (
            <div className="space-y-4">
              <h3 className="text-lg font-medium">Theme Customization</h3>
              <SchemaDrivenForm 
                schema={schema}
                formData={formData}
                onFormChange={handleFormChange}
              />
            </div>
          ) : (
            <div className="text-center border-2 border-dashed p-6 rounded-lg">
              <p className="font-semibold">No Customization Options</p>
              <p className="text-sm text-muted-foreground">
                The theme "{selectedTheme}" does not provide any customizable appearance settings.
              </p>
            </div>
          )}
        </div>

        <div className="flex justify-end pt-4 border-t">
          <Button 
            onClick={handleSave} 
            disabled={isSaving || !hasChanges || isLoading} 
            size="lg"
          >
            {isSaving ? 'Saving...' : 'Save Appearance'}
          </Button>
        </div>
      </div>
    </>
  );
}

================================================================================

File: pages/sites/settings/SiteSettingsPage.tsx
// src/pages/sites/settings/SiteSettingsPage.tsx

import { useEffect, useState, useCallback } from 'react';
import { useParams } from 'react-router-dom';

// State and Services
import { useAppStore } from '@/core/state/useAppStore';
import { getMergedThemeDataFieldsForForm } from '@/core/services/config/theme.service';
import { HtmlSanitizerService } from '@/core/services/htmlSanitizer.service';

// Types
import { type Manifest, type ImageRef } from '@/core/types';
import { type RJSFSchema } from '@rjsf/utils';

// UI Components
import { Button } from '@/core/components/ui/button';
import SiteSettingsForm from '@/features/site-settings/components/SiteSettingsForm';
import { toast } from 'sonner';

// Define the shape of the form's local state
interface PageFormData {
  title: string;
  description: string;
  author: string;
  baseUrl: string;
  logo: ImageRef | undefined;
  favicon: ImageRef | undefined;
}

export default function SiteSettingsPage() {
  const { siteId = '' } = useParams<{ siteId: string }>();

  const site = useAppStore(useCallback(state => state.getSiteById(siteId), [siteId]));
  const updateManifestAction = useAppStore(state => state.updateManifest);

  const [formData, setFormData] = useState<PageFormData | null>(null);
  const [themeDataSchema, setThemeDataSchema] = useState<RJSFSchema | null>(null);
  const [themeData, setThemeData] = useState<Record<string, unknown>>({});
  const [themeDataChanged, setThemeDataChanged] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [hasChanges, setHasChanges] = useState(false);

  const loadThemeData = useCallback(async () => {
    if (!site?.manifest?.theme?.name) return;
    try {
      const { schema, initialData } = await getMergedThemeDataFieldsForForm(
        site.manifest.theme.name,
        site.manifest.theme.themeData || {}
      );
      setThemeDataSchema(schema);
      setThemeData(initialData);
    } catch (error) {
      console.error('Failed to load theme data schema:', error);
    }
  }, [site?.manifest?.theme?.name, site?.manifest?.theme?.themeData]);

  useEffect(() => {
    if (site?.manifest) {
      setIsLoading(true);
      setFormData({
        title: site.manifest.title,
        description: site.manifest.description,
        author: site.manifest.author || '',
        baseUrl: site.manifest.baseUrl || '',
        logo: site.manifest.logo,
        favicon: site.manifest.favicon,
      });
      setHasChanges(false);
      setThemeDataChanged(false);
      loadThemeData();
      setIsLoading(false);
    }
  }, [site, loadThemeData]);

  const handleThemeDataChange = useCallback((newData: Record<string, unknown>) => {
    const sanitizedData = HtmlSanitizerService.sanitizeThemeData(newData);
    setThemeData(sanitizedData);
    setThemeDataChanged(true);
    setHasChanges(true);
  }, []);
  
  const handleFormChange = useCallback((newData: PageFormData) => {
    setFormData(newData);
    setHasChanges(true);
  }, []);

  const handleSave = async () => {
    if (!site?.manifest || !formData) {
        toast.error("Form data is not ready. Cannot save.");
        return;
    }
    setIsLoading(true);
    
    const newManifest: Manifest = {
      ...site.manifest,
      title: formData.title.trim(),
      description: formData.description.trim(),
      author: formData.author.trim(),
      baseUrl: formData.baseUrl.trim(),
      logo: formData.logo,
      favicon: formData.favicon,
      theme: {
        ...site.manifest.theme,
        themeData: themeDataChanged ? themeData : site.manifest.theme.themeData
      }
    };

    try {
      await updateManifestAction(siteId, newManifest);
      toast.success('Site settings saved successfully!');
      setHasChanges(false);
    } catch (error) {
      console.error("Error saving site settings:", error);
      toast.error("Failed to save settings. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  const pageTitle = `Settings - ${site?.manifest?.title || 'Loading...'}`;

  if (isLoading || !formData) {
    return (
      <>
        <title>{pageTitle}</title>
        <div className="p-6">Loading settings...</div>
      </>
    );
  }

  return (
    <>
      <title>{pageTitle}</title>
      <div className="space-y-6 max-w-2xl p-6">
        <div>
          <h1 className="text-2xl font-bold">Site Settings</h1>
          <p className="text-muted-foreground">Manage the core details and identity of your website.</p>
        </div>

        <div className="border-t pt-6">
          <SiteSettingsForm
            siteId={siteId}
            formData={formData}
            onFormChange={handleFormChange}
            themeDataSchema={themeDataSchema || undefined}
            themeData={themeData}
            onThemeDataChange={handleThemeDataChange}
          />
        </div>

        <div className="flex justify-end pt-4">
          <Button onClick={handleSave} disabled={isLoading || !hasChanges} size="lg">
            {isLoading ? 'Saving...' : 'Save Settings'}
          </Button>
        </div>
      </div>
    </>
  );
}

================================================================================

File: pages/sites/settings/ImageSettingsPage.tsx
// src/pages/sites/settings/ImageSettingsPage.tsx

import { useEffect, useState, useCallback } from 'react';
import { useParams } from 'react-router-dom';

// State Management
import { useAppStore } from '@/core/state/useAppStore';
import { type AppStore } from '@/core/state/useAppStore';

// Types
import { type Manifest } from '@/core/types';
import { type SiteSecrets } from '@/core/services/siteSecrets.service';

// UI Components
import { Button } from '@/core/components/ui/button';
import { Label } from '@/core/components/ui/label';
import { Input } from '@/core/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/core/components/ui/select';
import { toast } from 'sonner';

type ImageServiceId = 'local' | 'cloudinary';

export default function ImageSettingsPage() {
  const { siteId = '' } = useParams<{ siteId: string }>();

  // Selectors for Zustand store
  const site = useAppStore(useCallback((state: AppStore) => state.getSiteById(siteId), [siteId]));
  const updateManifestAction = useAppStore((state: AppStore) => state.updateManifest);
  const updateSiteSecretsAction = useAppStore((state: AppStore) => state.updateSiteSecrets);

  // Local state for the form
  const [selectedService, setSelectedService] = useState<ImageServiceId>('local');
  const [cloudinaryCloudName, setCloudinaryCloudName] = useState('');
  const [cloudinaryUploadPreset, setCloudinaryUploadPreset] = useState('');
  const [isLoading, setIsLoading] = useState(true);
  const [hasChanges, setHasChanges] = useState(false);

  // Effect to populate the form's local state from the global store on mount.
  useEffect(() => {
    if (site?.manifest) {
      setIsLoading(true);
      const { imageService, cloudinary } = site.manifest.settings || {};
      setSelectedService(imageService || 'local');
      setCloudinaryCloudName(cloudinary?.cloudName || '');
      setCloudinaryUploadPreset(site.secrets?.cloudinary?.uploadPreset || '');
      setHasChanges(false);
      setIsLoading(false);
    }
  }, [site]); // Re-run if the site object in the store changes.
  
  const handleServiceChange = (value: string) => {
    setSelectedService(value as ImageServiceId);
    setHasChanges(true);
  };
  
  const handleInputChange = (setter: React.Dispatch<React.SetStateAction<string>>, value: string) => {
    setter(value);
    setHasChanges(true);
  };

  const handleSave = async () => {
    if (!site?.manifest) {
      toast.error("Site data not available. Cannot save settings.");
      return;
    }
    setIsLoading(true);

    const newManifest: Manifest = {
      ...site.manifest,
      settings: {
        ...site.manifest.settings,
        imageService: selectedService,
        cloudinary: {
            cloudName: cloudinaryCloudName.trim(),
        },
      },
    };

    const newSecrets: SiteSecrets = {
      ...site.secrets, // Preserve other potential secrets
      cloudinary: {
          uploadPreset: cloudinaryUploadPreset.trim(),
      }
    };

    try {
      // These actions persist data and update the global state.
      // Toasts for success are now handled inside the actions for consistency.
      await updateManifestAction(siteId, newManifest);
      await updateSiteSecretsAction(siteId, newSecrets);
      setHasChanges(false);
    } catch(error) {
      console.error("An error occurred during save:", error);
      // Let the action's own toast handle the error message.
    } finally {
      setIsLoading(false);
    }
  };

  const pageTitle = `Image Settings - ${site?.manifest?.title || 'Loading...'}`;

  if (isLoading || !site) {
    return (
      <>
        <title>{pageTitle}</title>
        <div className="p-6">Loading image settings...</div>
      </>
    );
  }
  
  return (
    <>
      <title>{pageTitle}</title>
      <div className="space-y-6 max-w-2xl p-6">
        <div>
          <h1 className="text-2xl font-bold">Image Settings</h1>
          <p className="text-muted-foreground">Configure how images are stored and processed for your site.</p>
        </div>

        <div className="border-t pt-6 space-y-6">
          <div className="space-y-2">
            <Label htmlFor="service-select">Image Storage Backend</Label>
            <Select value={selectedService} onValueChange={handleServiceChange}>
              <SelectTrigger id="service-select" className="mt-1">
                <SelectValue placeholder="Select a service..." />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="local">Store in Site Bundle (Default)</SelectItem>
                <SelectItem value="cloudinary">Upload to Cloudinary</SelectItem>
              </SelectContent>
            </Select>
            <p className="text-xs text-muted-foreground">"Local" is best for portability. "Cloudinary" is best for performance.</p>
          </div>
          
          {selectedService === 'cloudinary' && (
            <div className="p-4 border rounded-lg bg-card space-y-4">
              <h3 className="font-semibold text-card-foreground">Cloudinary Settings</h3>
              <div className="space-y-2">
                <Label htmlFor="cloud-name">Cloudinary Cloud Name (Public)</Label>
                <Input
                  id="cloud-name"
                  value={cloudinaryCloudName}
                  onChange={(e) => handleInputChange(setCloudinaryCloudName, e.target.value)}
                  placeholder="e.g., your-cloud-name"
                />
                <p className="text-xs text-muted-foreground">This is public and stored in your site's manifest.</p>
              </div>
              <div className="space-y-2">
                <Label htmlFor="upload-preset">Cloudinary Upload Preset (Secret)</Label>
                <Input
                  id="upload-preset"
                  type="password"
                  value={cloudinaryUploadPreset}
                  onChange={(e) => handleInputChange(setCloudinaryUploadPreset, e.target.value)}
                  placeholder="e.g., ml_default"
                />
                <p className="text-xs text-muted-foreground">This is a secret and is stored securely in your browser, not in your public site files.</p>
              </div>
            </div>
          )}
        </div>

        <div className="flex justify-end pt-4">
          <Button onClick={handleSave} disabled={isLoading || !hasChanges} size="lg">
            {isLoading ? 'Saving...' : 'Save Image Settings'}
          </Button>
        </div>
      </div>
    </>
  );
}

================================================================================

File: pages/sites/edit/EditSiteLayout.tsx
// src/pages/sites/edit/EditSiteLayout.tsx

import { Outlet } from 'react-router-dom';

/**
 * The root layout for the /edit section.
 *
 * In the Vite + react-router-dom architecture, this layout's primary role
 * is to provide a mounting point for its child routes via the `<Outlet />`
 * component. It can also be used to wrap all editor pages in a common
 * context or layout if needed in the future.
 */
export default function EditSiteLayout() {
  // The <Outlet /> component from react-router-dom will render the
  // matched child route. For example, if the URL is /sites/123/edit/content/about,
  // the EditContentPage component will be rendered here.
  return <Outlet />;
}

================================================================================

File: pages/sites/edit/EditContentPage.tsx
// src/pages/sites/edit/EditContentPage.tsx

import { useMemo, useEffect, useRef } from 'react';
import { useParams } from 'react-router-dom';

// Global State and UI Management
import { useUIStore } from '@/core/state/uiStore';
import { useAppStore } from '@/core/state/useAppStore';

// UI Components
import { Button } from '@/core/components/ui/button';
import { FilePlus, LayoutGrid } from 'lucide-react';
import ThreeColumnLayout from '@/core/components/layout/ThreeColumnLayout';
import LeftSidebar from '@/features/editor/components/LeftSidebar';
import NewPageDialog from '@/features/editor/components/NewPageDialog';
import CreateCollectionPageDialog from '@/features/editor/components/CreateCollectionPageDialog';
import BlocknoteEditor, { type BlocknoteEditorRef } from '@/features/editor/components/BlocknoteEditor';
import FrontmatterSidebar from '@/features/editor/components/FrontmatterSidebar';
import PrimaryContentFields from '@/features/editor/components/PrimaryContentFields';
import CollectionItemList from '@/features/editor/components/CollectionItemList';
import SaveButton from '@/features/editor/components/SaveButton';

// Modular Hooks
import { usePageIdentifier } from '@/features/editor/hooks/usePageIdentifier';
import { useFileContent } from '@/features/editor/hooks/useFileContent';
import { useFilePersistence } from '@/features/editor/hooks/useFilePersistence';

export default function EditContentPage() {
  const editorRef = useRef<BlocknoteEditorRef>(null);
  
  const { siteId = '' } = useParams<{ siteId: string }>();

  const site = useAppStore(state => siteId ? state.getSiteById(siteId) : undefined);
  
  const siteStructure = site?.manifest.structure || [];
  const allContentFiles = useMemo(() => site?.contentFiles || [], [site?.contentFiles]);
  const siteManifest = site?.manifest;
  const siteLayoutFiles = site?.layoutFiles;
  const siteThemeFiles = site?.themeFiles;

  const { isNewFileMode, filePath } = usePageIdentifier({ siteStructure, allContentFiles });
  
  const { status, frontmatter, initialBlocks, slug, setSlug, handleFrontmatterChange, onContentModified } = useFileContent(siteId, filePath, isNewFileMode);
  const { handleDelete } = useFilePersistence({ siteId, filePath, isNewFileMode, frontmatter, slug, getEditorContent: () => editorRef.current?.getBlocks() ?? [] });
  
  const { leftSidebarContent, rightSidebarContent, setLeftAvailable, setRightAvailable, setLeftSidebarContent, setRightSidebarContent } = useUIStore(state => state.sidebar);

  const isCollectionPage = useMemo(() => !!frontmatter?.collection, [frontmatter]);

  const rightSidebarComponent = useMemo(() => {
    if (status !== 'ready' || !frontmatter || !siteId || !siteManifest) return null;
    return (
      <FrontmatterSidebar
        siteId={siteId}
        filePath={filePath}
        manifest={siteManifest}
        layoutFiles={siteLayoutFiles}
        themeFiles={siteThemeFiles}
        allContentFiles={allContentFiles}
        frontmatter={frontmatter}
        onFrontmatterChange={handleFrontmatterChange}
        isNewFileMode={isNewFileMode}
        slug={slug}
        onSlugChange={setSlug}
        onDelete={handleDelete}
      />
    );
  }, [status, frontmatter, siteId, filePath, allContentFiles, handleFrontmatterChange, isNewFileMode, slug, setSlug, handleDelete, siteLayoutFiles, siteManifest, siteThemeFiles]);

  useEffect(() => {
    setLeftAvailable(true);
    setLeftSidebarContent(<LeftSidebar />);
    return () => { setLeftAvailable(false); setLeftSidebarContent(null); };
  }, [setLeftAvailable, setLeftSidebarContent]);

  useEffect(() => {
    if (rightSidebarComponent) {
      setRightAvailable(true);
      setRightSidebarContent(rightSidebarComponent);
    } else {
      setRightAvailable(false);
      setRightSidebarContent(null);
    }
    return () => { setRightAvailable(false); setRightSidebarContent(null); };
  }, [rightSidebarComponent, setRightAvailable, setRightSidebarContent]);

  const isSiteEmpty = siteId && siteStructure.length === 0 && !isNewFileMode;
  
  const pageTitle = status === 'ready' && frontmatter?.title 
    ? `Editing: ${frontmatter.title} | ${site?.manifest.title || 'Sparktype'}` 
    : `Editor - ${site?.manifest.title || 'Sparktype'}`;

  // --- THIS IS THE FIX ---
  // Define the header actions as a separate variable *before* the return statement.
  // This makes it clear to TypeScript that this prop is not related to the children.
  const headerActions = isSiteEmpty ? null : <SaveButton />;

  return (
    <>
      <title>{pageTitle}</title>

      <ThreeColumnLayout
        leftSidebar={leftSidebarContent}
        rightSidebar={isSiteEmpty ? null : rightSidebarContent}
        headerActions={headerActions} // Pass the variable here
      >
        {isSiteEmpty ? (
          <div className="flex flex-col items-center justify-center h-full text-center p-8 bg-background">
            <h2 className="text-2xl font-bold mb-2">Create Your Homepage</h2>
            <p className="text-muted-foreground mb-6 max-w-md">Your site is empty. The first page you create will become your site's permanent homepage.</p>
            {/* These dialogs are now just children and have no relation to the headerActions prop. */}
            <div className="flex gap-4">
              <NewPageDialog siteId={siteId}><Button size="lg"><FilePlus className="mr-2 h-5 w-5" /> Create Content Page</Button></NewPageDialog>
              <CreateCollectionPageDialog siteId={siteId}><Button size="lg" variant="outline"><LayoutGrid className="mr-2 h-5 w-5" /> Create Collection Page</Button></CreateCollectionPageDialog>
            </div>
          </div>
        ) : (
          (() => {
            if (status !== 'ready' || !frontmatter || !filePath) {
              return <div className="p-6 flex justify-center items-center h-full"><p>Loading Editor...</p></div>;
            }
            return (
              <div className='flex h-full w-full flex-col'>
                <div className='container mx-auto flex h-full max-w-[900px] flex-col p-6'>
                  <div className="shrink-0"><PrimaryContentFields frontmatter={frontmatter} onFrontmatterChange={handleFrontmatterChange} /></div>
                  <div className="mt-6 flex-grow min-h-0">
                    {isCollectionPage ? (
                      <CollectionItemList siteId={siteId} collectionPagePath={filePath} />
                    ) : (
                      <BlocknoteEditor ref={editorRef} key={filePath} initialContent={initialBlocks} onContentChange={onContentModified} />
                    )}
                  </div>
                </div>
              </div>
            );
          })()
        )}
      </ThreeColumnLayout>
    </>
  );
}

================================================================================

File: pages/sites/view/ViewSitePage.tsx
// src/pages/sites/view/ViewSitePage.tsx

import SiteViewer from '@/features/viewer/components/SiteViewer';
import { useAppStore } from '@/core/state/useAppStore';
import { useCallback } from 'react';
import { useParams } from 'react-router-dom';

export default function ViewSitePage() {
  const { siteId = '' } = useParams<{ siteId: string }>();
  const site = useAppStore(useCallback((state) => state.getSiteById(siteId), [siteId]));

  const pageTitle = `Preview: ${site?.manifest?.title || 'Loading...'}`;

  return (
    <>
      <title>{pageTitle}</title>
      
      {/*
        This page's only job is to render the master preview component.
        The SiteViewer component itself will read the URL and parameters
        to determine what to render inside the iframe.
      */}
      <SiteViewer />
    </>
  );
}

================================================================================

