// src/core/state/slices/contentSlice.ts

import { type StateCreator } from 'zustand';
import { produce } from 'immer';
import { toast } from 'sonner';

// Core Types and Services
import { type ParsedMarkdownFile, type StructureNode, type LocalSiteData, type CollectionItemRef, type MarkdownFrontmatter } from '@/core/types';
import * as localSiteFs from '@/core/services/localFileSystem.service';
import { saveContentFile } from '@/core/services/localFileSystem.service';
import { findAndRemoveNode, updatePathsRecursively, findNodeByPath, getDescendantIds } from '@/core/services/fileTree.service';
import { getCollections } from '@/core/services/collections.service';
import { stringifyToMarkdown, parseMarkdownString } from '@/core/libraries/markdownParser';
import { type SiteSlice } from '@/core/state/slices/siteSlice';
import { createTagGroup, updateTagGroup, deleteTagGroup, getTagGroups, getTagGroupsForCollection } from '@/core/services/tagGroups.service';
import { createTag, updateTag, deleteTag, getTags, getTagsInGroup } from '@/core/services/tags.service';
import type { TagGroup, Tag } from '@/core/types';
import { updateImageReferences } from '@/core/services/images/imageRegistry.service';
import { findImagesInContentFile } from '@/core/services/images/imageReferenceFinder.service';

// Helper: Generates an up-to-date list of collection item references.
function buildCollectionItemRefs(siteData: LocalSiteData): CollectionItemRef[] {
  const collections = getCollections(siteData.manifest);
  const newCollectionItems: CollectionItemRef[] = [];
  for (const collection of collections) {
    const items = (siteData.contentFiles || []).filter((file: ParsedMarkdownFile) => file.path.startsWith(collection.contentPath));
    for (const item of items) {
      // Extract just the filename part of the slug, removing the collection path
      const collectionPathSlug = collection.contentPath.replace(/^content\//, '').replace(/\/$/, '');
      const itemSlug = item.slug.startsWith(collectionPathSlug + '/') 
        ? item.slug.substring(collectionPathSlug.length + 1)
        : item.slug.split('/').pop() || item.slug;
      
      newCollectionItems.push({ 
        collectionId: collection.id, 
        slug: itemSlug, 
        path: item.path, 
        title: item.frontmatter.title || item.slug, 
        url: '' // Will be generated by URL service when needed
      });
    }
  }
  return newCollectionItems;
}

// Helper: Updates content file paths immutably.
const updateContentFilePaths = (files: ParsedMarkdownFile[], pathsToMove: { oldPath: string; newPath: string }[]): ParsedMarkdownFile[] => {
  const pathMap = new Map(pathsToMove.map(p => [p.oldPath, p.newPath]));
  return files.map(file => {
    if (pathMap.has(file.path)) {
      const newPath = pathMap.get(file.path)!;
      const newSlug = newPath.replace(/^content\//, '').replace(/\.md$/, '');
      return { ...file, path: newPath, slug: newSlug };
    }
    return file;
  });
};

// Helper: Calculates path changes for slug update (parent + children)
const calculateSlugPathChanges = (currentFilePath: string, newSlug: string, currentNode: StructureNode): { oldPath: string; newPath: string }[] => {
  const currentSlug = currentFilePath.replace(/^content\//, '').replace(/\.md$/, '');
  const newFilePath = `content/${newSlug}.md`;

  const pathsToMove: { oldPath: string; newPath: string }[] = [];

  // Add the main file
  pathsToMove.push({ oldPath: currentFilePath, newPath: newFilePath });

  // Add any descendant pages
  if (currentNode.children) {
    const descendantPaths = getDescendantIds([currentNode]);
    for (const descendantPath of descendantPaths) {
      // Calculate new path for descendant by replacing the parent slug part
      const relativePath = descendantPath.replace(`content/${currentSlug}`, '');
      const newDescendantPath = `content/${newSlug}${relativePath}`;
      pathsToMove.push({ oldPath: descendantPath, newPath: newDescendantPath });
    }
  }

  return pathsToMove;
};

// Helper: Updates structure node paths immutably
const updateStructurePaths = (structure: StructureNode[], pathsToMove: { oldPath: string; newPath: string }[]): StructureNode[] => {
  const pathMap = new Map(pathsToMove.map(p => [p.oldPath, p.newPath]));

  const updateNodePaths = (nodes: StructureNode[]): StructureNode[] => {
    return nodes.map(node => {
      const updatedNode = { ...node };

      if (pathMap.has(node.path)) {
        const newPath = pathMap.get(node.path)!;
        const newSlug = newPath.replace(/^content\//, '').replace(/\.md$/, '');
        updatedNode.path = newPath;
        updatedNode.slug = newSlug;
      }

      if (node.children) {
        updatedNode.children = updateNodePaths(node.children);
      }

      return updatedNode;
    });
  };

  return updateNodePaths(structure);
};

export interface ContentSlice {
  addOrUpdateContentFile: (siteId: string, filePath: string, rawMarkdownContent: string, silent?: boolean) => Promise<boolean>;
  deleteContentFileAndState: (siteId: string, filePath: string) => Promise<void>;
  repositionNode: (siteId: string, activeNodePath: string, newParentPath: string | null, newIndex: number) => Promise<void>;
  updateContentFileOnly: (siteId: string, savedFile: ParsedMarkdownFile, silent?: boolean) => Promise<void>;
  setAsHomepage: (siteId: string, filePath: string) => Promise<void>;
  changePageSlug: (siteId: string, currentFilePath: string, newSlug: string) => Promise<{ success: boolean; newFilePath?: string; error?: string }>;
  changePageSlugWithContent: (siteId: string, currentFilePath: string, newSlug: string, frontmatter: MarkdownFrontmatter, content: string) => Promise<{ success: boolean; newFilePath?: string; error?: string }>;
  
  // Tag Group operations
  createTagGroup: (siteId: string, tagGroupData: Omit<TagGroup, 'id'>) => Promise<void>;
  updateTagGroup: (siteId: string, groupId: string, updates: Partial<Omit<TagGroup, 'id'>>) => Promise<void>;
  deleteTagGroup: (siteId: string, groupId: string) => Promise<void>;
  getApplicableTagGroups: (siteId: string, collectionId?: string) => TagGroup[];
  
  // Tag operations
  createTag: (siteId: string, tagData: Omit<Tag, 'id'>) => Promise<void>;
  updateTag: (siteId: string, tagId: string, updates: Partial<Omit<Tag, 'id'>>) => Promise<void>;
  deleteTag: (siteId: string, tagId: string) => Promise<void>;
  getTagsForGroup: (siteId: string, groupId: string) => Tag[];
}

export const createContentSlice: StateCreator<SiteSlice & ContentSlice, [], [], ContentSlice> = (set, get) => ({
  
  updateContentFileOnly: async (siteId, savedFile, silent = false) => {
    if (!savedFile) {
      console.error('SavedFile is undefined in updateContentFileOnly');
      return;
    }
    
    // Get site data for manifest and serialization options
    // const _site = get().getSiteById(siteId); // Not currently used

    // Serialize to markdown (blocks are empty in our current implementation)
    const markdownContent = stringifyToMarkdown(savedFile.frontmatter, savedFile.content);
    
    await localSiteFs.saveContentFile(siteId, savedFile.path, markdownContent);

    // Update image references in registry
    try {
      const referencedImages = findImagesInContentFile(savedFile);
      await updateImageReferences(siteId, savedFile.path, referencedImages);
      if (referencedImages.length > 0) {
        console.log(`[ContentSlice] Updated image references for ${savedFile.path}: ${referencedImages.length} images`);
      }
    } catch (error) {
      console.warn(`[ContentSlice] Failed to update image references for ${savedFile.path}:`, error);
      // Don't fail content saving if registry update fails
    }

    // If silent mode (for autosave), skip state updates to prevent re-renders
    if (silent) {
      console.log('Silent mode: Skipping state updates to prevent re-renders');
      return;
    }

    set(produce((draft: SiteSlice) => {
      const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
      if (!siteToUpdate?.contentFiles) return;
      
      const fileIndex = siteToUpdate.contentFiles.findIndex(f => f.path === savedFile.path);
      if (fileIndex !== -1) siteToUpdate.contentFiles[fileIndex] = savedFile;
      else siteToUpdate.contentFiles.push(savedFile);
    }));

    const siteData = get().getSiteById(siteId);
    if (!siteData) return;

    const newManifest = produce(siteData.manifest, (draft: any) => {
        draft.collectionItems = buildCollectionItemRefs(siteData as LocalSiteData);
        
        // Sync frontmatter changes to structure nodes
        const findAndUpdateStructureNode = (nodes: StructureNode[]): void => {
          for (const node of nodes) {
            if (node.path === savedFile.path) {
              node.title = savedFile.frontmatter.title;
              node.menuTitle = typeof savedFile.frontmatter.menuTitle === 'string' ? savedFile.frontmatter.menuTitle : undefined;
              return;
            }
            if (node.children) findAndUpdateStructureNode(node.children);
          }
        };
        findAndUpdateStructureNode(draft.structure);
    });

    await get().updateManifest(siteId, newManifest);
  },

  addOrUpdateContentFile: async (siteId, filePath, rawMarkdownContent, silent) => {
    const site = get().getSiteById(siteId);
    if (!site) return false;

    // Check if this is the first file being created for the site
    let processedContent = rawMarkdownContent;
    const isFirstFile = site.manifest.structure.length === 0 && !site.contentFiles?.some(f => f.path === filePath);

    if (isFirstFile) {
      // Parse the frontmatter and mark as homepage
      const { frontmatter, content } = parseMarkdownString(rawMarkdownContent);
      const updatedFrontmatter = { ...frontmatter, homepage: true };
      processedContent = stringifyToMarkdown(updatedFrontmatter, content);
      toast.info("First page created. It has been set as the permanent homepage.");
    }

    const savedFile = await localSiteFs.saveContentFile(siteId, filePath, processedContent);

    // Update image references in registry
    try {
      const referencedImages = findImagesInContentFile(savedFile);
      await updateImageReferences(siteId, savedFile.path, referencedImages);
      if (referencedImages.length > 0) {
        console.log(`[ContentSlice] Updated image references for ${savedFile.path}: ${referencedImages.length} images`);
      }
    } catch (error) {
      console.warn(`[ContentSlice] Failed to update image references for ${savedFile.path}:`, error);
      // Don't fail content saving if registry update fails
    }

    // Determine if this is a new file that needs to be added to the navigation structure.
    const isNewFileInStructure = !findNodeByPath(site.manifest.structure, filePath);

    // Default to silent mode for existing files, non-silent only for new files
    const shouldBeSilent = silent !== undefined ? silent : !isNewFileInStructure;

    // Atomically create the new manifest with all necessary updates.
    const newManifest = produce(site.manifest, draft => {
      if (isNewFileInStructure) {
        // Determine if this is a collection item by checking path against collection contentPaths
        const collections = getCollections(draft);
        const isCollectionPage = savedFile?.frontmatter?.collection;
        const isCollectionItem = !isCollectionPage && collections.some(c => savedFile.path.startsWith(c.contentPath));

        // Only add to structure if it's NOT a collection item
        // Collection items should be managed separately and not appear in navigation
        if (!isCollectionItem) {
          const newNode: StructureNode = {
            type: 'page',
            title: savedFile.frontmatter.title,
            menuTitle: typeof savedFile.frontmatter.menuTitle === 'string' ? savedFile.frontmatter.menuTitle : undefined,
            path: filePath,
            slug: savedFile.slug,
            navOrder: draft.structure.length,
            children: []
          };
          draft.structure.push(newNode);
        }
      } else {
        // If it's an existing file, update its title and menuTitle in the structure.
        const findAndUpdate = (nodes: StructureNode[]): void => {
          for (const node of nodes) {
            if (node.path === filePath) { 
              node.title = savedFile.frontmatter.title; 
              node.menuTitle = typeof savedFile.frontmatter.menuTitle === 'string' ? savedFile.frontmatter.menuTitle : undefined;
              return; 
            }
            if (node.children) findAndUpdate(node.children);
          }
        };
        findAndUpdate(draft.structure);
      }
    });

    // Update both manifest and contentFiles atomically in a single state update (unless silent)
    if (!shouldBeSilent) {
      set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (!siteToUpdate) return;
        if (!siteToUpdate.contentFiles) siteToUpdate.contentFiles = [];

        // Update the manifest structure (copy the structure from newManifest)
        siteToUpdate.manifest.structure = newManifest.structure;

        // Update contentFiles array
        const fileIndex = siteToUpdate.contentFiles.findIndex(f => f.path === savedFile.path);
        if (fileIndex !== -1) siteToUpdate.contentFiles[fileIndex] = savedFile;
        else siteToUpdate.contentFiles.push(savedFile);
        
        // Rebuild the collection item index based on the latest contentFiles.
        siteToUpdate.manifest.collectionItems = buildCollectionItemRefs(siteToUpdate as LocalSiteData);
      }));
    }

    // Persist the final manifest to disk (including updated collectionItems)
    const finalManifest = get().getSiteById(siteId)!.manifest;
    await get().updateManifest(siteId, finalManifest);

    return true;
  },
    
  deleteContentFileAndState: async (siteId, filePath) => {
    const site = get().getSiteById(siteId);
    if (!site) return;
    
    const fileToDelete = site.contentFiles?.find(f => f.path === filePath);
    if (fileToDelete?.frontmatter.homepage === true) {
      toast.error("Cannot delete the homepage.", { description: "The first page of a site is permanent." });
      return;
    }

    // First, update the manifest structure.
    const newManifest = produce(site.manifest, draft => {
      const filterStructure = (nodes: StructureNode[]): StructureNode[] => nodes.filter(node => {
        if (node.path === filePath) return false;
        if (node.children) node.children = filterStructure(node.children);
        return true;
      });
      draft.structure = filterStructure(draft.structure);
    });

    // Persist changes and delete the file in parallel.
    await Promise.all([
      localSiteFs.deleteContentFile(siteId, filePath),
      get().updateManifest(siteId, newManifest),
    ]);

    // Update the in-memory state and sync collectionItems.
    set(produce((draft: SiteSlice) => {
      const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
      if (!siteToUpdate?.contentFiles) return;
      siteToUpdate.contentFiles = siteToUpdate.contentFiles.filter(f => f.path !== filePath);
      siteToUpdate.manifest.collectionItems = buildCollectionItemRefs(siteToUpdate as LocalSiteData);
    }));
    
    // Save the final manifest with the updated collectionItems.
    const finalManifest = get().getSiteById(siteId)!.manifest;
    await localSiteFs.saveManifest(siteId, finalManifest);

    toast.success(`Page "${fileToDelete?.frontmatter.title || 'file'}" deleted.`);
  },
    
  repositionNode: async (siteId, activeNodePath, newParentPath, newIndex) => {
    const site = get().getSiteById(siteId);
    if (!site?.contentFiles || !site.manifest) {
      toast.error("Site data not ready. Cannot move page.");
      return;
    }
    const { structure } = site.manifest;
    if (activeNodePath === structure[0]?.path) {
      toast.error("The homepage cannot be moved.");
      return;
    }

    const { found: activeNode, tree: treeWithoutActive } = findAndRemoveNode([...structure], activeNodePath);
    if (!activeNode) return;

    const newParentDir = newParentPath ? newParentPath.replace(/\.md$/, '') : 'content';
    const finalActiveNode = updatePathsRecursively(activeNode, newParentDir);
    
    const pathsToMove: { oldPath: string; newPath: string }[] = [];
    const collectPaths = (newNode: StructureNode, oldNode: StructureNode) => {
        if (newNode.path !== oldNode.path) pathsToMove.push({ oldPath: oldNode.path, newPath: newNode.path });
        if (newNode.children && oldNode.children) newNode.children.forEach((child, i) => collectPaths(child, oldNode.children![i]));
    };
    collectPaths(finalActiveNode, activeNode);
    
    const finalTree = produce(treeWithoutActive, (draft: StructureNode[]) => {
        if (newParentPath) {
            const parent = findNodeByPath(draft, newParentPath);
            if (parent) {
                parent.children = parent.children || [];
                parent.children.splice(newIndex, 0, finalActiveNode);
            }
        } else {
            draft.splice(newIndex, 0, finalActiveNode);
        }
    });
    
    try {
      if (pathsToMove.length > 0) await localSiteFs.moveContentFiles(siteId, pathsToMove);
      
      const newManifest = { ...site.manifest, structure: finalTree };
      await get().updateManifest(siteId, newManifest);

      set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (!siteToUpdate) return;
        siteToUpdate.contentFiles = updateContentFilePaths(siteToUpdate.contentFiles!, pathsToMove);
        siteToUpdate.manifest.collectionItems = buildCollectionItemRefs(siteToUpdate as LocalSiteData);
      }));

      const finalManifest = get().getSiteById(siteId)!.manifest;
      await localSiteFs.saveManifest(siteId, finalManifest);

      toast.success("Site structure updated successfully.");
    } catch (error) {
      console.error("Failed to reposition node:", error);
      toast.error("An error occurred while updating the site structure. Reverting changes.");
      get().loadSite(siteId);
    }
  },

  // Set a page as the site homepage
  setAsHomepage: async (siteId: string, filePath: string) => {
    try {
      const site = get().getSiteById(siteId);
      if (!site?.contentFiles) {
        toast.error("Site data not found");
        return;
      }

      // Find the current homepage
      const currentHomepage = site.contentFiles.find(f => f.frontmatter.homepage === true);
      const targetFile = site.contentFiles.find(f => f.path === filePath);

      if (!targetFile) {
        toast.error("Page not found");
        return;
      }

      if (targetFile.frontmatter.homepage === true) {
        toast.info("This page is already the homepage");
        return;
      }

      // Update frontmatter for both files
      const updates: Array<{ path: string; frontmatter: any }> = [];

      // Clear current homepage
      if (currentHomepage) {
        const updatedCurrentFrontmatter = { ...currentHomepage.frontmatter };
        delete updatedCurrentFrontmatter.homepage;
        updates.push({ path: currentHomepage.path, frontmatter: updatedCurrentFrontmatter });
      }

      // Set new homepage
      const updatedTargetFrontmatter = { ...targetFile.frontmatter, homepage: true };
      updates.push({ path: filePath, frontmatter: updatedTargetFrontmatter });

      // Apply updates and update state
      set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (!siteToUpdate?.contentFiles) return;

        // Update frontmatter in state
        for (const update of updates) {
          const file = siteToUpdate.contentFiles.find(f => f.path === update.path);
          if (file) {
            file.frontmatter = update.frontmatter;
          }
        }
      }));

      // Apply updates to filesystem
      for (const update of updates) {
        const file = site.contentFiles.find(f => f.path === update.path);
        if (file) {
          const updatedContent = stringifyToMarkdown(update.frontmatter, file.content);
          await saveContentFile(siteId, update.path, updatedContent);
        }
      }

      // Move new homepage to top of structure
      set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (!siteToUpdate?.manifest.structure) return;

        const structure = [...siteToUpdate.manifest.structure];
        const targetNodeIndex = structure.findIndex(node => node.path === filePath);
        
        if (targetNodeIndex > 0) {
          // Move homepage to top
          const [homepageNode] = structure.splice(targetNodeIndex, 1);
          structure.unshift(homepageNode);
          
          // Update structure in state
          siteToUpdate.manifest.structure = structure;
        }
      }));

      // Save updated manifest to filesystem
      const finalSite = get().getSiteById(siteId);
      if (finalSite?.manifest) {
        await localSiteFs.saveManifest(siteId, finalSite.manifest);
      }

      toast.success("Homepage updated successfully");
    } catch (error) {
      console.error("Failed to set as homepage:", error);
      toast.error("Failed to set as homepage");
    }
  },


  // === TAG GROUP OPERATIONS ===

  createTagGroup: async (siteId: string, tagGroupData: Omit<TagGroup, 'id'>) => {
    try {
      const siteData = get().getSiteById(siteId);
      if (!siteData) {
        toast.error("Site not found");
        return;
      }

      const { manifest: updatedManifest, tagGroup } = createTagGroup(siteData.manifest, tagGroupData);
      
      // Update state
      set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate) {
          siteToUpdate.manifest = updatedManifest;
        }
      }));

      // Persist to filesystem
      await get().updateManifest(siteId, updatedManifest);
      
      toast.success(`Tag group "${tagGroup.name}" created successfully!`);
    } catch (error) {
      console.error("Failed to create tag group:", error);
      toast.error(`Failed to create tag group: ${(error as Error).message}`);
    }
  },

  updateTagGroup: async (siteId: string, groupId: string, updates: Partial<Omit<TagGroup, 'id'>>) => {
    try {
      const siteData = get().getSiteById(siteId);
      if (!siteData) {
        toast.error("Site not found");
        return;
      }

      const updatedManifest = updateTagGroup(siteData.manifest, groupId, updates);
      
      // Update state
      set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate) {
          siteToUpdate.manifest = updatedManifest;
        }
      }));

      // Persist to filesystem
      await get().updateManifest(siteId, updatedManifest);
      
      toast.success("Tag group updated successfully!");
    } catch (error) {
      console.error("Failed to update tag group:", error);
      toast.error(`Failed to update tag group: ${(error as Error).message}`);
    }
  },

  deleteTagGroup: async (siteId: string, groupId: string) => {
    try {
      const siteData = get().getSiteById(siteId);
      if (!siteData) {
        toast.error("Site not found");
        return;
      }

      const tagGroup = getTagGroups(siteData.manifest).find(tg => tg.id === groupId);
      const { manifest: updatedManifest } = deleteTagGroup(siteData.manifest, groupId);
      
      // Update state
      set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate) {
          siteToUpdate.manifest = updatedManifest;
        }
      }));

      // Persist to filesystem
      await get().updateManifest(siteId, updatedManifest);
      
      toast.success(`Tag group "${tagGroup?.name}" deleted successfully!`);
    } catch (error) {
      console.error("Failed to delete tag group:", error);
      toast.error(`Failed to delete tag group: ${(error as Error).message}`);
    }
  },

  getApplicableTagGroups: (siteId: string, collectionId?: string) => {
    const siteData = get().getSiteById(siteId);
    if (!siteData) return [];
    
    if (collectionId) {
      return getTagGroupsForCollection(siteData.manifest, collectionId);
    }
    
    return getTagGroups(siteData.manifest);
  },

  // === TAG OPERATIONS ===

  createTag: async (siteId: string, tagData: Omit<Tag, 'id'>) => {
    try {
      const siteData = get().getSiteById(siteId);
      if (!siteData) {
        toast.error("Site not found");
        return;
      }

      const { manifest: updatedManifest, tag } = createTag(siteData.manifest, tagData);
      
      // Update state
      set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate) {
          siteToUpdate.manifest = updatedManifest;
        }
      }));

      // Persist to filesystem
      await get().updateManifest(siteId, updatedManifest);
      
      toast.success(`Tag "${tag.name}" created successfully!`);
    } catch (error) {
      console.error("Failed to create tag:", error);
      toast.error(`Failed to create tag: ${(error as Error).message}`);
    }
  },

  updateTag: async (siteId: string, tagId: string, updates: Partial<Omit<Tag, 'id'>>) => {
    try {
      const siteData = get().getSiteById(siteId);
      if (!siteData) {
        toast.error("Site not found");
        return;
      }

      const updatedManifest = updateTag(siteData.manifest, tagId, updates);
      
      // Update state
      set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate) {
          siteToUpdate.manifest = updatedManifest;
        }
      }));

      // Persist to filesystem
      await get().updateManifest(siteId, updatedManifest);
      
      toast.success("Tag updated successfully!");
    } catch (error) {
      console.error("Failed to update tag:", error);
      toast.error(`Failed to update tag: ${(error as Error).message}`);
    }
  },

  deleteTag: async (siteId: string, tagId: string) => {
    try {
      const siteData = get().getSiteById(siteId);
      if (!siteData) {
        toast.error("Site not found");
        return;
      }

      const tag = getTags(siteData.manifest).find(t => t.id === tagId);
      const { manifest: updatedManifest } = deleteTag(siteData.manifest, tagId);
      
      // Update state
      set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (siteToUpdate) {
          siteToUpdate.manifest = updatedManifest;
        }
      }));

      // Persist to filesystem
      await get().updateManifest(siteId, updatedManifest);
      
      toast.success(`Tag "${tag?.name}" deleted successfully!`);
    } catch (error) {
      console.error("Failed to delete tag:", error);
      toast.error(`Failed to delete tag: ${(error as Error).message}`);
    }
  },

  getTagsForGroup: (siteId: string, groupId: string) => {
    const siteData = get().getSiteById(siteId);
    if (!siteData) return [];
    
    return getTagsInGroup(siteData.manifest, groupId);
  },

  changePageSlugWithContent: async (siteId: string, currentFilePath: string, newSlug: string, frontmatter: MarkdownFrontmatter, content: string) => {
    try {
      // Mark slug change as in progress
      const appStore = get() as any; // Cast to access other slice methods
      if (appStore.markSlugChangeInProgress) {
        appStore.markSlugChangeInProgress(siteId);
      }

      const siteData = get().getSiteById(siteId);
      if (!siteData) {
        return { success: false, error: "Site not found" };
      }

      // Validate new slug
      if (!newSlug || newSlug.trim() === '') {
        return { success: false, error: "Slug cannot be empty" };
      }

      // Get current file
      const currentFile = siteData.contentFiles?.find(f => f.path === currentFilePath);
      if (!currentFile) {
        return { success: false, error: "Current file not found" };
      }

      const currentSlug = currentFile.slug;

      // If slug hasn't changed, do nothing
      if (currentSlug === newSlug) {
        return { success: true, newFilePath: currentFilePath };
      }

      // Check for homepage - cannot change homepage slug
      if (currentFile.frontmatter.homepage === true) {
        return { success: false, error: "Cannot change the slug of the homepage" };
      }

      // Check if new slug already exists
      const newFilePath = `content/${newSlug}.md`;
      const slugExists = siteData.contentFiles?.some(f => f.slug === newSlug);
      if (slugExists) {
        return { success: false, error: `A page with the slug "${newSlug}" already exists` };
      }

      // Find current node in structure
      const currentNode = findNodeByPath(siteData.manifest.structure, currentFilePath);
      if (!currentNode) {
        return { success: false, error: "Page not found in site structure" };
      }

      // Calculate all path changes using our new helper
      const pathsToMove = calculateSlugPathChanges(currentFilePath, newSlug, currentNode);

      // Validate all new paths don't already exist
      for (const pathMove of pathsToMove) {
        if (pathMove.newPath !== newFilePath) { // We already checked the main file
          const pathExists = siteData.contentFiles?.some(f => f.path === pathMove.newPath);
          if (pathExists) {
            return { success: false, error: `Cannot move page - path "${pathMove.newPath}" already exists` };
          }
        }
      }

      // Update the main file's content with current editor content before moving
      const updatedMainFile = {
        ...currentFile,
        frontmatter: { ...frontmatter },
        content
      };
      const mainFileMarkdown = stringifyToMarkdown(updatedMainFile.frontmatter, updatedMainFile.content);
      await localSiteFs.saveContentFile(siteId, currentFilePath, mainFileMarkdown);

      // Perform atomic file system operations (move files)
      await localSiteFs.moveContentFiles(siteId, pathsToMove);

      // Update state atomically - both structure and contentFiles together
      set(produce((draft: SiteSlice) => {
        const siteToUpdate = draft.sites.find(s => s.siteId === siteId);
        if (!siteToUpdate) return;

        // Update manifest structure paths
        siteToUpdate.manifest.structure = updateStructurePaths(siteToUpdate.manifest.structure, pathsToMove);

        // Update contentFiles paths
        if (siteToUpdate.contentFiles) {
          siteToUpdate.contentFiles = updateContentFilePaths(siteToUpdate.contentFiles, pathsToMove);

          // Update the main file's content in the moved file
          const movedMainFile = siteToUpdate.contentFiles.find(f => f.path === newFilePath);
          if (movedMainFile) {
            movedMainFile.frontmatter = { ...frontmatter };
            movedMainFile.content = content;
          }
        }

        // Rebuild the collection item index
        siteToUpdate.manifest.collectionItems = buildCollectionItemRefs(siteToUpdate as LocalSiteData);
      }));

      // Persist the updated manifest to disk
      const finalSite = get().getSiteById(siteId);
      if (finalSite?.manifest) {
        await get().updateManifest(siteId, finalSite.manifest);
      }

      // Force a complete site reload to ensure all components get fresh data
      await get().loadSite(siteId);

      // Mark slug change as complete
      if (appStore.markSlugChangeComplete) {
        appStore.markSlugChangeComplete(siteId);
      }

      toast.success(`Page slug changed from "${currentSlug}" to "${newSlug}"`);

      return {
        success: true,
        newFilePath
      };

    } catch (error) {
      console.error("Failed to change page slug:", error);
      const errorMessage = `Failed to change slug: ${(error as Error).message}`;
      toast.error(errorMessage);

      // Mark slug change as complete even on error
      const appStore = get() as any;
      if (appStore.markSlugChangeComplete) {
        appStore.markSlugChangeComplete(siteId);
      }

      return { success: false, error: errorMessage };
    }
  },

  changePageSlug: async (siteId: string, currentFilePath: string, newSlug: string) => {
    try {
      const site = get().getSiteById(siteId);
      if (!site) {
        return { success: false, error: "Site not found" };
      }

      // Validate new slug
      if (!newSlug || newSlug.trim() === '') {
        return { success: false, error: "Slug cannot be empty" };
      }

      // Get current file
      const currentFile = site.contentFiles?.find(f => f.path === currentFilePath);
      if (!currentFile) {
        return { success: false, error: "Current file not found" };
      }

      const currentSlug = currentFile.slug;
      
      // If slug hasn't changed, do nothing
      if (currentSlug === newSlug) {
        return { success: true, newFilePath: currentFilePath };
      }

      // Check for homepage - cannot change homepage slug
      if (currentFile.frontmatter.homepage === true) {
        return { success: false, error: "Cannot change the slug of the homepage" };
      }

      // Check if new slug already exists
      const newFilePath = `content/${newSlug}.md`;
      const slugExists = site.contentFiles?.some(f => f.slug === newSlug);
      if (slugExists) {
        return { success: false, error: `A page with the slug "${newSlug}" already exists` };
      }

      // Find current node in structure
      const currentNode = findNodeByPath(site.manifest.structure, currentFilePath);
      if (!currentNode) {
        return { success: false, error: "Page not found in site structure" };
      }

      // Collect all affected pages (current page + any descendants)
      const affectedPaths = [currentFilePath];
      if (currentNode.children) {
        affectedPaths.push(...getDescendantIds([currentNode]));
      }

      // Backup all affected content before deletion
      const contentBackup = [];
      for (const path of affectedPaths) {
        const file = site.contentFiles?.find(f => f.path === path);
        if (file) {
          // Calculate new path for this file
          let newPath: string;
          if (path === currentFilePath) {
            // This is the main file being changed
            newPath = newFilePath;
          } else {
            // This is a descendant - update its path to use the new slug
            const relativePath = path.replace(`content/${currentSlug}`, '');
            newPath = `content/${newSlug}${relativePath}`;
          }
          
          contentBackup.push({
            originalPath: path,
            newPath,
            frontmatter: { ...file.frontmatter },
            content: file.content
          });
        }
      }

      // Validate all new paths don't already exist
      for (const backup of contentBackup) {
        if (backup.newPath !== newFilePath) { // We already checked the main file
          const pathExists = site.contentFiles?.some((f: ParsedMarkdownFile) => f.path === backup.newPath);
          if (pathExists) {
            return { success: false, error: `Cannot recreate page - path "${backup.newPath}" already exists` };
          }
        }
      }

      // Delete all affected pages (in reverse order to avoid structure issues)
      for (let i = affectedPaths.length - 1; i >= 0; i--) {
        await get().deleteContentFileAndState(siteId, affectedPaths[i]);
      }

      // Recreate all pages with new paths
      const results = [];
      for (const backup of contentBackup) {
        const markdownContent = stringifyToMarkdown(backup.frontmatter, backup.content);
        const success = await get().addOrUpdateContentFile(siteId, backup.newPath, markdownContent);
        results.push({ path: backup.newPath, success });
        
        if (!success) {
          console.error(`Failed to recreate file: ${backup.newPath}`);
          // Continue with other files rather than failing completely
        }
      }

      // Check if all recreations were successful
      const allSuccessful = results.every(r => r.success);
      if (!allSuccessful) {
        const failedPaths = results.filter(r => !r.success).map(r => r.path);
        toast.error(`Some pages could not be recreated: ${failedPaths.join(', ')}`);
      }

      toast.success(`Page slug changed from "${currentSlug}" to "${newSlug}"`);
      
      return { 
        success: true, 
        newFilePath,
        error: allSuccessful ? undefined : "Some descendant pages failed to recreate"
      };
      
    } catch (error) {
      console.error("Failed to change page slug:", error);
      const errorMessage = `Failed to change slug: ${(error as Error).message}`;
      toast.error(errorMessage);
      return { success: false, error: errorMessage };
    }
  },
});